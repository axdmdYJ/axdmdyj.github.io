<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法60天训练–10-03-day24</title>
      <link href="/2023/10/03/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%9310-03-day24/"/>
      <url>/2023/10/03/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%9310-03-day24/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题相当于是在</p><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a>多了一个判断找出的集合之和等于n的判断</p><p>因为数只能取从1 ~ 9</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>回溯三部曲</p><ul><li>第一曲:确定递归函数参数</li></ul><p>依然定义path 和 result为全局变量</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>targetSum（int）目标和，也就是题目中的n。</li><li>k（int）就是题目中要求k个数的集合。</li><li>sum（int）为已经收集的元素的总和，也就是path里元素的总和。</li><li>startIndex（int）为下一层for循环搜索的起始位置。</li></ul></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure><p>补充一下: 回溯算法递归的参数很难一次确定,需要用到什么参数,填什么参数</p><ul><li>第二曲:确定终止条件</li></ul><p>跟组合一样,遍历到第k层其实就已经将树的深度遍历完了</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == targetSum) result.push_back(path);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三曲: 单层搜索</li></ul><p>每一层都是遍历的数都是上一层的数<code>-1</code>,因为集合中不能出现重复的数</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    path.push_back(i);</span><br><span class="line">    backtracking(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">    sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">    path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考这段代码的时候,暂时不要去考虑backtracking里面的过程,直接到<code>sum  -= i</code>和<code>pop.pop_back</code>,然后进行下一层for循环,这两个相当于是清理战场了,然后换一个<code>i</code>再打一遍</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum) &#123;</span><br><span class="line">                res.push_back(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//单层搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> ; i++)&#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backtracking(targetSum,k,sum,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>如果已经选的元素 已经大于<code>targetSum</code>了,那么也没有必要继续往下遍历了</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝操作</span></span><br><span class="line"><span class="keyword">if</span>(sum) &gt; targetSum&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终代码</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; targetSum) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum) &#123;</span><br><span class="line">                res.push_back(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//单层搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> ; i++)&#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backtracking(targetSum,k,sum,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>本题一眼看可以暴力,因为如果<code>digit = 2</code>, 那么两层for魂环酒后了. 但如果<code>digit=10086</code> 层呢,for循环是并不可能的. 这是和<a href="https://leetcode.cn/problems/combinations/">77. 组合</a>在刚开始分析时一样的问题</p><p>理解本题后，要解决如下三个问题：</p><ul><li>数字和字母如何映射</li><li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来</li><li>输入1 * #按键等等异常情况</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="数字和字母如何映射"></a>数字和字母如何映射</h3><p>可以用<code>map</code>, 或者定义一个二维数组,</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="built_in">string</span> letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回溯法来解决n个for循环的问题"><a href="#回溯法来解决n个for循环的问题" class="headerlink" title="回溯法来解决n个for循环的问题"></a>回溯法来解决n个for循环的问题</h3><p>依然是: 深度就是字母集合的长度</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>第一曲: 确定回溯函数参数</li></ul><p>这个在实际做题中不可能一下子想出来,用到什么写什么</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;<span class="comment">//字符串数组result保存起来</span></span><br><span class="line"><span class="built_in">string</span> s;<span class="comment">//收集叶子节点的结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; digits, <span class="type">int</span> index)</span><span class="comment">//记录遍历第几个数字</span></span><br></pre></td></tr></table></figure><p>const string&amp; digit相当于取了一个别名,引用digit但不改变其字符串内容</p><ul><li>确定终止条件</li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(intdex == digits.size())&#123;<span class="comment">//遍历到树底了</span></span><br><span class="line">    result.push_back(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定单层遍历逻辑</li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line"><span class="built_in">string</span> letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.size(); i++) &#123;</span><br><span class="line">    s.push_back(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">    backtracking(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">    s.pop_back();                       <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的for循环并不是从startIndex开始遍历的</strong> <strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合</strong>，<strong>而<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>都是求同一个集合中的组合！</strong></p><p>注意：输入1 * #按键等等异常情况</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="built_in">string</span> letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; digits, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.size())&#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">string</span> letters = letterMap[digit];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.size(); i++)&#123;</span><br><span class="line">            s.push_back(letters[i]);</span><br><span class="line">            backtracking(digits, index + <span class="number">1</span>);</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        backtracking(digits,<span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–10-02-day23</title>
      <link href="/2023/10/02/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%9310-02-day23/"/>
      <url>/2023/10/02/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%9310-02-day23/</url>
      
        <content type="html"><![CDATA[<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果 <code>k = 2</code></p><p>就直接可以用两层for循环可以解决</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果 <code> k = 10086呢</code> 不可能去用10086层for循环</p><p>这时候可以考虑取用回溯算法来解决暴力都解决不了的问题</p><p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p><blockquote><p>此时,在 <code>n = 100 , k = 50的时候</code> 就是递归50层</p></blockquote><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong></p><p>对于一个集合,相当于是递归树的宽度,而k相当于是递归的深度</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归的返回值以及参数</li></ul><p>先定义两个全局变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br></pre></td></tr></table></figure><ul><li>回溯函数的三个参数</li></ul><p>n, 集合大小.   k 组合集合的大小(树的深度)</p><p><strong>startIndex</strong> 记录下一层递归从哪开始,避免重复</p><p>比如1,2,3,4下一层就要从2开始</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure><ul><li>回溯终止条件</li></ul><p>path数组的大小等于k时,找到了一个子集大小为k的组合,在path存的就是根节点到叶子结点的路径</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">    result.push_back(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单层搜索的过程</li></ul><p>for循环, &#x3D;&gt;  横向遍历集合</p><p>递归 &#x3D;&gt; 纵向遍历</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">    path.push_back(i); <span class="comment">// 处理节点</span></span><br><span class="line">    backtracking(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">    path.pop_back(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯模版"><a href="#回溯模版" class="headerlink" title="回溯模版"></a>回溯模版</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= n; i++)&#123;</span><br><span class="line">            path.push_back(i); <span class="comment">// 处理结点</span></span><br><span class="line">            backtracking(n , k , i+<span class="number">1</span>); <span class="comment">//递归,不能使用++i改变原来的值</span></span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k , <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n ; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n, k , i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">            backtracking(n , k , <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h1><p>回溯法虽然是暴力搜索,但有时候也是可以剪枝优化的</p><p>在遍历中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当n &#x3D; 9, k &#x3D; 9, 那么 起始从2开始到9也不到9个数,</p><p>这个地方就可以剪枝了</p><ul><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ul><p>举一个<code>n = 9</code>  <code>k  - 4</code> 就知道上面三步操作是为什么了</p><p>for循环优化后</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) <span class="comment">// i为本次搜索的起始位置</span></span><br></pre></td></tr></table></figure><h1 id="Code-剪枝优化"><a href="#Code-剪枝优化" class="headerlink" title="Code(剪枝优化)"></a>Code(剪枝优化)</h1><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 优化的地方</span></span><br><span class="line">            path.push_back(i); <span class="comment">// 处理节点</span></span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.pop_back(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-21-day16</title>
      <link href="/2023/09/24/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-21-day16/"/>
      <url>/2023/09/24/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-21-day16/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求最大深度, 首先可以想到,前序遍历和后序遍历</p><p>对于求深度,和求高度.都可以用后序遍历,因为一个二叉树的最大深度和最大的高度是相等的</p><p>那么如何求最大深度呢?</p><p>可以使用递归,即递归的求左右两节点的长度, 并将左右两节点的长度取最大值.</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241939134.png" alt="image-20230924185157004"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getdepth</span><span class="params">(TreeNode* node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = getdepth(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightdepth = getdepth(node-&gt;right);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + max(leftdepth,rightdepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getdepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getdepth</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftdepth</span> <span class="operator">=</span> getdepth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightdepth</span> <span class="operator">=</span> getdepth(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(leftdepth,rightdepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getdepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一眼看其实和求<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>类似,但还是有很多细节的区别的</p><p>因为当在根结点有空的子节点的时候就会出现错误</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241856074.png" alt="image-20230924185607931"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode* node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = getDepth(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = getDepth(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span> &amp;&amp;node-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + min(leftDepth,rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span> + Math.min(leftDepth,rightDepth);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>比较容易想到的就是后序遍历,做法跟前两道是一样的.</p><p>但因为是一个完全二叉树,根据完全二叉树的性质,我们又可以采用另一种方法</p><p>:<img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241941772.png" alt="image-20230924194150634"></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> getCount(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> getCount(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">countNodes</span> <span class="operator">=</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getCount(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用完全二叉树性质"><a href="#利用完全二叉树性质" class="headerlink" title="利用完全二叉树性质"></a>利用完全二叉树性质</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-19-day14</title>
      <link href="/2023/09/19/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-19-day14/"/>
      <url>/2023/09/19/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-19-day14/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树理论基础"><a href="#1-二叉树理论基础" class="headerlink" title="1. 二叉树理论基础"></a>1. 二叉树理论基础</h1><h2 id="1-1-二叉树的种类"><a href="#1-1-二叉树的种类" class="headerlink" title="1.1 二叉树的种类"></a>1.1 二叉树的种类</h2><ul><li>满二叉树: 每一个节点的子节点都为0或2</li><li>完全二叉树: 除了最底层的结点,其他结点每层节点数都达到最大值</li><li>二叉搜索树:所有左结点的值都小于根结点</li><li>平衡二叉树: 左右两个子树高度最大值不能超过1</li></ul><h2 id="1-2-二叉树存储方式"><a href="#1-2-二叉树存储方式" class="headerlink" title="1.2 二叉树存储方式"></a>1.2 二叉树存储方式</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储的元素在内存中是连续分布的，通常用数组来存储。如果父节点的数组下标是 root，那么它的左孩子就是 root * 2 + 1，右孩子就是 root * 2 + 2。</p><h3 id="1-3-二叉树的遍历方式"><a href="#1-3-二叉树的遍历方式" class="headerlink" title="1.3 二叉树的遍历方式"></a>1.3 二叉树的遍历方式</h3><ul><li><p>深度优先遍历 </p></li><li><blockquote><p>前序遍历,中序遍历, 后序遍历</p></blockquote></li><li><p>广度优先遍历</p></li><li><blockquote><p>层序遍历</p></blockquote></li></ul><h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Struct twoTreeNode&#123;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">twoTreeNode *left;</span><br><span class="line">twoTreeNode *right;</span><br><span class="line">twoTreeNode(<span class="type">int</span> x): val(x),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-18-day13</title>
      <link href="/2023/09/18/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-18-day13/"/>
      <url>/2023/09/18/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-18-day13/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为要求滑动窗口中的最大值,</p><p>所以比较容易实现的便是,自己定义一个结构,能够让队列头始终是滑动窗口中最大的:</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309190106567.png" alt="image-20230919010607211"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309190106585.png" alt="image-20230919010613196"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQue</span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; value == deque.peek())&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty()  &amp;&amp; val &gt; deque.getLast())&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> deque.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k  + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 存放结果元素的数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">MyQue</span> <span class="variable">myque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[num++] = myque.peek();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++)&#123;</span><br><span class="line">        myque.poll(nums[i-k]);</span><br><span class="line"></span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">        res[num++] = myque.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++:</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQue</span>&#123;</span></span><br><span class="line">    Deque&lt;Integer&gt; <span class="built_in">deque</span> = new LinkedList&lt;&gt;();</span><br><span class="line">    <span class="type">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">deque</span>.isEmpty() &amp;&amp; value == <span class="built_in">deque</span>.peek())&#123;</span><br><span class="line">            <span class="built_in">deque</span>.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">deque</span>.isEmpty()  &amp;&amp; val &gt; <span class="built_in">deque</span>.getLast())&#123;</span><br><span class="line">                <span class="built_in">deque</span>.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">deque</span>.add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deque</span>.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = nums.length - k  + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 存放结果元素的数组</span></span><br><span class="line">    <span class="type">int</span>[] res = new <span class="type">int</span>[len];</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MyQue myque = new MyQue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[num++] = myque.peek();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">        myque.poll(nums[i-k]);</span><br><span class="line"></span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">        res[num++] = myque.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session区别</title>
      <link href="/2023/09/17/Cookie%E5%92%8CSession%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/09/17/Cookie%E5%92%8CSession%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Cookie和Session都用于管理用户的状态和身份，但它们在存储位置、数据容量、安全性和传输方式等方面存在一些关键区别，下面通过具体示例来说明这些区别：</p><ol><li><p>存储位置：</p><ul><li><strong>Cookie</strong>：Cookie数据存储在用户的浏览器中。这意味着服务器可以将一些信息存储在用户的计算机上，以便在后续请求中使用。</li><li><strong>Session</strong>：Session数据存储在服务器上，不会在用户浏览器中留下痕迹。</li></ul></li><li><p>数据容量：</p><ul><li><strong>Cookie</strong>：Cookie的存储容量通常较小，一般限制在几KB。这适用于存储少量的文本数据，如用户首选项或购物车中的几个商品。</li><li><strong>Session</strong>：Session的存储容量通常较大，不受明确定义的限制，因为它们可以利用服务器的资源，用于存储更多的数据，如用户登录状态、购物车内容等。</li></ul></li><li><p>安全性：</p><ul><li><strong>Cookie</strong>：由于Cookie存储在用户浏览器中，它们容易受到安全威胁。例如，Cookie可以被用户查看和修改，从而可能引发安全漏洞。</li><li><strong>Session</strong>：Session数据存储在服务器上，不容易被用户直接访问或篡改，因此相对更安全。</li></ul></li><li><p>传输方式：</p><ul><li><strong>Cookie</strong>：每次用户向服务器发送HTTP请求时，浏览器会自动将相关的Cookie信息附加到请求头中，以便服务器可以提取这些信息。</li><li><strong>Session</strong>：通常，Session ID会存储在Cookie中或者通过URL参数传递给服务器。服务器使用Session ID来查找并还原用户的会话数据。</li></ul></li></ol><p>示例：<br>假设有一个在线购物网站，用户在登录后可以将商品添加到购物车。以下是Cookie和Session在这个场景中的应用：</p><ul><li><p><strong>Cookie的应用</strong>：当用户登录后，服务器可以创建一个包含用户ID和购物车内容的Cookie，并在用户的浏览器中存储。每次用户浏览不同商品或查看购物车时，浏览器都会自动将Cookie信息发送到服务器，服务器通过Cookie中的用户ID来识别用户，并获取购物车内容。然而，由于Cookie易于修改，用户可能尝试篡改购物车中的商品数量。</p></li><li><p><strong>Session的应用</strong>：当用户登录后，服务器创建一个与该用户相关联的Session，其中包含用户ID和购物车内容等信息。Session数据存储在服务器上，而不会发送到用户浏览器中。每次用户进行操作时，服务器使用Session ID（通常存储在Cookie中）来查找并还原用户的购物车内容，而用户无法直接修改Session数据，因为它们位于服务器上，更加安全。</p></li></ul><p>综上所述，Cookie和Session在不同情况下用于管理用户状态和身份，具有各自的优势和限制，开发人员应根据应用程序的需求和安全性考虑选择合适的机制。</p>]]></content>
      
      
      <categories>
          
          <category> 每日八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-15-day10</title>
      <link href="/2023/09/15/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-15-day10/"/>
      <url>/2023/09/15/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-15-day10/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先应该先明确队列是先进先出,</p><p>而栈是先进后出,而如果想用栈实现队列,就可以尝试用两个栈</p><p>进栈和出栈</p><ul><li>进栈模拟入队列</li><li>出栈模拟先出队列</li></ul><p>画图如下</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309171830073.png" alt="image-20230917183021976"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stIn;</span><br><span class="line">Stack&lt;Integer&gt; stOut;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      stIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">stIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span>(stOut.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stIn.isEmpty())&#123;</span><br><span class="line">        stOut.push(stIn.pop());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="built_in">this</span>.pop();</span><br><span class="line">stOut.push(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stOut.isEmpty()&amp;&amp;stIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line"></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">stIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(stOut.empty())&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stIn.empty())&#123;</span><br><span class="line">        stOut.push(stIn.top());</span><br><span class="line">        stIn.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> result = stOut.top();</span><br><span class="line">stOut.pop();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> res = this-&gt;pop();</span><br><span class="line">stOut.push(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stIn.empty()&amp;&amp;stOut.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度: push和empty为O(1), pop和peek为O(n)</p><p>空间复杂度: O(n)</p><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>队列是先进先出原则,</p><p>而栈是先进后出原则</p><p>因此,可以使用两个队列来实现栈</p><p><strong>可以使用一个队列来实现栈</strong></p><p>满足先进后出的方法就是; 入队列之后,就将这个数放到队首</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309171847163.png" alt="image-20230917184757095"></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">que.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> size = que.size();</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">while</span>(size--)&#123;</span><br><span class="line">    que.push(que.front());</span><br><span class="line">    que.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> que.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> que.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            que.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="keyword">return</span> que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que.poll();</span><br><span class="line">        que.add(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rePosition</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que.add(que.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: pop为O(n)，其他为O(1)</li><li>空间复杂度: O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-13-day8</title>
      <link href="/2023/09/14/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-13-day8/"/>
      <url>/2023/09/14/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-13-day8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="Problem-344-反转字符串"><a href="#Problem-344-反转字符串" class="headerlink" title="Problem: 344. 反转字符串"></a>Problem: <a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义两个指针,分别初始化为指向左端点和指向右端点,</p><p>当<code>l &lt; r</code>的时候,说明二者已将字符转遍历完</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140023893.png" alt="image-20230914002307799"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[l];</span><br><span class="line">                s[l] = s[r];</span><br><span class="line">                s[r] = temp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-541-反转字符串-II"><a href="#Problem-541-反转字符串-II" class="headerlink" title="Problem: 541. 反转字符串 II"></a>Problem: <a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符,所以可以定义一个指针 i ,来从起点,以2k的长度来遍历,</p><p>在遍历的同时,需要判断此时的位置是否超出字符串的长度</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140114051.png" alt="image-20230914003144804"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140032858.png" alt="image-20230914003241823"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140038341.png" alt="image-20230914003825298"></p><blockquote><p>比较容易疑惑的就是边界问题</p><p>例如:<code>if(i + k &lt;= ch.length)</code>在这个判断条件下,<code>ch.length - 1</code>也能通过,</p><p>这是因为,这一步边界的判断是为了操作最后剩余的数,事实上,在for循环里,循环条件便是i &lt; ch.length,所以到最后一步后,操作是统一的,都是<code> reverse(ch, i, ch.length-1); reverse(ch, i, ch.length-1);</code>这里的reverse是自己实现的左闭右闭原则</p></blockquote><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &lt;= ch.length)&#123;</span><br><span class="line">                reverse(ch , i, i+k-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(ch, i, ch.length-<span class="number">1</span>); <span class="comment">//这里自己实现的reverse是左闭右闭原则,所以ch.length-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= j; i++,j--)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[i];</span><br><span class="line">            ch[i] = ch[j];</span><br><span class="line">            ch[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-题目：剑指Offer-05-替换空格"><a href="#Problem-题目：剑指Offer-05-替换空格" class="headerlink" title="Problem: 题目：剑指Offer 05.替换空格"></a>Problem: <a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/">题目：剑指Offer 05.替换空格</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为要把空格替换为“%20”, 所以容易知道:</p><p>数组的长度是需要扩大的,可以在原数组增大,或者创建一个新的数组</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140049824.png" alt="image-20230914004917681"></p><p>可以定义两个指针,从新数组最后往前遍历,和从老数组后往前遍历,这样可以省去从前往后每次遇到空格需要挪动数组的操作</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140058237.png" alt="image-20230914005831852"></p><p>将 <code>j</code>遍历的字符赋值给<code>i</code>, 如果遇到空格, <code>i</code>就独自往前赋值为“%20”, 然后和<code>j</code>继续重复以上操作</p><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line">        <span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>可以利用StringBuilder来从前往后遍历,如果遇到空格,就<code>append(&quot;%20&quot;)</code></p><p>其余就<code>qppend(&quot;字符&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(s.charAt(i));</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-11-day6</title>
      <link href="/2023/09/11/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-11-day6/"/>
      <url>/2023/09/11/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-11-day6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="242-有效字母的异位词"><a href="#242-有效字母的异位词" class="headerlink" title="242.有效字母的异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">242.有效字母的异位词</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>简单的两层for循环,同时记录字符是否重复出现,很明显时间复杂度是$O(n^2)$</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p><p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong> 这样就将字符串s中字符出现的次数，统计出来了。</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142128713.png" alt="image-20230914212802619"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142130536.png" alt="image-20230914213003490"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">      <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">        record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">        record[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(record[i] != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为是找 <strong>交集</strong>, 所以可以先去重:</p><ul><li>先将nums1放在Set容器中,(不包含重复元素)</li><li>然后遍历nums2元素,查看Set容器中是否包含nums2元素</li><li>如果包括:就放在另一个resSet集合中</li></ul><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(mn)</li><li>空间复杂度: O(n)</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i))</span><br><span class="line">            set2.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return set2.stream().mapToInt(x-&gt;x).toArray();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法二: 再申请一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:set2)&#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; resSet;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">numsSet</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  i: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numsSet.<span class="built_in">find</span>(i) != numsSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                resSet.<span class="built_in">insert</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(resSet.<span class="built_in">begin</span>(),resSet.<span class="built_in">end</span>()); <span class="comment">//强制转化为数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以可以考虑哈希法</p><ul><li><p>第一步: 首先可以定义一个<code>set</code>存放数据,避免重复.</p></li><li><p>第二步: 然后再while(true)中无限循环,先求出一个数各单数平方的和相加</p></li><li><p>第三步:如果这个数为1, 直接返回true </p></li><li><p>第四步:否则继续向下判断:在set中是否出现过,如果出现过,说明这个数永远不能到1, 即不是一个快乐数.  如果没出现过,那么就将这个和</p></li></ul><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(logn)</li><li>空间复杂度: O(logn)</li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> set.add(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C+&#x3D;"></a>C+&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n)&#123;</span><br><span class="line">                sum+=(n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">                n/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.<span class="built_in">insert</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        n = sum;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><strong>再回想一下为什么使用哈希法?</strong></p><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>选用map来存储key value,为了寻找两个数,将数的值作为<code>key</code> 数的下标作为<code>value</code></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142234874.png" alt="image-20230914223409718"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142234658.png" alt="image-20230914223416547"></p><h2 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="comment">// 看是否与target匹配的ket</span></span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没找到匹配对,就把访问过的下标加入到map中</span></span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(target-nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo n 算法60天训练–9-10-day5</title>
      <link href="/2023/09/10/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-10-day5/"/>
      <url>/2023/09/10/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-10-day5/</url>
      
        <content type="html"><![CDATA[<h1 id="周日-休息日"><a href="#周日-休息日" class="headerlink" title="周日,休息日"></a>周日,休息日</h1>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-8-day3</title>
      <link href="/2023/09/10/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-8-day3/"/>
      <url>/2023/09/10/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-8-day3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="算法60天训练–9-8-day3"><a href="#算法60天训练–9-8-day3" class="headerlink" title="算法60天训练–9-8-day3"></a>算法60天训练–9-8-day3</h1><p>[TOC]</p><p>(画图有些不规范)</p><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先删除一个链表元素,无非就是将要删除的链表结点的上一个结点指向这个被删除链表的下一个结点</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101051269.png" alt="image-20230910105127232"></p><p>这里在刚开始将<code>cur = dummy_head</code>,是为了将删除头结点的操作和其他结点的操作统一</p><p>即永远操作的结点都为<code>cur-&gt;next</code></p><p>直到为空,在这个过程中找到要被删除的结点,执行删除操作</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h3 id="Code-JAVA"><a href="#Code-JAVA" class="headerlink" title="Code(JAVA)"></a>Code(JAVA)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy_Node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy_Node.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy_Node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">else</span> cur  = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_Node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/description/">707. 设计链表</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这是一个比较综合的题目</p><h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><p>这个跟其他链表元素有区别,将<code>cur = dummyhead-&gt;next</code> 是为了解决index等于0的情况,避免没有进入while循环而造成直接返回return cur-&gt;val; </p><h4 id="addAtHead"><a href="#addAtHead" class="headerlink" title="addAtHead"></a>addAtHead</h4><p>在 链表头插入时要注意顺序问题</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101053274.png" alt="image-20230910105320233"></p><h4 id="addAtTail"><a href="#addAtTail" class="headerlink" title="addAtTail"></a>addAtTail</h4><p>直接在结尾插入即可</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101053862.png" alt="image-20230910105345821"></h4><h4 id="addAtIndex"><a href="#addAtIndex" class="headerlink" title="addAtIndex"></a>addAtIndex</h4><p>还是注意插入的顺序问题</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101054396.png" alt="image-20230910105438357"></p><h4 id="deleteAtIndex"><a href="#deleteAtIndex" class="headerlink" title="deleteAtIndex"></a>deleteAtIndex</h4><p>找到要删除的结点,将该结点的上一个结点指向下一个结点</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101050621.png" alt="image-20230910011347372"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度: 涉及 index 的相关操作为 O(index), 其余为 O(1)</p><p>空间复杂度: O(n)</p><h3 id="Code-C"><a href="#Code-C" class="headerlink" title="Code(C++)"></a>Code(C++)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummy_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; (_size<span class="number">-1</span>) || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = dummy_head-&gt;next;<span class="comment">//要在虚拟头节点的下一个结点,以解决index等于0的情况</span></span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">         ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">         newNode-&gt;next = dummy_head-&gt;next;</span><br><span class="line">         dummy_head-&gt;next = newNode; </span><br><span class="line">         _size++;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">         ListNode* cur = dummy_head;</span><br><span class="line">         ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">         <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">             cur = cur-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">         cur-&gt;next = newNode;</span><br><span class="line">         _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode* cur = dummy_head;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; _size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">           cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">         newNode-&gt;next = cur-&gt;next;<span class="comment">//要保证操作的节点是cur-&gt;next;</span></span><br><span class="line">         cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size<span class="number">-1</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要保证第n个结点一定要是cur-&gt;next;</span></span><br><span class="line">        ListNode* cur = dummy_head;</span><br><span class="line">        ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">          cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next; </span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    ListNode* dummy_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>定义一个temp,来临时存放cur-&gt;next,这样在cur-&gt;next &#x3D; pre之后,才能将cur &#x3D; temp到下一个结点去</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101050994.png" alt="image-20230910012140226"></p><h3 id="Code-JAVA-1"><a href="#Code-JAVA-1" class="headerlink" title="Code(JAVA)"></a>Code(JAVA)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = cur.next; <span class="comment">//因为如果将cur指向pre后就无法找到cur的下一个节点了</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-9-day4</title>
      <link href="/2023/09/09/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-9-day4/"/>
      <url>/2023/09/09/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-9-day4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="Problem-24-两两交换链表中的节点"><a href="#Problem-24-两两交换链表中的节点" class="headerlink" title="Problem: 24. 两两交换链表中的节点"></a>Problem: <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两两交换结点.首先要定义一个虚拟头结点,还有cur起始指向虚拟头结点,来将对于链表的所有操作进行统一,</p><p>然后按照以下的图演示步骤进行操作.</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130032243.png" alt="image-20230913003224212"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130030359.png" alt="img"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>●时间复杂度: O(n) </p><p>● 空间复杂度: O(1)</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy_head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy_head.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy_head;</span><br><span class="line">    ListNode temp1;        </span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">      temp1 = cur.next;</span><br><span class="line">      temp2 = cur.next.next.next;</span><br><span class="line"></span><br><span class="line">      cur.next = cur.next.next; <span class="comment">//步骤一</span></span><br><span class="line"></span><br><span class="line">      cur.next.next = temp1;<span class="comment">//步骤二</span></span><br><span class="line"></span><br><span class="line">      temp1.next = temp2;<span class="comment">//步骤三</span></span><br><span class="line"></span><br><span class="line">      cur = cur.next.next;<span class="comment">//步骤四</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy_head-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummy_head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next!=<span class="literal">nullptr</span> )&#123;<span class="comment">//注意顺序,避免空指针异常</span></span><br><span class="line">            ListNode* temp1 = cur-&gt;next; <span class="comment">//保留相对第一个结点</span></span><br><span class="line">            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">//保留结点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//第一步</span></span><br><span class="line">            cur-&gt;next-&gt;next = temp1;<span class="comment">//第二步</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = temp2;<span class="comment">//第三步</span></span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位,准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Problem-19-删除链表的倒数第-N-个结点"><a href="#Problem-19-删除链表的倒数第-N-个结点" class="headerlink" title="Problem: 19. 删除链表的倒数第 N 个结点"></a>Problem: <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>让fast先移动n位,然后再往后移动一位,之后和slow一起移动,直到fast指向为空</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309110905335.png" alt="img"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309110905639.png" alt="img"></p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy_head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy_head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy_head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy_head-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = dummy_head;</span><br><span class="line">        ListNode* slow = dummy_head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next; <span class="comment">// 让fast多走一位,使得slow指向被删除结点的前一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Problem-142-环形链表-II"><a href="#Problem-142-环形链表-II" class="headerlink" title="Problem: 142. 环形链表 II"></a>Problem: <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130031788.png" alt="image-20230913001419393">fast走两步,slow走一步<br>所以fast永远相对slow走一步</p><ul><li><p>所以二者一定在第一圈相遇</p></li><li><p>要求环形链表入口点</p></li><li><p>因为两指针相遇,</p></li><li><p><strong>fast &#x3D; x + y + n (y + z)</strong>,</p></li><li><blockquote><p> n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A</p></blockquote></li><li><p><strong>slow &#x3D; x + y</strong></p></li></ul><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></table></figure><p>将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>因为y+z是一圈,所以, 可将(n - 1) (y + z)看作0, </p><p>这个时候灯饰就为: <strong>x &#x3D; 0 + z</strong> <strong>即x  &#x3D; z</strong></p><p> 这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p><p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130031171.png" alt="image-20230913002319285"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n</li><li>空间复杂度: O(1)</li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123; <span class="comment">//在有环的前提下</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123; <span class="comment">//相遇,说明有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9.7(day2)</title>
      <link href="/2023/09/07/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-7-day2/"/>
      <url>/2023/09/07/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-7-day2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="算法60天训练–9-7-day2"><a href="#算法60天训练–9-7-day2" class="headerlink" title="算法60天训练–9.7(day2)"></a>算法60天训练–9.7(day2)</h1><p>[TOC]</p><h2 id="Problem977-有序数组的平方"><a href="#Problem977-有序数组的平方" class="headerlink" title="Problem977. 有序数组的平方"></a>Problem<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方</a></h2><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><blockquote><p>因为<strong>非递减数组</strong>,在两边的平方要么是最大,要么是最小,一定是在两边,所以这时候可以用双指针,</p><p>在数组两边定义两个指针,当左边的平方小于右边的平方,就往一个新数组放,放在最大索引处,然后左边++,同理,右边–.直到左边小于右边</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fcd55d8be8c8386bbb805e6f7155dd30.png" alt="image-20230907214610773"></p></blockquote><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度:</li></ul><blockquote><p>$O(n)$</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] *= nums[i];</span><br><span class="line">        &#125;                   </span><br><span class="line">        Arrays.sort(res) ;<span class="comment">//如果递减就  Arrays.sort(a, Collections.reverseOrder());</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:$O(n + nlog n)$</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> []res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]; <span class="comment">//递增存到新数组中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length-<span class="number">1</span>; <span class="comment">//新数组的索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length-<span class="number">1</span>; l &lt;= r; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]*nums[l] &lt;= nums[r]*nums[r]) &#123;</span><br><span class="line">                 res[k--] = nums[r]*nums[r];</span><br><span class="line">                 r --;</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[k--] = nums[l]*nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:$O(n)$</p><h2 id="Problem-209-长度最小的子数组"><a href="#Problem-209-长度最小的子数组" class="headerlink" title="Problem: 209. 长度最小的子数组"></a>Problem: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="直接暴力"><a href="#直接暴力" class="headerlink" title="直接暴力"></a>直接暴力</h3><p>两层for循环,比较简单,不做演示</p><h3 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h3><p>使用一个for循环完成操作:</p><p>所谓滑动窗口,就是不断调节子序列的起始位置和终止位置,从而得出我们想要的结果</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2f78be28a0f2fc7596c032b7706bdbd7.png" alt="image-20230907220554936"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/806b60109cf14179c01840ca94112367.png" alt="image-20230907220606299"></p><h3 id="代码-java"><a href="#代码-java" class="headerlink" title="代码(java)"></a>代码(java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="comment">// 使用滑动窗口解法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 起始位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 滑动窗口右端点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">subL</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//滑动窗口长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; nums.length; j++)&#123;</span><br><span class="line">    sum += nums[j];</span><br><span class="line">    <span class="keyword">while</span>(sum &gt;= target)&#123;<span class="comment">//开始缩小窗口,注意这里是while循环，缩小滑动窗口操作是一个持续性的操作</span></span><br><span class="line">      subL = j - i + <span class="number">1</span>;</span><br><span class="line">      result = Math.min(result,subL);</span><br><span class="line">    sum = sum - nums[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result; <span class="comment">// 注意有没有被赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><h2 id="Problem-59-螺旋矩阵-II"><a href="#Problem-59-螺旋矩阵-II" class="headerlink" title="Problem: 59. 螺旋矩阵 II"></a>Problem: <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题无非就是遍历二维数组,一层层向里遍历,但是不统一规定遍历每一条边的边界,会非常的混乱</p><p>所以本题采用循环不变量,对于判断每次螺旋的边界麻烦,不妨都采取左闭又开的原则</p><p>第一个不太好理解的地方就是为什么循环n&#x2F;2圈?是因为最后循环结束的时候StartX一定是在相对于第一条边中间的位置,那么循环了多少圈就可以由这个点对两边的竖边的条数进行分割.两边的条数一定是相等的,有就是转了多少圈.</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202309072228459.png" alt="image-20230907221135198"></p><p><strong>由图可以发现,转了3圈</strong></p><p>第二个地方就是左开右闭,每到一个节点就进入下一个边的循环.</p><p>在每个圈数结束后,更新起点,横纵坐标都加一.startX+1;startY+1</p><p>如果n&#x2F;2等于一,说明最中间有单独的数,直接单独赋值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span> [][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//每次循环的开始点(start, start)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//定义填充数字</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop ++ &lt; n/<span class="number">2</span>)&#123;<span class="comment">//判断边界后,loop从1开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟上侧从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(j = start; j&lt;n-loop; j++)&#123;<span class="comment">// n-loop 是为了左闭又开</span></span><br><span class="line">            res[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟右侧从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(i = start; i &lt; n-loop; i++)&#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=loop;j--)&#123;<span class="comment">//此时loop等于一,startX+1的位置</span></span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=loop;i--)&#123; <span class="comment">//此时loop等于一,startY+1的位置</span></span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间<br>空间复杂度 O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-6-day1</title>
      <link href="/2023/09/06/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-6-day1/"/>
      <url>/2023/09/06/%E7%AE%97%E6%B3%9560%E5%A4%A9%E8%AE%AD%E7%BB%83%E2%80%939-6-day1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="算法60天训练–9-6-day1"><a href="#算法60天训练–9-6-day1" class="headerlink" title="算法60天训练–9-6-day1"></a>算法60天训练–9-6-day1</h1><h2 id="Problem-704-二分查找"><a href="#Problem-704-二分查找" class="headerlink" title="Problem: 704. 二分查找"></a>Problem: <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>从题目中可以看出,数组中的元素是<strong>有序的</strong>,而且是<strong>不重复的</strong>,很满足二分法的使用条件,所以使用二分法来解决这道题,同时二分有两种情况,一种是左闭右闭,一种是左闭右开,而这两种情况在代码的形式上是不一样的.</p></blockquote><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><blockquote><p>以right &#x3D;&#x3D; left(两边顶点)为终止条件,根据左闭又开或左闭右闭来调整每一轮循环之后right和left两边端点的位置.始终将target在端点之间,直到right &#x3D; left.</p></blockquote><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101538656.png" alt="image-20230910153841532"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度:</li></ul><blockquote><p>O(log n)</p></blockquote><ul><li>空间复杂度:</li></ul><blockquote><p>O(1)</p></blockquote><h3 id="Code-JAVA"><a href="#Code-JAVA" class="headerlink" title="Code[JAVA]"></a>Code[JAVA]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> right+left &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code-C"><a href="#Code-C" class="headerlink" title="Code[C++]"></a>Code[C++]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> middle  = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle<span class="number">-1</span>;<span class="comment">//右开</span></span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(nums[middle] == target)&#123;</span><br><span class="line">              <span class="keyword">return</span> middle;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Problem-27-移除元素"><a href="#Problem-27-移除元素" class="headerlink" title="Problem: 27. 移除元素"></a>Problem: <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先可以两个for循环遍历.很简单</p><p>但是如果要减小时间复杂度,可以采用双指针解法</p><h3 id="双指针方法"><a href="#双指针方法" class="headerlink" title="双指针方法"></a>双指针方法</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101546315.png" alt="image-20230910154659274"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101547470.png" alt="image-20230910154707431"></p><p>首先定义两个指针<strong>fast,slow,<strong>如果fast指针指向的元素不等于要删除的元素,那么slow跟随fas</strong>t一起往右移动</strong>,,如果fast指向的元素<strong>等于要被删除的元素,</strong></p><p>那么slow不动,fast向右移动,<strong>直到fast-&gt;val不等于要被删除的元素</strong>,然后将其值赋<strong>值给slow指向的元素</strong>,如此循环,直到最右边,达到前面的等于2的元素被删除的目的.</p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><p>时间复杂度: </p><blockquote><p>添加时间复杂度： $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>添加空间复杂度： $O(1)$</p></blockquote></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(fastIndex; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val)&#123;</span><br><span class="line">                nums[slowIndex]  = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;<span class="comment">//移动几次说明有几个重复元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法60天打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拦截器Interceptor</title>
      <link href="/2023/08/26/%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/"/>
      <url>/2023/08/26/%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>什么是拦截器？ </p><p>是一种动态拦截方法调用的机制，类似于过滤器。 拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。 </p><p>拦截器的作用： </p><p>拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。 在拦截器当中，我们通常也是做一些通用性的操作，比如：我们可以通过拦截器来拦截前端发起的请 求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且 是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令 牌，就可以直接给前端响应未登录的错误信息。</p><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>实现HandlerInterceptor接口，并重写其所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"><span class="comment">//目标资源方法执行前执行。 返回true：放行 返回false：不放行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true表示放行</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//目标资源方法执行后执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response, Object handler, ModelAndView</span></span><br><span class="line"><span class="params">modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;postHandle ... &quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span></span><br><span class="line">Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;afterCompletion .... &quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意： preHandle方法：目标资源方法执行前执行。 返回true：放行 返回false：不放行 postHandle方法：目标资源方法执行后执行 afterCompletion方法：视图渲染完毕后执行，最后执行</p></blockquote><h2 id="注册配置拦截器"><a href="#注册配置拦截器" class="headerlink" title="注册配置拦截器"></a>注册配置拦截器</h2><p>实现WebMvcConfigurer接口，并重写addInterceptors方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"><span class="comment">//自定义的拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">    registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**</span></span><br><span class="line"><span class="string">    &quot;</span>);<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interceptor详解"><a href="#Interceptor详解" class="headerlink" title="Interceptor详解"></a>Interceptor详解</h2><h2 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h2><p>首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径， 通过 <code>addPathPatterns</code>(“要拦截路径”) 方法，就可以指定要拦截哪些资源。 在入门程序中我们配置的是 &#x2F;** ，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资 源，还可以指定不拦截哪些资源，只需要调用 <code>excludePathPatterns</code>(“不拦截路径”) 方法，指定哪些 资源不需要拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">    registry.addInterceptor(loginCheckInterceptor)</span><br><span class="line">     .addPathPatterns(<span class="string">&quot;/**&quot;</span>)<span class="comment">//设置拦截器拦截的请求路径（ /**</span></span><br><span class="line">    表示拦截所有请求）</span><br><span class="line">     .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);<span class="comment">//设置不拦截的请求路径</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308261811132.png" alt="image-20230826181149973"></p><ul><li>当我们打开浏览器来访问部署在web服务器当中的web应用时，此时我们所定义的过滤器会拦截到 这次请求。拦截到这次请求之后，它会先执行放行前的逻辑，然后再执行放行操作。而由于我们当 前是基于springboot开发的，所以放行之后是进入到了spring的环境当中，也就是要来访问我 们所定义的controller当中的接口方法。</li><li>Tomcat并不识别所编写的Controller程序，但是它识别<code>Servlet</code>程序，所以在Spring的Web环 境中提供了一个非常核心的<code>Servlet：DispatcherServlet</code>（前端控制器），所有请求都会先 进行到&#96;&#96;DispatcherServlet&#96;，再将请求转给Controller。</li><li>当我们定义了拦截器后，会在执行Controller的方法之前，请求被拦截器拦截住。执行 <code>preHandle() </code>方法，这个方法执行完成后需要返回一个布尔类型的值，如果返回<code>true</code>，就表示放 行本次操作，才会继续访问controller中的方法；如果返回<code>false</code>，则不会放行（controller 中的方法也不会执行）。</li><li>在controller当中的方法执行完毕之后，再回过来执行 <code>postHandle() </code>这个方法以及 <code>afterCompletion()</code> 方法，然后再返回给<code>DispatcherServlet</code>，最终再来执行过滤器当中放 行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。</li></ul><p>参考黑马程序员课程</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT令牌详解</title>
      <link href="/2023/08/26/JWT%E4%BB%A4%E7%89%8C%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/08/26/JWT%E4%BB%A4%E7%89%8C%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JWT全称：JSON Web Token （官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><blockquote><p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。 自包含：指的是jwt令牌，看似是一个随机的字符串，但是我们是可以根据自身的需求在jwt 令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。 简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在 通信双方安全的进行信息传输了。</p></blockquote><h2 id="JWT的组成："><a href="#JWT的组成：" class="headerlink" title="JWT的组成："></a>JWT的组成：</h2><p>（JWT令牌由三个部分组成，三个部分之间使用英文的点来分割） 第一部分：Header(头）， 记录令牌类型、签名算法等。 例如： {“alg”:”HS256”,”type”:”JWT”} 第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如： {“id”:”1”,”username”:”Tom”} 第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加 入指定秘钥，通过指定签名算法计算而来。</p><blockquote><p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在， 所以整个jwt 令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡 改了，整个令牌在校验的时候都会失败，所以它是非常安全可靠的。</p></blockquote><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308261527163.png" alt="image-20230826152706061"></p><blockquote><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？ 其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码 Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味 着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是 64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符 号，那就是等号。等号它是一个补位的符号 需要注意的是Base64是编码方式，而不是加密方式。</p></blockquote><p><strong>既然这样, 编码和加密的区别是什么呢?</strong></p><p><strong>加密</strong>是对数据进行安全<strong>编码</strong>的过程，以便只有知道密钥或密码的授权用户才能为其他人检索原始数据，这只是垃圾。 <strong>编码</strong>是将数据转换为这样一种格式的过程，该格式可以由不同类型的系统使用公开可用的算法进行。 <strong>加密</strong>的目的是转换数据以使其对他人保密。 <strong>编码</strong>主要目的是保护数据的完整性。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>JWT令牌最典型的应用场景就是登录认证：</p><ul><li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成 一个jwt令牌，将生成的 jwt令牌返回给前端。 </li><li>前端拿到jwt令牌之后，会将jwt令牌存储起来。在后续的每一次请求中都会将jwt令牌携带到服 务端。</li><li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接 拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处 理。</li></ul><p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作： </p><ol><li>在登录成功之后，要生成令牌。</li><li>每一次请求当中，要接收令牌并对令牌进行校验。</li></ol><h2 id="生成和校验"><a href="#生成和校验" class="headerlink" title="生成和校验"></a>生成和校验</h2><p>首先需要映入JWT的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成JWT代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>&#123;</span><br><span class="line">Map&lt;String,Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">claims.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">claims.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line"> .setClaims(claims) <span class="comment">//自定义内容(载荷)</span></span><br><span class="line"> .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;itheima&quot;</span>) <span class="comment">//签名算法</span></span><br><span class="line"> .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() +</span><br><span class="line"><span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>)) <span class="comment">//有效期</span></span><br><span class="line"> .compact();<span class="comment">//使其返回一个对象</span></span><br><span class="line">System.out.println(jwt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71</span><br><span class="line">UqLXDdLyipptLgxBUg_mSuGJtXtBk</span><br></pre></td></tr></table></figure><p>输出的结果就是生成的JWT令牌,，通过英文的点分割对三个部分进行分割，我们可以将生成的令牌复制 一下，然后打开JWT的官网，将生成的令牌直接放在Encoded位置，此时就会自动的将令牌解析出来。</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308261534117.png" alt="image-20230826153437066"></p><blockquote><p>第一部分解析出来，看到JSON格式的原始数据，所使用的签名算法为HS256。 第二个部分是我们自定义的数据，之前我们自定义的数据就是id，还有一个exp代表的是我们所设 置的过期时间。 由于前两个部分是base64编码，所以是可以直接解码出来。但最后一个部分并不是base64编 码，是经过签名算法计算出来的，所以最后一个部分是不会解析的。</p></blockquote><p><strong>校验JWT令牌(解析生成的令牌)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line"> .setSigningKey(<span class="string">&quot;itheima&quot;</span>)<span class="comment">//指定签名密钥（必须保证和生成令牌时使用</span></span><br><span class="line">相同的签名密钥）</span><br><span class="line"></span><br><span class="line">.parseClaimsJws(<span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMw</span></span><br><span class="line"><span class="string">fQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk&quot;</span>)</span><br><span class="line"> .getBody();</span><br><span class="line">System.out.println(claims);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(以上参考了黑马程序员B站教程)</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC连接数据库ERROR</title>
      <link href="/2023/08/14/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93ERROR/"/>
      <url>/2023/08/14/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93ERROR/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="解决报错“Loading-class-com-mysql-jdbc-Driver’-This-is-deprecated”"><a href="#解决报错“Loading-class-com-mysql-jdbc-Driver’-This-is-deprecated”" class="headerlink" title="解决报错“Loading class &#96;com.mysql.jdbc.Driver’. This is deprecated”"></a>解决报错“Loading class &#96;com.mysql.jdbc.Driver’. This is deprecated”</h1><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308141056315.png" alt="image-20230814105654242"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>在这个基础上,改为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>除此之外</p><p>将url地址:</p><p>原本是<code>url: jdbc:mysql://127.0.0.1:3306/</code></p><p>改为:</p><p><code>jdbc:mysql://127.0.0.1:3306/tlias?useUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=GMT%2B8</code></p><p><code>tlias</code>是数据库名</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308141059868.png" alt="image-20230814105914802"></p><p>然后就可以尝试测试,问题就可以解决啦</p>]]></content>
      
      
      <categories>
          
          <category> 报错解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/08/11/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/08/11/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/2023/08/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2023/08/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h2><p>如果在一个类对象上方法太多,可以通过代理来减轻自己的负担,就比如黑马阿玮PPT的一张图</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308091949765.png" alt="image-20230809183336178"></p><p>对于代理如何知道对象的方法.可以让对象和代理都实现一个接口来达成目的</p><p>&#x3D;&#x3D;为什么需要代理&#x3D;&#x3D;</p><p>代理可以无侵入式的给对象增加其他的共能</p><p>调用者 -&gt; 代理 -&gt; 对象</p><p>&#x3D;&#x3D;代理长什么样&#x3D;&#x3D;</p><p>就是对象要被代理的方法</p><p>&#x3D;&#x3D;java通过什么来保证代理的样子&#x3D;&#x3D;</p><p>通过接口保证,后面的对象和代理需要实现同一个接口,接口中就是要被代理的方法</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308091949245.png" alt="image-20230809192308305"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象和代理的接口</span></span><br><span class="line"><span class="keyword">package</span> DaiLi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">sing</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BigStar 对象 </span></span><br><span class="line"><span class="keyword">package</span> DaiLi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigStar</span> <span class="keyword">implements</span> <span class="title class_">Star</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigStar</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigStar</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sing</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在唱&quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;谢谢大家&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在跳舞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BigStar&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建代理</span></span><br><span class="line"><span class="keyword">package</span> DaiLi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtile</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStar bigStar)</span>&#123;</span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(</span><br><span class="line">                ProxyUtile.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;sing&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备话筒,收钱&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;dance&quot;</span>.equals(method.getName())) System.out.println(<span class="string">&quot;准备场地收钱&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStar, args);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">package</span> DaiLi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigStar</span> <span class="variable">bigStar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigStar</span>(<span class="string">&quot;鸡哥&quot;</span>);</span><br><span class="line">        <span class="type">Star</span> <span class="variable">proxy</span> <span class="operator">=</span> ProxyUtile.createProxy(bigStar);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> proxy.sing(<span class="string">&quot;只因你太美&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除倒数第n个结点</title>
      <link href="/2023/08/08/%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2023/08/08/%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>双指针,首先让快指针先走n个点.这时候和slow的距离便是从最后一个点到要删的点的距离</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>定义一个fast指针,和一个slow指针,指向dummyhead(虚头结点,便于统一操作),<br>首先让快指针先走n个点.这时候和slow的距离便是从最后一个点到要删的点的距离</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308082341781.png" alt="image-20230808234135646"></p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fastIndex</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slowIndex</span> <span class="operator">=</span> dummyHead;  </span><br><span class="line">        n++; <span class="comment">//让fast指针多走一步,从而让slow-&gt;next指向被删的点</span></span><br><span class="line">        <span class="keyword">while</span>(n-- != <span class="number">0</span>&amp;&amp; fastIndex!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fastIndex = fastIndex.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fastIndex != <span class="literal">null</span>)&#123;</span><br><span class="line">            slowIndex = slowIndex.next;</span><br><span class="line">            fastIndex = fastIndex.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slowIndex.next = slowIndex.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* fast = dummyHead; <span class="comment">// 快指针</span></span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        n++; <span class="comment">//因为要操作的是slow-&gt;next,同时也为了避免fast为空指针的情况</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的节点</title>
      <link href="/2023/08/07/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2023/08/07/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>定义一个虚拟头结点, 赋值给一个临时节点cur,操作后两个节点.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>比如节点0(虚拟)-&gt;1-&gt;2-&gt;3,这时候如果实现两两交换,就需要一下操作,用tmp和tmp1保存1和3节点, 然后将0-&gt;2,2-&gt;1,1-&gt;3,然后将0往后依次这样执行,直到(cur-&gt;next !&#x3D;null &amp;&amp; cur-&gt;next-&gt;next) (分奇数和偶数节点的判断),不能颠倒,避免报错空指针异常</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> cur.next.next.next;</span><br><span class="line"></span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            cur.next.next = tmp;</span><br><span class="line">            cur.next.next.next = tmp1;</span><br><span class="line"></span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* temp = new ListNode(0);        ListNode* cur = dummyHead;        while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr)&#123;            temp = cur-&gt;next;            ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next;            cur-&gt;next = cur-&gt;next-&gt;next;            cur-&gt;next-&gt;next = temp;            cur-&gt;next-&gt;next-&gt;next = temp1;                        cur = cur-&gt;next-&gt;next;        &#125;     return dummyHead-&gt;next;//不能返回head,因为已经被改变了    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2023/08/06/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/08/06/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>双指针算法,定义pre,和cur,来遍历链表.然后进行反转</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>定义一个temp记录cur-&gt;next的位置,当反转通过<code>cur-&gt;next=pre</code>来完成,<br>所以之后pre &#x3D; cur, cur&#x3D;tmep(向后移动),直到cur为空,即达到遍历完成的效果</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = cur.next; <span class="comment">// 在cur.next改变之前</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用mybatis实现查询报错解决</title>
      <link href="/2023/08/05/%E4%BD%BF%E7%94%A8mybatis%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/08/05/%E4%BD%BF%E7%94%A8mybatis%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息“Unable-to-resolve-column-‘id’”"><a href="#报错信息“Unable-to-resolve-column-‘id’”" class="headerlink" title="报错信息“Unable to resolve column ‘id’”"></a>报错信息“Unable to resolve column ‘id’”</h2><p>​<img src="/../imgs/202308051939669.png" alt="image-20230805193945623"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li></li></ol><p><img src="/../imgs/202308051940228.png" alt="image-20230805194016190"></p><p>2.<img src="/../imgs/202308051940483.png" alt="image-20230805194036432"></p><ol start="3"><li></li></ol><p><img src="/../imgs/202308051941479.png" alt="image-20230805194105422"></p><p>4 . 更改为使用的表</p><p><img src="/../imgs/202308051941020.png" alt="image-20230805194133971"></p><p>然后报错就消失啦</p>]]></content>
      
      
      <categories>
          
          <category> 报错解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主键</title>
      <link href="/2023/08/05/%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F/"/>
      <url>/2023/08/05/%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="主键概述"><a href="#主键概述" class="headerlink" title="主键概述"></a>主键概述</h1><p>主键值是每一行记录的唯一标识(就是类似不能重复的身份证号)</p><p><img src="/../imgs/202308051618449.png" alt="image-20230805153904522"></p><p><strong>任何一张表都应该有主键,没有主键表无效</strong>,</p><p>主键的特征: not null + unique (不能为空,且不重复)</p><p>给一张表添加主键:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t_vip(</span><br><span class="line">id int primary key,//列级约束</span><br><span class="line">name varchar(255)</span><br><span class="line">);</span><br><span class="line">create table t_vip(</span><br><span class="line">id int ,</span><br><span class="line">name varchar(255),</span><br><span class="line">    primary key(id)  //表级约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../imgs/202308051618117.png" alt="image-20230805154406943"></p><h1 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h1><p>id 和name 联合起来做主键,叫做复合主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t_vip(</span><br><span class="line">id int ,</span><br><span class="line">name varchar(255),</span><br><span class="line">    primary key(id,name)  //表级约束</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/../imgs/202308051547340.png" alt="image-20230805154756288"></p><p>在实际开发中不建议使用复合主键</p><p>因为主键值存在的意义就是一行的唯一标识</p><h1 id="主键数量"><a href="#主键数量" class="headerlink" title="主键数量"></a>主键数量</h1><p><img src="/../imgs/202308051619294.png" alt="image-20230805154917751"></p><p>主键只能有一个,刚刚说的联合主键和这个情况不一样</p><h1 id="主键值"><a href="#主键值" class="headerlink" title="主键值"></a>主键值</h1><p>建议使用,<code>int</code> <code>bigint</code> <code>char</code> 等类型</p><p>不建议使用<code>varchar</code>来做主键.主键值一般都是数字,一般都是定长的1</p><h1 id="主键分类"><a href="#主键分类" class="headerlink" title="主键分类"></a>主键分类</h1><p><strong>根据主键字段的字段数量来划分：</strong><br>            单一主键（推荐的，常用的。）<br>            复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）<br>        <strong>根据主键性质来划分：</strong><br>            自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）<br>            业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）<br>                          最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要<br>                          随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。<br>    <strong>mysql提供主键值自增：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int primary key auto_increment, // id字段自动维护一个自增的数字，从1开始，以1递增。</span><br><span class="line">username varchar(255)</span><br><span class="line">);</span><br><span class="line">insert into t_user(username) values(&#x27;a&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;b&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;c&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;d&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;e&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;f&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line"></span><br><span class="line">提示:Oracle当中也提供了一个自增机制，叫做：序列（sequence）对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除链表元素</title>
      <link href="/2023/08/04/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2023/08/04/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>遍历链表,如果相等,需要删除的元素的左边节点指向删除元素的右边节点.<br>如果删除的是表头元素,为了统一,建立一个虚拟头结点</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>定义一个虚拟头结点dummyHead,和遍历需要的指针cur,进入循环,遍历链表元素,如果相等就将删除的元素的左边节点指向删除元素的右边节点.<br>如果删除的是表头元素,为了统一,建立一个虚拟头结点.直到cur-&gt;next !&#x3D; null.因为cur &#x3D;&#x3D; dummyHead. 实际上我们操作的也一直是cur-&gt;next;</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code-C"><a href="#Code-C" class="headerlink" title="Code(C++)"></a>Code(C++)</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">      ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">      dummyHead-&gt;next = head; <span class="comment">//这里要从虚节点的下一个操作</span></span><br><span class="line">      ListNode* cur = dummyHead;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)&#123;<span class="comment">// 操作的永远是 cur-&gt;next</span></span><br><span class="line">              ListNode* tmp = cur-&gt;next; <span class="comment">// 操作的永远是 cur-&gt;next</span></span><br><span class="line">              cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">              <span class="keyword">delete</span> tmp;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              cur = cur-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵||</title>
      <link href="/2023/08/04/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/08/04/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>本体采用循环不变量,对于判断每次螺旋的边界麻烦,不妨都采取左闭又开的原则</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>第一个不太好理解的地方就是为什么循环n&#x2F;2圈?是因为最后循环结束的时候StartX一定是在相对于第一条边中间的位置,那么循环了多少圈就可以由这个点对两边的竖边的条数进行分割.两边的条数一定是相等的,有就是转了多少圈.<br>第二个地方就是左开右闭,每到一个节点就进入下一个边的循环.<br>在每个圈数结束后,更新起点,横纵坐标都加一.startX+1;startY+1</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $n(2)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span> [][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//每次循环的开始点(start, start)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//定义填充数字</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop ++ &lt; n/<span class="number">2</span>)&#123;<span class="comment">//判断边界后,loop从1开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟上侧从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(j = start; j&lt;n-loop; j++)&#123;<span class="comment">// n-loop 是为了左闭又开</span></span><br><span class="line">            res[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟右侧从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(i = start; i &lt; n-loop; i++)&#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=loop;j--)&#123;<span class="comment">//此时loop等于一,startX+1的位置</span></span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=loop;i--)&#123; <span class="comment">//此时loop等于一,startY+1的位置</span></span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot初学相关配置问题</title>
      <link href="/2023/08/02/SpringBoot%E5%88%9D%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/02/SpringBoot%E5%88%9D%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot初学相关配置问题"><a href="#SpringBoot初学相关配置问题" class="headerlink" title="SpringBoot初学相关配置问题"></a>SpringBoot初学相关配置问题</h1><p>如果下了多个JDK版本要对应</p><p><img src="/../imgs/image-20230802223518620-16912480524331.png" alt="image-20230802223518620"></p><p><img src="/../imgs/image-20230802223544161-16912480560582.png" alt="image-20230802223544161"></p><p><img src="/../imgs/image-20230802223559402-16912480586283.png" alt="image-20230802223559402"></p><p><img src="/../imgs/image-20230802223615199-16912480613534.png" alt="image-20230802223615199"></p>]]></content>
      
      
      <categories>
          
          <category> 报错解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven配置相关问题</title>
      <link href="/2023/08/01/maven%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/01/maven%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="解决-Unresolved-plugin-‘org-apache-maven-plugins-maven-clean-plugin-2-5’-问题"><a href="#解决-Unresolved-plugin-‘org-apache-maven-plugins-maven-clean-plugin-2-5’-问题" class="headerlink" title="解决 (Unresolved plugin: ‘org.apache.maven.plugins:maven-clean-plugin:2.5’)问题"></a>解决 (Unresolved plugin: ‘org.apache.maven.plugins:maven-clean-plugin:2.5’)问题</h3><p>首先要先下载maven相关包,遇到这种问题一般是在创建maven项目之后,</p><p>这时候先看settings中maven ,其中相关路径以及经典配置</p><p>如果仍出现这种problems,</p><p>可以看maven配置的 Local respository下面的对钩有没有勾上,勾上之后重新加载就可以解决问题啦</p><p><img src="/../imgs/image-20230801212737931.png" alt="image-20230801212737931"></p>]]></content>
      
      
      <categories>
          
          <category> 报错解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2023/08/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2023/08/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先是暴力,通过两层for循环遍历所有情况,取最小;<br>然后就是滑动窗口, 因为本体取的是子数组, 就不能出现跨越的情况.通过滑动窗口来优化</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>首先定义一个滑动窗口的右端点, 然后计算sum , 如果满足条件, 就将左端点往右移动,直到sum &lt; target, 然后继续往右挪动右端点. 不断更新最小值result;</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>O(n) 暴力 O(n^2)</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>O(1)</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>; st &lt; nums.length; st++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> st; l &lt; nums.length; l++)&#123;</span><br><span class="line">                sum += nums[l];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> l - st + <span class="number">1</span>;</span><br><span class="line">                    result = Math.min(len, result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">la</span> <span class="operator">=</span> <span class="number">0</span>; la &lt; nums.length; la++)&#123; <span class="comment">// 遍历终止点</span></span><br><span class="line">            sum += nums[la];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123; <span class="comment">//满足条件就一直通过左端点往右移动</span></span><br><span class="line">                len = la - st + <span class="number">1</span>; <span class="comment">//取子序列的长度</span></span><br><span class="line">                <span class="comment">//result = Math.min(len, result);</span></span><br><span class="line">                result = result &lt; len ? result : len;</span><br><span class="line">                sum -= nums[st++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> :result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/2023/07/30/Vue3/"/>
      <url>/2023/07/30/Vue3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="1-vue语法初探"><a href="#1-vue语法初探" class="headerlink" title="1.vue语法初探"></a>1.vue语法初探</h2><h3 id="1-1-HelloWord"><a href="#1-1-HelloWord" class="headerlink" title="1.1 HelloWord"></a>1.1 HelloWord</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 从面向dom编程到面向数据编程</span><br><span class="line">Vue.createApp(&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">content: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 当页面加载完成,会自动调用mounted</span><br><span class="line">mounted() &#123;</span><br><span class="line">setInterval( ()=&gt;&#123;</span><br><span class="line">this.content++</span><br><span class="line">&#125;,1000)</span><br><span class="line">&#125;,</span><br><span class="line">template: `&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;`</span><br><span class="line">&#125;).mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里要引用<code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></p><p>&#x3D;&#x3D;要慢慢将思维由面向dom到面向数据&#x3D;&#x3D;</p><h3 id="1-2-反转和隐藏"><a href="#1-2-反转和隐藏" class="headerlink" title="1.2 反转和隐藏"></a>1.2 反转和隐藏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">   // 从面向dom编程到面向数据编程</span><br><span class="line">   Vue.createApp(&#123;</span><br><span class="line">   data()&#123;</span><br><span class="line">   return &#123;</span><br><span class="line">   content: &#x27;helloworld&#x27;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   methods:&#123;</span><br><span class="line">   handClick()&#123;</span><br><span class="line">   this.content  = this.content.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   // 绑定反转函数,实习写在methods里面</span><br><span class="line">   template: `</span><br><span class="line">   &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;</span><br><span class="line">   &lt;button @click = &quot;handClick&quot;&gt;反转&lt;/button&gt;</span><br><span class="line">   ` </span><br><span class="line">   &#125;).mount(&#x27;#root&#x27;)</span><br><span class="line">   &lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 从面向dom编程到面向数据编程</span><br><span class="line">Vue.createApp(&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">show: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">handClick()&#123;</span><br><span class="line">// 面向数据编程,改变数据的值</span><br><span class="line">this.show = !this.show</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">template: `</span><br><span class="line">&lt;span v-if = &quot;show&quot;&gt;hello&lt;/span&gt;</span><br><span class="line">&lt;button @click = &quot;handClick&quot;&gt;隐藏/出现&lt;/button&gt;</span><br><span class="line">` </span><br><span class="line">&#125;).mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-todolist"><a href="#1-3-todolist" class="headerlink" title="1.3 todolist"></a>1.3 todolist</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 从面向dom编程到面向数据编程</span><br><span class="line">Vue.createApp(&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">list: [],</span><br><span class="line">inputValue: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">handClick()&#123;</span><br><span class="line">this.list.push(this.inputValue)</span><br><span class="line">    inputValue = &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">template: `</span><br><span class="line">&lt;input v-model = &quot;inputValue&quot;&gt;</span><br><span class="line">&lt;button @click = &quot;handClick&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for = &quot;(item,index) of list&quot;&gt;&#123;&#123;item&#125;&#125; &#123;&#123;index&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">` </span><br><span class="line">&#125;).mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>index ,是item遍历的索引</p><p><code>&lt;button @click = &quot;handClick&quot; title = &quot;222&quot;&gt;增加&lt;/button&gt;</code></p><p>这样不对,如果title要和数据绑定,需要使用v-bind指令 :title&#x3D;   </p><h3 id="1-4-组件概念初探"><a href="#1-4-组件概念初探" class="headerlink" title="1,4 组件概念初探"></a>1,4 组件概念初探</h3><p>如果<code>.mount(&#39;#root&#39;)</code>挂载了组件之后再去<code>qpp.component()</code>去创建组件就来不及了</p><p>展示组件:定义完组件之后再去挂载<code>app.mount(&#39;#root&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 从面向dom编程到面向数据编程</span><br><span class="line">const app = Vue.createApp(&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">list: [],</span><br><span class="line">inputValue: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">handClick()&#123;</span><br><span class="line">this.list.push(this.inputValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">template: `</span><br><span class="line">&lt;input v-model = &quot;inputValue&quot;&gt;</span><br><span class="line">&lt;button @click = &quot;handClick&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;todo-item v-for = &quot;(item, index) of list&quot;</span><br><span class="line">:content = &quot;item&quot;</span><br><span class="line">:index = &quot;index&quot;</span><br><span class="line">&gt;&lt;/todo-item&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">` </span><br><span class="line">&#125;);</span><br><span class="line">app.component(&#x27;todo-item&#x27;, &#123;</span><br><span class="line">props: [&#x27;content&#x27;, &#x27;index&#x27;],</span><br><span class="line">template: &#x27;&lt;div&gt;&#123;&#123;content&#125;&#125;----&#123;&#123;index&#125;&#125;&lt;/div&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">app.mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>在这里,将li标签的属性通过组件化展示出来,:index :content分别绑定两个变量, 在组件中,由<code>props:[绑定值1,绑定值2...]</code>去接收</p><h2 id="2-Vue基础语法"><a href="#2-Vue基础语法" class="headerlink" title="2. Vue基础语法"></a>2. Vue基础语法</h2><h3 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h3><p>获取数据要用<code>vm.$data.xxx</code></p><p>createApp 表示创建一个Vue应用, 存储到app变量中, 传入的参数表示,这个应用最外层的组件应该如何展示</p><p>&#x3D;&#x3D;mvvm&#x3D;&#x3D;模式, m-&gt;model 数据 v-&gt;view 视图 vm -&gt; viewModel视图数据连接层</p><p>这也是为什么 const vm &#x3D; app.mount(‘#root’) vm代表的就是Vue的根组件</p><h3 id="2-2-生命周期函数"><a href="#2-2-生命周期函数" class="headerlink" title="2.2 生命周期函数"></a>2.2 生命周期函数</h3><p><strong>在某一时刻会自动执行的函数</strong></p><p>比如之前的 mounted(){}</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550391.png" alt="image-20230730205903567"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550672.png" alt="image-20230730210033959"></p><p>图里面的判断意思是. 如果没有template 就去root挂载的根节点去找innerHtml结构</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550645.png" alt="image-20230730210226446"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550175.png" alt="image-20230730210418348"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550137.png" alt="image-20230730210503916"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551822.png" alt="image-20230730210625949"></p><p><code>beforeUpdate</code>是在数据改变(页面还没有渲染时调用)</p><p><code>updated</code>是在页面重新渲染完之后调用,注意二者区别!</p><p><code>beforeUnmount</code>当Vue应用失效时,自动执行的函数</p><p><code>unmounted</code> 当Vue应用失效时,且dom完全销毁之后,自动执行的函数</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551739.png" alt="image-20230730211407402"></p><h3 id="2-3-常用模版语法"><a href="#2-3-常用模版语法" class="headerlink" title="2.3 常用模版语法"></a>2.3 常用模版语法</h3><p>template: <code>&lt;div v-html = &quot;message&quot;&lt;/div&gt;</code></p><p>避免转义</p><p>v-bind:(属性或变量) &#x3D; …  与data中的数据绑定 , 不知道起什么名可以**:[data中的属性名]**</p><p>template: <code>&lt;div v-html = &quot;message&quot;&gt;&#123;&#123;在这里面可以写类似于Max(,)这样的js表达式&#125;&#125;&lt;/div&gt;</code>但是如果是if(){}就不行,这是js语句,不是表达式</p><p> <code>&lt;div v-once&gt;&#123;&#123;m&#125;&#125;&lt;/div&gt; </code>只显示一次,当m再变化,页面渲染</p><p><code>v-if = &#39;show&#39;</code>  show是data:{} 中的bool</p><p>v-on  点击绑定</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551231.png" alt="image-20230731214451194"></p><p>@[event] , 而event可以在data中 event: ‘click’ &#x2F;‘ mouseenter’ 绑定其他事件</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551123.png" alt="image-20230731215311197"></p><p>阻止默认行为  @click.prevent &#x3D; “函数名”</p><h3 id="2-4-数据-方法-计算属性-侦听器"><a href="#2-4-数据-方法-计算属性-侦听器" class="headerlink" title="2.4 数据,方法,计算属性,侦听器"></a>2.4 数据,方法,计算属性,侦听器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  methods:&#123;</span><br><span class="line">    formatString(string)&#123;</span><br><span class="line">      return string.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123;formatString(message)&#125;&#125;&lt;/div&gt;`</span><br><span class="line">&#125;).mount(&#x27;#root&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const vm = Vue.createApp(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#x27;hello world&#x27;,</span><br><span class="line">        count: 2,</span><br><span class="line">        price: 5</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">      // 当计算属性依赖的内容发生改变,才会重新执行计算</span><br><span class="line">      total()&#123;</span><br><span class="line">        // 注意计算属性别漏了this</span><br><span class="line">        // return this.count * this.price; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      formatString(string)&#123;</span><br><span class="line">        return string.toUpperCase();</span><br><span class="line">      &#125;,</span><br><span class="line">      // 只要页面重新渲染,就会重新计算</span><br><span class="line">      </span><br><span class="line">        Date.now();</span><br><span class="line">        // return this.count * this.price; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;`</span><br><span class="line">  &#125;).mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><p> total()(在computed中)</p><p>   &#x2F;当计算属性依赖的内容发生改变,才会重新执行计算<br>getTotal()(在函数方法中)</p><p> 只要页面重新渲染,就会重新计算</p><p><strong>侦听器</strong></p><p>如果想数据改变隔五秒打印一些东西,用computed肯定是不行的,这是后就需要加一个watch侦听器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const vm = Vue.createApp(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#x27;hello world&#x27;,</span><br><span class="line">        count: 2,</span><br><span class="line">        price: 5</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">      // 当计算属性依赖的内容发生改变,才会重新执行计算</span><br><span class="line">      total()&#123;</span><br><span class="line">        // 注意计算属性别漏了this</span><br><span class="line">         return this.count * this.price; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      price()&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&#x27;price changed&#x27;)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      formatString(string)&#123;</span><br><span class="line">        return string.toUpperCase();</span><br><span class="line">      &#125;,</span><br><span class="line">      // 只要页面重新渲染,就会重新计算</span><br><span class="line">      getTotal()&#123;</span><br><span class="line">        Date.now();</span><br><span class="line">        // return this.count * this.price; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;`</span><br><span class="line">  &#125;).mount(&#x27;#root&#x27;)</span><br></pre></td></tr></table></figure><p><strong>computed 和 method 都能实现的一个功能,建议使用computed,因为有缓存, computed 和 watcher 都能实现的功能,建议使用computed,因为更加简洁. watched 也可以监听price改变,然后对页面重新与安然,但是麻烦,不如computed</strong></p><p>异步可以在watch 里面, 但同步不如在computed里面更简洁</p><h3 id="2-5-样式绑定语法"><a href="#2-5-样式绑定语法" class="headerlink" title="2.5.样式绑定语法"></a>2.5.样式绑定语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const app = Vue.createApp(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        classString: &#x27;red&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `&lt;div :class = &#x27;classString&#x27;&gt; hello&lt;/div&gt;`</span><br><span class="line">  &#125;)</span><br><span class="line">  const vm =  app.mount(&#x27;#root&#x27;)</span><br></pre></td></tr></table></figure><p>通过字符串绑定来改变style样式</p><p><img src="/../imgs/image-20230802133154875.png" alt="image-20230802133154875"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552596.png" alt="image-20230802135424710"></p><p>添加子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const app = Vue.createApp(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        classString: &#x27;red&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `&lt;div :class = &#x27;classString&#x27;&gt; hello</span><br><span class="line">      &lt;demo /&gt;</span><br><span class="line">      &lt;/div&gt;`</span><br><span class="line">  &#125;)</span><br><span class="line">  // 创建组件</span><br><span class="line">  app.component(&#x27;demo&#x27;, &#123;</span><br><span class="line">    template: &#x27; &lt;div class = &quot;green&quot; &gt; single &lt;/div&gt;&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  const vm =  app.mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><p>如果子组件有两个div. 当把class加到父组件demo中时,可以控制显示哪个div:</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552559.png" alt="image-20230802140326043"></p><p><strong>通过style的方式写样式:</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552543.png" alt="image-20230802140537613"></p><p>这里简写写styleObject 可读性更强</p><h3 id="2-6-条件渲染"><a href="#2-6-条件渲染" class="headerlink" title="2.6 条件渲染"></a>2.6 条件渲染</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const app = Vue.createApp(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        show : false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;div v-if = &#x27;show&#x27;&gt; hello&lt;/div&gt;</span><br><span class="line">      &lt;div v-show = &#x27;show&#x27;&gt; hello&lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">  &#125;);</span><br><span class="line">  const vm =  app.mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><p>v-if 是直接在DOM上添加或者删除,而v-show值通过冬至<code>display:none属性</code>来控制是否显示</p><p>如果频繁改变的话还是建议使用v-show</p><p>除此之外,在vue中还可以使用if else if else逻辑</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552914.png" alt="image-20230802141746575"></p><p>表示如果<code>conditionOne</code> 是True的话就展示<code>if</code>,如果不是,就看<code>conditionTwo</code>是true的话就显示<code>else if</code>, 否则就展示<code>else</code></p><h3 id="2-7-列表渲染"><a href="#2-7-列表渲染" class="headerlink" title="2.7 列表渲染"></a>2.7 列表渲染</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>可以对list 循环,也可以对对象循环:<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552486.png" alt="image-20230802144335089"></p><p>这里的value 代表对应的变量值, key代表<code>firstname</code>这些等等</p><p>index是索引, 从0开始往后一次增加 </p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553397.png" alt="image-20230802144744201"></p><p><strong>循环的时候尽量使用key值,避免重复渲染带来的性能问题</strong></p><h4 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h4><p> <img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553233.png" alt="image-20230802144910942"></p><p>实现页面的添加和删除</p><p>pop索引大的开始删,shift从小的开始删除,unshift会忘头部(索引开头)添加东西</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/202308031540064.png" alt="image-20230802145058175"></p><p><code>reverse</code>可以变更顺序</p><p><strong>2-直接替换数组</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553962.png" alt="image-20230802145323072"></p><h4 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553459.png" alt="image-20230802145551010"></p><p>在老版本的vue中出直接修改对象里面的内容可能会有一定的问题</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553828.png" alt="image-20230802145822932"></p><p>这个是实现不展示lastName,但是要注意 <strong>循环和判断不要写在一个标签上,循环的优先级会更高,如果要筛序性展示,则新创建一个div标签,来选择是否展示</strong>  </p><p>为了避免每一层多一个div标签</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553409.png" alt="image-20230802150211640"></p><p>这列<code>template</code> 知识占位符,并不会影响渲染效果</p><h3 id="2-8-事件绑定"><a href="#2-8-事件绑定" class="headerlink" title="2.8 事件绑定"></a>2.8 事件绑定</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554966.png" alt="image-20230802161607518"></p><p>如果要传参,且还要原生的event事件,就可以在event前面加一个$传递过去</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554472.png" alt="image-20230802161831118"></p><p>如果要使用多个函数,就不能只写函数名了,要加上括号</p><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>stop:避免冒泡</p><p><code>@click.stop = &quot;方法&quot;</code></p><p>.self 只有点自己才会执行,点子标签里面的其他元素则不会执行</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554812.png" alt="image-20230802162356544"></p><p>.prevent组织默认行为</p><p>.capture 捕获</p><p>once 只执行一次,再点击就不会执行</p><p>@scroll.passive</p><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554363.png" alt="image-20230802162853911"></p><p>exact是只按ctrl这个键再点击执行的,精确执行</p><h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><p><strong>v-model</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554224.png" alt="image-20230802163233015"></p><p>输入框的值变,页面渲染的值跟着改变</p><p><strong>textarea</strong></p><p>​<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554954.png" alt="image-20230802163655598"></p><p>checkbox:<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554461.png" alt="image-20230802163733528"></p><p> false跟着点击 变成true再变回来</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554729.png" alt="image-20230802171339552"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555260.png" alt="image-20230802163853755"></p><p>自定义值取代false True</p><p>多个checkbox会往数组里面存Value</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555383.png" alt="image-20230802164001558"></p><p><strong>radio</strong></p><p>是单选,不能都放到数组中</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555570.png" alt="image-20230802163946958"></p><p>初始值要变成字符串,选谁变成谁</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555611.png" alt="image-20230802164057819"></p><p><strong>select</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555088.png" alt="image-20230802164357563"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555997.png" alt="image-20230802164204475"></p><p><strong>加上multiple变成多选</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555900.png" alt="image-20230802164631503"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555807.png" alt="image-20230802164650502"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555841.png" alt="image-20230802164838310"></p><p>最终存储会将value里面的对象作为存储的值</p><p>帮助我吗做项目临时转化</p><h4 id="表单中双向绑定的使用"><a href="#表单中双向绑定的使用" class="headerlink" title="表单中双向绑定的使用"></a>表单中双向绑定的使用</h4><p>lazy</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556984.png" alt="image-20230802171443748"></p><p>当失去焦点的时候渲染页面展示的值,跟v-model不一样的地方在于不实时渲染</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556604.png" alt="image-20230802171603688"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556448.png" alt="image-20230802171623240"></p><p>输入内容的时候由String变成number</p><p><strong>trim</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031549888.png" alt="image-20230802171807151"></p><p>只去除字符串前后字符,中间的不会去除</p><h2 id="3-探索组件的概念"><a href="#3-探索组件的概念" class="headerlink" title="3.探索组件的概念"></a>3.探索组件的概念</h2><h3 id="3-1-组件的定义及复用性"><a href="#3-1-组件的定义及复用性" class="headerlink" title="3.1 组件的定义及复用性"></a>3.1 组件的定义及复用性</h3><p> <img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556849.png" alt="image-20230803152607203"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = Vue.createApp(&#123;</span><br><span class="line">      template: `&lt;div&gt;&lt;hello /&gt;&lt;world /&gt;&lt;/div&gt;`,</span><br><span class="line">    &#125;)</span><br><span class="line">    app.component(&#x27;hello&#x27;, &#123;</span><br><span class="line">      template: `&lt;div&gt;hello&lt;/div&gt;`</span><br><span class="line">    &#125;)</span><br><span class="line">    app.component(&#x27;world&#x27;, &#123;</span><br><span class="line">    template: `&lt;div&gt;world&lt;/div&gt;`</span><br><span class="line">    &#125;)    </span><br><span class="line"></span><br><span class="line">    const vm =  app.mount(&#x27;#root&#x27;)</span><br><span class="line">  &lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>组件可以被复用,但不会和其他组件共享</p><p>独享</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031616842.png" alt="image-20230803161654775"></p><p>app.component定义的组件是全局的,不仅在父组件可以用,在其他的组件里也可以用,</p><p>就算不用组件,但仍会挂载到app上,影响性能,使用简单</p><h3 id="3-2-局部组件"><a href="#3-2-局部组件" class="headerlink" title="3.2 局部组件"></a>3.2 局部组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"></span><br><span class="line">  const hello = &#123;</span><br><span class="line">    template: `&lt;div&gt;hello&lt;/div&gt;`</span><br><span class="line">  &#125;</span><br><span class="line">  const counter = &#123;</span><br><span class="line">   data()&#123;</span><br><span class="line">     return&#123;</span><br><span class="line">       count: 1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   template:   `&lt;div @click = &quot;count += 1&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;`</span><br><span class="line"> &#125;</span><br><span class="line">    const app = Vue.createApp(&#123;</span><br><span class="line">      components: &#123;&#x27;counter&#x27;: counter,</span><br><span class="line">                  &#x27;hello&#x27;:hello</span><br><span class="line">                   &#125;,  // counter ES6</span><br><span class="line">      template: `&lt;div&gt;&lt;counter /&gt;&lt;hello /&gt;&lt;/div&gt;`,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const vm = app.mount(&#x27;#root&#x27;)</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>全局组件建议小写字母单词,中间横线连接</p><p>一般将局部组件首字母大写,驼峰命名法: HelloWorld;</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031632348.png" alt="image-20230803163246287"></p><p>可以略写X部分,系统会自动映射,只把组件名写上去也可以</p><p>局部组件:定义了.要注册之后才能使用,性能比较高,使用起来有些麻烦</p><p>局部组件使用时,要做一个名字和组件间的映射印象</p><h3 id="3-3-组件间传值及传值校验"><a href="#3-3-组件间传值及传值校验" class="headerlink" title="3.3 组件间传值及传值校验"></a>3.3 组件间传值及传值校验</h3><p><code>props:[]</code></p><p><strong>动态传参</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = Vue.createApp(&#123;</span><br><span class="line">      data()&#123;</span><br><span class="line">        return &#123;num:132&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: `&lt;div&gt;&lt;test :content = &quot;num&quot;/&gt;&lt;/div&gt;`</span><br><span class="line">    &#125;)    </span><br><span class="line">    app.component(&#x27;test&#x27;,&#123;</span><br><span class="line">      props: [&#x27;content&#x27;],</span><br><span class="line">      template:`</span><br><span class="line">        &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;</span><br><span class="line">      `</span><br><span class="line">    &#125;)</span><br><span class="line">    const vm =  app.mount(&#x27;#root&#x27;)</span><br><span class="line">  &lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>通过父组件中的content与data中的num绑定,来实现动态的传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.component(&#x27;test&#x27;,&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    content: String</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>意思是需要传递字符串进来,其他类型会警告</p><p><strong>函数传递</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031731183.png" alt="image-20230803173120103"></p><p>​<strong>其他的参数:</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031732207.png" alt="image-20230803173247168"></p><p>required:需要传值但是没传</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031734583.png" alt="image-20230803173412544"></p><p>default可以是数,也可以是函数,代表不传参的时候显示什么</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031735607.png" alt="image-20230803173525564"></p><p>需要&lt;1000, &gt;1000会警告</p><h3 id="3-4-单项数据流的理解"><a href="#3-4-单项数据流的理解" class="headerlink" title="3.4 单项数据流的理解"></a>3.4 单项数据流的理解</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032131494.png" alt="image-20230803213149393"></p><p>这样写太麻烦,可以通过对象来简化</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032135225.png" alt="image-20230803213528186"></p><p><code>v-bind = “params”</code>等价于 :content &#x3D; “params.content”依次往后</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032138022.png" alt="image-20230803213821963"></p><p>父组件里面用“-” ,子组件要用驼峰来接收</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032140887.png" alt="image-20230803214049744"></p><p>这样写会报错</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032143297.png" alt="image-20230803214321237"></p><p>可以这样写,复制一份数组再修改</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032144072.png" alt="image-20230803214434014"></p><p>如果子组件改父组件里面的数据,那么其他接收data中的数据也会改变,应该避免数据间的耦合.避免以后潜在的bug</p><h3 id="3-5-Non-Props属性"><a href="#3-5-Non-Props属性" class="headerlink" title="3.5 Non-Props属性"></a>3.5 Non-Props属性</h3><p>​父组件像子组件传值的时候,这些不用的属性该怎么用<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042035421.png" alt="image-20230804203533322">如果接收参数,那么就会如图所示等价</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042038978.png" alt="image-20230804203806926"></p><p>加上这个,就不会添加msg属性值了</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042040385.png" alt="image-20230804204033308"></p><p><code>$attrs</code>的意思是父组件传的所有值都可以放到这个标签上来</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042041031.png" alt="image-20230804204148993"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042042054.png" alt="image-20230804204230991"></p><h3 id="3-6-父子组件通过事件通信"><a href="#3-6-父子组件通过事件通信" class="headerlink" title="3.6 父子组件通过事件通信"></a>3.6 父子组件通过事件通信</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042050874.png" alt="image-20230804205040790"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042051498.png" alt="image-20230804205117437"></p><p><strong>v-model简化操作</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042101724.png" alt="image-20230804210143645"></p><p>这里的modelValue都是固定的,怒等改编成其他的值</p><p>但如果叫其他值,可以按下面的来写</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042102990.png" alt="image-20230804210239629"></p><h3 id="3-7-插槽"><a href="#3-7-插槽" class="headerlink" title="3.7 插槽"></a>3.7 插槽</h3><p>如果传递dom或者标签元素时,用props是非常麻烦,这时候就可以采用插槽</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051245440.png" alt="image-20230805124502379"></p><p>如果父组件想给子组件传递dom元素或者节点时,可以通过插槽来完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = Vue.createApp(&#123;</span><br><span class="line">      </span><br><span class="line">      template: `&lt;myform&gt;</span><br><span class="line">         &lt;div&gt;提交&lt;/div&gt;</span><br><span class="line">        &lt;/myform&gt;</span><br><span class="line">        &lt;myform&gt;</span><br><span class="line">          &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">        &lt;/myform&gt;</span><br><span class="line">        `,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    app.component(&#x27;myform&#x27;,&#123;</span><br><span class="line">      methods:&#123;</span><br><span class="line">        handleClick()&#123;</span><br><span class="line">          alert(123)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template:`</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input /&gt;</span><br><span class="line">        &lt;span @click = &quot;handleClick&quot;&gt;</span><br><span class="line">          &lt;slot&gt;&lt;/slot&gt; </span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      `</span><br><span class="line">    &#125;)</span><br><span class="line">    const vm = app.mount(&#x27;#root&#x27;)</span><br></pre></td></tr></table></figure><p>但slot不能绑定事件,如果要绑定事件,可以写在被绑定事件的span标签里面</p><ul><li>slot插槽</li><li>slot 中使用的数据,作用域的问题</li><li>父模版里调用的数据属性, 使用的都是父模版里面的数据</li><li>子模版里调用的数据属性,使用的都是子模版里面的数据</li></ul><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051251218.png" alt="image-20230805125142156"></p><p>如果slot没有接收到元素,会使用中间的默认元素</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051255773.png" alt="image-20230805125547696"></p><p>template是占位符</p><p><strong>给slot命名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const app = Vue.createApp(&#123;</span><br><span class="line">    </span><br><span class="line">    template: `</span><br><span class="line">    &lt;myform&gt;</span><br><span class="line">      &lt;template v-slot:header&gt;</span><br><span class="line">       &lt;div&gt;提交1&lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:footer&gt;</span><br><span class="line">        &lt;button&gt;提交2&lt;/button&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/myform&gt;</span><br><span class="line">      `,</span><br><span class="line">  &#125;)</span><br><span class="line">  app.component(&#x27;myform&#x27;,&#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">      handleClick()&#123;</span><br><span class="line">        alert(123)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:`</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span @click = &quot;handleClick&quot;&gt;</span><br><span class="line">        &lt;slot name = &quot;footer&quot;&gt;&lt;/slot&gt; </span><br><span class="line">        &lt;slot name = &quot;header&quot;&gt;&lt;/slot&gt; </span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line">  const vm = app.mount(&#x27;#root&#x27;)</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><p><strong>作用域插槽</strong></p><p>父组件使用子组件里面的数据</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051339916.png" alt="image-20230805133945833"></p><h3 id="3-8-动态组件和异步组件"><a href="#3-8-动态组件和异步组件" class="headerlink" title="3.8 动态组件和异步组件"></a>3.8 动态组件和异步组件</h3><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>两个组件,实现:点一个组件,另一个组件小时.反之亦然</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061312887.png" alt="image-20230806130836900"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061312268.png" alt="image-20230806131217319"></p><h4 id="异步组件-用得少"><a href="#异步组件-用得少" class="headerlink" title="异步组件(用得少)"></a>异步组件(用得少)</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061316337.png" alt="image-20230806131626259"></p><ul><li>根据数据的变化,结合component这个标签, 来随时动态切换组件的现实</li><li>异步组件:是异步执行某些组件的逻辑,这叫做异步组件</li></ul><h3 id="3-9-基础语法知识点查缺补漏"><a href="#3-9-基础语法知识点查缺补漏" class="headerlink" title="3.9 基础语法知识点查缺补漏"></a>3.9 基础语法知识点查缺补漏</h3><p><strong>v-once</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061501613.png" alt="image-20230806150110546"></p><p><strong>ref</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061505195.png" alt="image-20230806150502129"></p><p><strong>provide &#x2F; inject</strong></p><p>解决多层值的传递</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061509364.png" alt="image-20230806150918260"></p><h2 id="4-动画"><a href="#4-动画" class="headerlink" title="4. 动画"></a>4. 动画</h2><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><p> 一个简单的动画形式</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071647566.png" alt="image-20230807164657444"></p><p>用Vue来控制</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071648045.png" alt="image-20230807164817981"></p><p><strong>过渡效果</strong></p><p>背景切换的一个操作</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071651110.png" alt="image-20230807165144060"></p><p>transition表示背景切换,3s缓慢变动</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071653304.png" alt="image-20230807165347203"></p><p><strong>带点Vue特色来实现</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071659956.png" alt="image-20230807165929874"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071701963.png" alt="image-20230807170129879"></p><p>其实和原生js并没有太大区别,只是从面向dom到面向数据</p><h4 id="使用单元素组件实现过渡"><a href="#使用单元素组件实现过渡" class="headerlink" title="使用单元素组件实现过渡"></a>使用单元素组件实现过渡</h4><p>使用transition标签来实现入场和出场动画</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071709596.png" alt="image-20230807170928536"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071713080.png" alt="image-20230807171307031"></p><p>对v-重命名</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071715562.png" alt="image-20230807171531515"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方</title>
      <link href="/2023/07/30/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2023/07/30/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先这道题可以直接用暴力,for循环.加一个函数方法sort<br>但会提高实践复杂度,用双指针会优化</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>因为非递减数组,在两边的平方要么是最大,要么是最小,一定是在两边,所以这时候可以用双指针,在数组两边定义两个指针,当左边的平方小于右边的平方,就往一个新数组放,放在最大索引处,然后左边++,同理,右边–.直到左边小于右边</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: <blockquote><p>$O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] *= nums[i];</span><br><span class="line">        &#125;                   </span><br><span class="line">        Arrays.sort(res) ;<span class="comment">//如果递减就  Arrays.sort(a, Collections.reverseOrder());</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> []res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]; <span class="comment">//递增存到新数组中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length-<span class="number">1</span>; <span class="comment">//新数组的索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length-<span class="number">1</span>; l &lt;= r; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]*nums[l] &lt;= nums[r]*nums[r]) &#123;</span><br><span class="line">                 res[k--] = nums[r]*nums[r];</span><br><span class="line">                 r --;</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[k--] = nums[l]*nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="/2023/07/29/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2023/07/29/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先可以用暴力,两层for循环.但O(n^2)<br>快慢双指针:通过两个指针,来对数组进行处理</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>首先定义一个慢指针si,然后再循环中定义一个快指针fi,然后通过判断fi和val1是否相等,如果相等,说明这个值要被覆盖,所以慢指针停止,快指针向后,直到快指针和对应的val2不相等,就可一将这个值覆盖到val1的位置上,然后将<code>si++</code>,直到遍历完整个数组</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义快指针和慢指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//慢指针,快指针因为要不断更新,所以要在for中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="number">0</span>; fi &lt; nums.length; fi++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fi] != val)&#123; <span class="comment">//慢指针更新的条件</span></span><br><span class="line">                nums[si++] = nums[fi]; <span class="comment">// 将符合条件的元素往不符合条件的元素覆盖</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> si;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分(一)</title>
      <link href="/2023/07/28/%E4%BA%8C%E5%88%86-%E4%B8%80/"/>
      <url>/2023/07/28/%E4%BA%8C%E5%88%86-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-二分-一-date-2023-07-28-21-51-36找数"><a href="#title-二分-一-date-2023-07-28-21-51-36找数" class="headerlink" title="title: 二分(一)date: 2023-07-28 21:51:36找数"></a>title: 二分(一)<br>date: 2023-07-28 21:51:36<br>找数</h2><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>从题目中可以看出,数组中的元素是<strong>有序的</strong>,而且是<strong>不重复的</strong>,很满足二分法的使用条件,所以使用二分法来解决这道题,同时二分有两种情况,一种是左闭右闭,一种是左闭右开,而这两种情况在代码的形式上是不一样的.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>以right &#x3D;&#x3D; left(两边顶点)为终止条件,根据左闭又开或左闭右闭来调整每一轮循环之后right和left两边端点的位置.始终将target在端点之间,直到right &#x3D; left.</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>O(log n)</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>O(1)</p></blockquote></li></ul><h1 id="Code-JAVA"><a href="#Code-JAVA" class="headerlink" title="Code[JAVA]"></a>Code[JAVA]</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> right+left &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code-C"><a href="#Code-C" class="headerlink" title="Code[C++]"></a>Code[C++]</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> middle  = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle<span class="number">-1</span>;<span class="comment">//右开</span></span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(nums[middle] == target)&#123;</span><br><span class="line">              <span class="keyword">return</span> middle;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/2023/07/28/My-first-blog/"/>
      <url>/2023/07/28/My-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
