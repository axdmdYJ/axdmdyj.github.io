<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yj的Better之路</title>
  
  
  <link href="https://axdmdyj.github.io/atom.xml" rel="self"/>
  
  <link href="https://axdmdyj.github.io/"/>
  <updated>2024-02-14T14:38:44.647Z</updated>
  <id>https://axdmdyj.github.io/</id>
  
  <author>
    <name>coderLyj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>泛型在项目中不怎么用？这次结合实战！</title>
    <link href="https://axdmdyj.github.io/posts/20748c35.html"/>
    <id>https://axdmdyj.github.io/posts/20748c35.html</id>
    <published>2024-02-14T14:33:44.000Z</published>
    <updated>2024-02-14T14:38:44.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>泛型在项目中用的确实相对没有那么多，但是也可以提供一些便捷，本文先从基础介绍，然后在文章最后讲解项目实战中的一些使用，超级详细！🌟</p></blockquote><p>[TOC]</p><h1 id="泛型基础"><a href="#泛型基础" class="headerlink" title="泛型基础"></a>泛型基础</h1><h2 id="为什么引入泛型"><a href="#为什么引入泛型" class="headerlink" title="为什么引入泛型"></a>为什么引入泛型</h2><ul><li><strong>适用于多种数据类型执行相同的代码</strong>（代码复用）</li><li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li><li>Java泛型也是一种语法糖，在<strong>编译阶段完成类型的转换的工作</strong>，避免在运行时强制类型转换而出现ClassCastException,类型转化异常。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>不引入泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">target_01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">11</span>);</span><br><span class="line">        list.add(<span class="string">&quot;落雨既然&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println((String)list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>会报类型转换异常：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46b5cd26895e468a86a1d210994cc6b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1432&h=262&s=35825&e=png&b=202124" alt="image.png"></p><ul><li>使用泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">target_01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;落雨既然&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println((String)list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b342e5999f74c66a171e95f213e2c51~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=236&s=12681&e=png&b=1e1f22" alt="image.png"><br>在上述的实例中，我们只能添加String类型的数据，否则编译器会报错。</p><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul><li>泛型类概述：把泛型定义在类上</li><li>定义格式：</li></ul><blockquote><p>注意事项：泛型类型必须是引用类型（非基本数据类型）</p></blockquote><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul><li>泛型方法概述：把泛型定义在方法上</li><li>定义格式：</li></ul><blockquote><p>注意要点：<strong>方法声明</strong>中定义的<strong>形参只能在该方法里使用</strong>，而<strong>接口、类声明中定义的类型形参</strong>则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="comment">// 泛型方法，可以接收任意类型的数据</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fun</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接将参数返回</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo26</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化Demo对象</span></span><br><span class="line">    <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    <span class="comment">// 传递字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> d.fun(<span class="string">&quot;落雨既然&quot;</span>);</span><br><span class="line">    <span class="comment">// 传递数字，自动装箱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> d.fun(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 输出字符串内容</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="comment">// 输出数字内容</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  输出：</span></span><br><span class="line"><span class="comment">//  落雨既然</span></span><br><span class="line"><span class="comment">//  30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/075218b91c3a42418fe096972490a7fd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1199&h=543&s=25686&e=png&b=fefefe" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de3e70bb1a0c4e27b035264405a907f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=950&h=248&s=22406&e=png&b=ffffff" alt="image.png"><br>说明一下，定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。<br>Class<T>的作用就是指明泛型的具体类型，而Class<T>类型的变量c，可以用来创建泛型类的对象。<br>为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。<br>泛型方法要求的参数是Class<T>类型，而Class.forName()方法的返回值也是Class<T>，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class<T>就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class<User>类型的对象，因此调用泛型方法时，变量c的类型就是Class<User>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。<br>当然，泛型方法不是仅仅可以有一个参数Class<T>，可以根据需要添加其他参数。<br><strong>为什么要使用泛型方法呢</strong>？<br>因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p><h3 id="泛型上下限"><a href="#泛型上下限" class="headerlink" title="泛型上下限"></a>泛型上下限</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;? extends A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funD</span><span class="params">(List&lt;B&gt; listB)</span> &#123;</span><br><span class="line">    funC(listB); <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。&lt;? extends A&gt;表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。<br>如果不用泛型就会报错：&#x2F;&#x2F; Unresolved compilation problem: The method doPrint(List<A>) in the type test is not applicable for the arguments (List<B>)<br>上界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br></pre></td></tr></table></figure><p>下界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Info&lt;? <span class="built_in">super</span> String&gt; temp)</span>&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br></pre></td></tr></table></figure><p>小结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt; 无限制通配符</span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</span><br><span class="line">&lt;? <span class="built_in">super</span> E&gt; <span class="built_in">super</span> 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原则《Effictive Java》</span></span><br><span class="line"><span class="comment">// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</span></span><br><span class="line"><span class="number">1.</span> 如果参数化类型表示一个 T 的生产者，使用 &lt; ? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;;</span><br><span class="line"><span class="number">2.</span> 如果它表示一个 T 的消费者，就使用 &lt; ? <span class="built_in">super</span> T&gt;；</span><br><span class="line"><span class="number">3.</span> 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</span><br></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure><ul><li>使用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo30</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Integer i[] = fun1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) ;   <span class="comment">// 返回泛型数组  </span></span><br><span class="line">        fun2(i) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun1(T...arg)&#123;  <span class="comment">// 接收可变参数  </span></span><br><span class="line">        <span class="keyword">return</span> arg ;            <span class="comment">// 返回泛型数组  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(T param[])</span>&#123;   <span class="comment">// 输出  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收泛型数组：&quot;</span>) ;  </span><br><span class="line">        <span class="keyword">for</span>(T t:param)&#123;  </span><br><span class="line">            System.out.print(t + <span class="string">&quot;、&quot;</span>) ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da0e9136ae784482a65592dd47561d02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1756&h=1130&s=248753&e=png&b=222427" alt="image.png"></p><h1 id="深入理解泛型"><a href="#深入理解泛型" class="headerlink" title="深入理解泛型"></a>深入理解泛型</h1><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p><strong>泛型的类型擦除原则</strong>是：</p><ul><li>消除类型参数声明，即删除&lt;&gt;及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2dc031266c04baf8fca9ac12a25ad22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=776&h=223&s=30986&e=png&a=1&b=000000" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ac4d20ae2a479fb71d9ff2f7a7101e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=822&h=236&s=31204&e=png&a=1&b=000000" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a56013c830d44a2fa84bac6bc42eb717~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982&h=144&s=20440&e=png&a=1&b=fb9f00" alt="image.png"></p><h2 id="类型擦除保留的原始类型"><a href="#类型擦除保留的原始类型" class="headerlink" title="类型擦除保留的原始类型"></a>类型擦除保留的原始类型</h2><p>原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p><h2 id="泛型在编译器的检查"><a href="#泛型在编译器的检查" class="headerlink" title="泛型在编译器的检查"></a>泛型在编译器的检查</h2><p>java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);  </span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p><h1 id="项目中的泛型实战"><a href="#项目中的泛型实战" class="headerlink" title="项目中的泛型实战"></a>项目中的泛型实战</h1><p>泛型很多都是理论，在项目中怎么用呢？<br>比如对于常见的缓存穿透，缓存击穿，我们就可以使用泛型将其封装到一个类里面。<br>比如下面代码，是黑马点评项目中的一个点：<strong>通过泛型 + 函数式编程封装成通用解决方案。</strong><br><strong>难点：</strong></p><ul><li><strong>泛型方法</strong>的使用：返回值类型不确定、id类型不确定。所以就声明泛型，<strong>让调用者告诉我们泛型</strong>是什么；</li><li><strong>使用函数式接口</strong>：牵扯到数据库查询，需要参数和返回值，使用函数式接口Function&lt;ID,R&gt;<ul><li>四大函数式接口 Function&lt;T,R&gt;   Predicate<T>    Consumer<T>    Supplier<T></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存工具封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//缓存击穿使用的线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将任意java对象序列化为json字符串并存储在string类型的key中，并设置TTL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   string类型的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 任意java对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将任意java对象序列化为json字符串并存储在string类型的key中，并设置逻辑过期时间，用于处理缓存击穿</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   string类型的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 任意java对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  逻辑时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// RedisData对象，设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决缓存穿透</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix  key前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id         id不知道什么类型，所以需要声名泛型ID，名字随意起</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type       是什么类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbFallback 如果redis查询的不是&quot;&quot;，那就需要查询数据库，函数式接口指定逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time       重建缓存后的有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit       时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;        返回值类型，例如Shop类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt;       id不知道什么类型，所以需要声名泛型ID，名字随意起</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在 。isNotBlank只有在 字符串 才返回true。 换行 ，null, &quot;&quot;等都是false</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      3.2  如果不存在，则有  null，&quot;&quot;,换行  等可能性。如果是&quot;&quot;， 则是为了解决缓存穿透而约定的规则</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(json)) &#123;</span><br><span class="line">            <span class="comment">// 解决缓存穿透，不会再去查数据库</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.如果不存在，且不是&quot;&quot; ；那么原因可能是缓存中为null，需要根据id去查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis，调用已经写好的方法,超时剔除</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑过期 解决缓存击穿</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type,String lockKeyPrefix, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">//  3.1 不存在直接返回null，不是热点key</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//  3.2 存在，反序列化为RedisData对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="comment">//        得到R对象</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 4.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 4.1.未过期，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> lockKeyPrefix + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line"><span class="comment">//            在这之前需要DoubleCheck，再次查看redis缓存是否过期</span></span><br><span class="line">            json = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="comment">//            判断是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">                <span class="comment">//            5.2.2.1 存在则判断是否过期，未过期就直接返回，不需要缓存构建</span></span><br><span class="line">                redisData = JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">                r = JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">                expireTime = redisData.getExpireTime();</span><br><span class="line">                <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">                    <span class="comment">//   未过期，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//   6.4 已过期 || 不存在  则重新构建，开启线程池（如果自己new 线程，性能不好）</span></span><br><span class="line"></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存--热点key</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 互斥锁 解决缓存击穿</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type,String lockKeyPrefix, <span class="type">long</span> sleepTime,Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="comment">//        2.判断是否存在 。isNotBlank只有在 字符串 才返回true。 换行 ，null, &quot;&quot;等都是false</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      3.2  如果不存在，则有  null，&quot;&quot;,换行  等可能性。如果是&quot;&quot;， 则是为了解决缓存穿透而约定的规则</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(json)) &#123;</span><br><span class="line"><span class="comment">//            解决缓存穿透，不会再去查数据库</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        4.如果不存在，且不是&quot;&quot; ；那么原因可能是缓存中为null，需要根据id去查询数据库</span></span><br><span class="line"><span class="comment">//        ==========解决缓存击穿==========</span></span><br><span class="line"><span class="comment">//        4.1 获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> lockKeyPrefix + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(sleepTime);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id ,type,lockKeyPrefix,sleepTime, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4 成功，做双重检查锁，查看redis缓存是否存在，存在则无需重建缓存</span></span><br><span class="line">            json = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="comment">// 判断是否存在 。isNotBlank只有在 字符串 才返回true。 换行 ，null, &quot;&quot;等都是false</span></span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">                <span class="comment">//   存在直接返回</span></span><br><span class="line">                r = JSONUtil.toBean(json, type);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//   如果不存在，则有  null，&quot;&quot;,换行  等可能性。如果是&quot;&quot;， 则是为了解决缓存穿透而约定的规则</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(json)) &#123;</span><br><span class="line">                <span class="comment">//           解决缓存穿透，不会再去查数据库</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  5. 到这里说明通过双重检查锁，代表是第一个线程，则根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//        不要直接返回，因为会自动拆箱，如果为null，会报空指针异常。</span></span><br><span class="line"><span class="comment">//        使用工具类</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html#%E6%B3%9B%E5%9E%8B%E7%B1%BB">https://pdai.tech/md/java/basic/java-basic-x-generic.html#泛型类</a><br>    <a href="https://juejin.cn/post/6844903925666021389?searchId=202402142156151370FABE70EBA2501841#heading-8">https://juejin.cn/post/6844903925666021389?searchId=202402142156151370FABE70EBA2501841#heading-8</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;泛型在项目中用的确实相对没有那么多，但是也可以提供一些便捷，本文先从基础介绍，然后在文章最后讲解项目实战中的一些使用，超级详细！🌟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;泛型基础&quot;&gt;&lt;a href=&quot;#泛型</summary>
      
    
    
    
    <category term="Java" scheme="https://axdmdyj.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://axdmdyj.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收入门（爱上JVM！！）</title>
    <link href="https://axdmdyj.github.io/posts/63f114ae.html"/>
    <id>https://axdmdyj.github.io/posts/63f114ae.html</id>
    <published>2024-01-30T02:48:52.000Z</published>
    <updated>2024-01-30T02:53:09.606Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><meta name="referrer" content="no-referrer" /><h1 id="如何判断对象可回收"><a href="#如何判断对象可回收" class="headerlink" title="如何判断对象可回收"></a>如何判断对象可回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>如果一个对象被其他变量所引用，则让该对象的引用计数+1，如果该对象被引用2次则其引用计数为2，依次类推。<br>某个变量不再引用该对象，则让该对象的引用计数-1，当该对象的引用计数变为0时，则表示该对象没用被其他变量所引用，这时候该对象就可以被作为垃圾进行回收。<br>引用计数法弊端：循环引用时，两个对象的引用计数都为1，导致两个对象都无法被释放回收。最终就会造成内存泄漏！<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706285104990-31a78b77-2fa1-4cdf-95ed-5796e62cca6f.png#averageHue=%23f8f8f7&clientId=u30874917-ba43-4&from=paste&height=173&id=ua318ec17&originHeight=346&originWidth=718&originalType=binary&ratio=2&rotation=0&showTitle=false&size=41902&status=done&style=none&taskId=u5e50c46c-531b-4b80-8438-a79c782602a&title=&width=359" alt="image.png"></p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法：就是JVM中判断对象是否是垃圾的算法：该算法首先要确定GC Root(根对象，就是肯定不会被当成垃圾回收的对象)。<br>在垃圾回收之前，JVM会先对堆中的所有对象进行扫描，判断每一个对象是否能被GC Root直接或者间接的引用，如果能被根对象直接或间接引用则表示该对象不能被垃圾回收，反之则表示该对象可以被回收：<br>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象。<br>扫描堆中的对象，看能否沿着GC Root为起点的引用链找到该对象，如果找不到，则表示可以回收，否则就可以回收。<br>可以作为GC Root的对象：<br>虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>方法区中类静态属性引用的对象。<br>方法区中常量引用的对象<br>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p><blockquote><p>可以理解成一个葡萄，从根出发能到达各个葡萄的位置。</p></blockquote><p>案例演示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286510162-965b841c-3f1b-4c05-90cc-da4fb616d941.png#averageHue=%23faf9f9&clientId=u9964b7dd-f54e-4&from=paste&height=636&id=uca5ea950&originHeight=1272&originWidth=2810&originalType=binary&ratio=2&rotation=0&showTitle=false&size=721676&status=done&style=none&taskId=u1b2faba7-4158-476c-b9ea-706e1393da6&title=&width=1405" alt="image.png"><br>这里在list1有无值两方面抓取快照。<br>然后通过eclipse提供的MAT工具来 <code>GCRoot</code>，哪些可以作为<code>GCRoot</code><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286861093-06406389-103f-4a01-abf0-dad164d4f4de.png#averageHue=%23ece9e2&clientId=u9964b7dd-f54e-4&from=paste&height=262&id=u1d8e0269&originHeight=524&originWidth=1204&originalType=binary&ratio=2&rotation=0&showTitle=false&size=234129&status=done&style=none&taskId=ua9ee7593-c0ac-404a-9ca8-c06fc092092&title=&width=602" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286775480-81f7544c-d99f-44e1-aa5b-e186d932bc12.png#averageHue=%23eae8e2&clientId=u9964b7dd-f54e-4&from=paste&height=467&id=u08ab5f86&originHeight=934&originWidth=2308&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1147449&status=done&style=none&taskId=u7c022eb1-cce0-48fe-863b-fe141f1e59f&title=&width=1154" alt="image.png"><br>这些都可以作为<code>gcroot</code><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287024040-9700c11d-1fcb-41df-9314-24ab95d9f363.png#averageHue=%23edede8&clientId=u9964b7dd-f54e-4&from=paste&height=761&id=u2aa131a4&originHeight=1522&originWidth=2546&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1286962&status=done&style=none&taskId=uefd0b948-48df-401f-84cc-eb2f1f850b0&title=&width=1273" alt="image.png"></p><ul><li>所以以后我们查看跟对象就可以通过MAT工具啦。</li></ul><h1 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706341743263-6f3e11ef-731f-4948-9b2a-92758904999c.png#averageHue=%23dedad4&clientId=u9964b7dd-f54e-4&from=paste&height=644&id=gTuV2&originHeight=1288&originWidth=2066&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1168397&status=done&style=none&taskId=u6b208f64-cea3-4c93-bf18-e96e793340f&title=&width=1033" alt="image.png"></p><h2 id="强软弱"><a href="#强软弱" class="headerlink" title="强软弱"></a>强软弱</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287702315-3b3cbca2-5e11-48e5-b188-6afc037d3d97.png#averageHue=%23f9f7f0&clientId=u9964b7dd-f54e-4&from=paste&height=614&id=u969b987b&originHeight=1228&originWidth=2376&originalType=binary&ratio=2&rotation=0&showTitle=false&size=580538&status=done&style=none&taskId=u7a15e292-5bcc-4dc6-9b5a-2e578847c76&title=&width=1188" alt="image.png"></p><ul><li>强引用：对于A1对象，只有两个<code>GC Root</code>都不在引用它，才会释放。</li><li>软引用和弱引用，当内存不够的时候，看你就会释放A2,A3对象，之后软引用和弱引用就会进入到引用队列，如果要释放二者，就需要通过引用队列遍历，然后释放两个引用（因为它们俩也是对象）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287970236-c1deb335-9fff-415c-b008-8eb8b173eef1.png#averageHue=%23f9f8f4&clientId=u9964b7dd-f54e-4&from=paste&height=583&id=ud2beb0e6&originHeight=1166&originWidth=2348&originalType=binary&ratio=2&rotation=0&showTitle=false&size=472767&status=done&style=none&taskId=u18d56396-e792-44ca-8363-a3ffbab3f01&title=&width=1174" alt="image.png"></p><h2 id="虚终"><a href="#虚终" class="headerlink" title="虚终"></a>虚终</h2><ul><li>虚引用和终引用必须配合引用队列使 用</li></ul><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706340580486-818f346a-e34f-4cad-8e88-343a2b7460d2.png#averageHue=%23f9f7f3&clientId=u9964b7dd-f54e-4&from=paste&height=339&id=u8641f669&originHeight=678&originWidth=1480&originalType=binary&ratio=2&rotation=0&showTitle=false&size=221705&status=done&style=none&taskId=ucca23a33-d880-46b3-80cc-d1963d16cf8&title=&width=740" alt="image.png"><br>当引用的对于ByteBuffer被回收以后，直接内存还没有被回收，虚引用对象（Cleaner)就会被放入到引用队列中，<br>然后就会由线程<code>ReferencHandler</code>定时去引用队列寻找是否有<code>Cleaner</code>对象，如果有，就会调用Cleaner对象的clean方法，而clean方法就会根据前面记录的直接内存地址，调用Unsafe.freeMemory()方法，来释放直接内存。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706340798493-29f35654-5f12-4f6c-88e9-5b03b2f1eb25.png#averageHue=%23f9f8f4&clientId=u9964b7dd-f54e-4&from=paste&height=316&id=u2f462385&originHeight=632&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=208623&status=done&style=none&taskId=uae20db02-e918-45e7-8dbc-ddc52855982&title=&width=754" alt="image.png"><br>总之虚引用的一个体现是释放直接内存所分配的内存，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存。<br>根据上面的图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用 队列中，然后调用它的clean方法来释放直接内存。</p><blockquote><p>可以回顾一下之前学的直接内存，和Cleaner底层原理。</p></blockquote><h3 id="终引用"><a href="#终引用" class="headerlink" title="终引用"></a>终引用</h3><p>所有的类都继承自Object类，Object类有一个finalize()方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize()方法。调用以后，该对象就可以被垃圾回收了。<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706341322729-5dbafcfd-a4af-4ee5-968a-f77ed1995c06.png#averageHue=%23faf8f6&clientId=u9964b7dd-f54e-4&from=paste&height=500&id=u1816a410&originHeight=1000&originWidth=2268&originalType=binary&ratio=2&rotation=0&showTitle=false&size=275505&status=done&style=none&taskId=ub155ae2c-26a6-48c6-a24a-14e8f67e575&title=&width=1134" alt="image.png"><br>当一个对象重写了finalize方法，肯定是希望通过终结器应用释放。<br>例如上图，当A4对象没有强引用的时候，这时候会进行垃圾回收，虚拟机会对这个对象创建终结器引用，终结器应用会进入到引用队列，但这时候A4对象还没有被释放！！<br>只有当优先级很低的FinallizeHandler线程来应用队列寻找是否有终结器应用，然后调用A4对象的finallize()方法，在下一次垃圾回收的时候A4对象才会得到释放。</p><blockquote><p>所以也就有一个弊端，因为FinallizeHandler线程优先级很低，而且第一次内存回收的时候并不能完全释放。所以有时候对象迟迟得不到释放，内存就会一直被占用，所以这个终结器应用在日常用的并不多。</p></blockquote><hr><h2 id="软引用案例"><a href="#软引用案例" class="headerlink" title="软引用案例"></a>软引用案例</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347165062-a9a75e54-7b71-42cc-9407-bfccde1f4fc9.png#averageHue=%23f0ecdf&clientId=u9964b7dd-f54e-4&from=paste&height=508&id=u63d2e236&originHeight=1016&originWidth=2220&originalType=binary&ratio=2&rotation=0&showTitle=false&size=648652&status=done&style=none&taskId=u136180f6-a625-4acd-af36-d0755c7acb8&title=&width=1110" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347325360-08e2b093-3ff1-4595-9702-44c59b9ebafb.png#averageHue=%23fafaf8&clientId=u9964b7dd-f54e-4&from=paste&height=664&id=u7ab57e66&originHeight=1328&originWidth=2672&originalType=binary&ratio=2&rotation=0&showTitle=false&size=801552&status=done&style=none&taskId=u7e118bab-2526-4e05-906c-19afdfbf113&title=&width=1336" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347369906-fac8d4c4-76e5-4680-9be5-3f7a95d827ad.png#averageHue=%23fcfbfb&clientId=u9964b7dd-f54e-4&from=paste&height=551&id=u1923440c&originHeight=1102&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=439484&status=done&style=none&taskId=uaaff3dc5-e4fa-4dcc-948c-5d857a752d7&title=&width=1153" alt="image.png"><br>让我们细看一下细节。打印gc详情<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347638207-0bf901a4-88df-454f-90e1-857b6149be68.png#averageHue=%23e1dfd8&clientId=u9964b7dd-f54e-4&from=paste&height=473&id=u1690702f&originHeight=946&originWidth=2880&originalType=binary&ratio=2&rotation=0&showTitle=false&size=994686&status=done&style=none&taskId=uc35aa18b-e351-4c35-85db-91a4d54e303&title=&width=1440" alt="image.png"><br>所以在处理一些不重要的对象的时候，就可以通过软引用来降低内存压力。</p><h2 id="软引用-引用队列"><a href="#软引用-引用队列" class="headerlink" title="软引用_引用队列"></a>软引用_引用队列<img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706348021334-2093d593-def0-49e1-81eb-2b2c3efa9a7b.png#averageHue=%23edece6&clientId=u9964b7dd-f54e-4&from=paste&height=446&id=u641eca1e&originHeight=892&originWidth=1680&originalType=binary&ratio=2&rotation=0&showTitle=false&size=524549&status=done&style=none&taskId=ucba936bc-e745-4ee3-86fe-70ef89a69d9&title=&width=840" alt="image.png"></h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347973037-6d201545-2b9b-467c-b5e2-000e71b58f26.png#averageHue=%23f1eee1&clientId=u9964b7dd-f54e-4&from=paste&height=605&id=uc14935a2&originHeight=1210&originWidth=2628&originalType=binary&ratio=2&rotation=0&showTitle=false&size=635074&status=done&style=none&taskId=u6478809c-8762-44e2-bd04-5b2c42d8562&title=&width=1314" alt="image.png"></p><h2 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706348447712-e4db3f90-ab7a-4edc-9622-a70b6db345fa.png#averageHue=%23eeece3&clientId=u9964b7dd-f54e-4&from=paste&height=600&id=u7b445252&originHeight=1200&originWidth=2416&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1236319&status=done&style=none&taskId=u9773bbed-0dbb-41ca-8e06-23ff6565402&title=&width=1208" alt="image.png"><br>弱引用一般会发生在垃圾回收的时候，当内存紧张时，就会回收弱引用对象，同时也会回收弱引用自身。</p><h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>首先有两步</p><ul><li>先标记哪些对象可以是垃圾</li><li>然后清除垃圾回收对象（这里的腾出内存空间并不是将内存空间的字节清 0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。）</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349164883-994f2c35-6859-427d-8ddd-5453e0629fba.png#averageHue=%23f8f8f6&clientId=u9964b7dd-f54e-4&from=paste&height=644&id=ua8b12acc&originHeight=1288&originWidth=1782&originalType=binary&ratio=2&rotation=0&showTitle=false&size=295572&status=done&style=none&taskId=ua30e9cb0-4773-46f5-9471-13046710775&title=&width=891" alt="image.png"></p><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349501497-21a252ea-cc5b-467e-a68f-b982d7752814.png#averageHue=%23f8f8f7&clientId=ud1c445ad-4364-4&from=paste&height=510&id=u69fd961f&originHeight=1020&originWidth=2166&originalType=binary&ratio=2&rotation=0&showTitle=false&size=383709&status=done&style=none&taskId=u5d3ff6a0-6269-496a-8da3-286446eb84e&title=&width=1083" alt="image.png">会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是牵扯到对象的整理移动，需要消耗一定的时间，所以效率较低。 </p><h2 id="复制回收"><a href="#复制回收" class="headerlink" title="复制回收"></a>复制回收</h2><ul><li>第一步，分两个区，From区和 To区</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349661483-d9b3176e-5827-49f4-bdf9-0b4b679c3ccc.png#averageHue=%23faf9f8&clientId=ud1c445ad-4364-4&from=paste&height=204&id=uc1ec8f95&originHeight=408&originWidth=1534&originalType=binary&ratio=2&rotation=0&showTitle=false&size=128470&status=done&style=none&taskId=uceee1eac-d330-46ba-9fad-52660c0ff8a&title=&width=767" alt="image.png"></p><ul><li>第二步，将From区存活的对象复制到To区，完成碎片的整理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349713486-70ce3114-9d57-4f04-b3ad-67d6f577fcad.png#averageHue=%23f6f6f6&clientId=ud1c445ad-4364-4&from=paste&height=200&id=uffb1c45b&originHeight=400&originWidth=1430&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126655&status=done&style=none&taskId=uecf4a7da-fbf5-4b88-a812-41e5cd0df2a&title=&width=715" alt="image.png"></p><ul><li>第三步，交换From区和To区，使To区总是空闲的一块空间</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349723740-6b5d89dd-5c39-447d-9858-49eeb46cf6c7.png#averageHue=%23f9f9f8&clientId=ud1c445ad-4364-4&from=paste&height=183&id=u0fec0796&originHeight=366&originWidth=1472&originalType=binary&ratio=2&rotation=0&showTitle=false&size=128196&status=done&style=none&taskId=u8c7d6052-9e5f-4483-8d43-b9b7fe02819&title=&width=736" alt="image.png"><br>复制算法：将内存分为等大小的两个区域，<strong>FROM</strong>和<strong>TO</strong>（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。<strong>这样也可以避免内存碎片的问题，但是会占用双倍的内存空间</strong>。</p><h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><p>长时间使用的对象放在老年代中（长时间回收一次，回收花费时间久），在内存不足的时候也可能回收，用完即可丢弃的对象放在新生代中（频繁需要回收，回收速度相对较快）：</p><h2 id="堆内存大致分为两块："><a href="#堆内存大致分为两块：" class="headerlink" title="堆内存大致分为两块："></a>堆内存大致分为两块：</h2><p>新生代、老年代；新生代又划分为伊甸园、幸存区from、幸存区to。<br>长时间使用的对象放在老年代中，用完了就丢弃的对象放在新生代中。根据对象生命周期的不同特点，采用不同的垃圾回收算法，老年代发生次数少，新生代比较频繁。不同区域采用不同算法，更有效的对垃圾回收进行管理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881007627-58238735-ea09-46ba-8a18-eb949359a3d5.png#averageHue=%23f8f8f8&clientId=u64d6ddc7-8e02-4&from=paste&height=287&id=uc287fade&originHeight=359&originWidth=1575&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68146&status=done&style=none&taskId=u7422b092-03c8-4cc3-ba33-46651a1163b&title=&width=1260" alt="image.png"></p><h2 id="分代垃圾回收怎么工作："><a href="#分代垃圾回收怎么工作：" class="headerlink" title="分代垃圾回收怎么工作："></a>分代垃圾回收怎么工作：</h2><p>java虚拟机本身就是一个小的操作系统吧？</p><ul><li>新创建的对象首先分配在 伊甸园 区；</li><li>伊甸园 区空间不足时，触发 minor gc ，使用可达性分析算法沿着GC root引用链去找，进行标记的动作；</li><li>采用复制算法将 伊甸园 区 和幸存区from 区存活的对象复制到幸存区to 中，存活的对象年龄加一，然后交换 from to（这里很细节，实际变的不是两块物理地址，而是指针引用）；</li><li>minor gc 会引发 stop the world，因为垃圾回收的时候对象地址发生改变，如果其他线程也在运行，会造成混乱。暂停其他线程，等垃圾回收结束后，恢复用户线程运行；</li><li>新生代触发的STW的时间较短  </li><li>每次minorGC后，eden和from对象都清除干净了 </li><li>每次都把不需要回收和幸存区from留下的移到To中，然后交换From和To的位置</li><li>当幸存区to对象的寿命超过阈值时，会晋升到老年代，最大寿命是15（4bit）</li><li>相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li><li>如果老年代空间不足时，会先尝试触发 minor gc，如果空间仍然不足，那么就触发 full fc ，STW停止的时间更长！</li><li>from和to每次都要留一个空的，空间不足就触发gc，还不足就会触发提前晋升老年代，老年代如果放不下先触发full gc 然后再尝试提前晋升，还不行就Java heap space outofmemoryerror异常</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881771672-021f9d70-7ed1-45bb-a8b4-669bee5ffa8f.png#averageHue=%23fafafa&clientId=u64d6ddc7-8e02-4&from=paste&height=638&id=uc808cb5a&originHeight=798&originWidth=1573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=161287&status=done&style=none&taskId=u8cb047b9-4dfd-4147-ac34-1ff98b7e2ec&title=&width=1258.4" alt="image.png"></p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><p>**含义 **                                      <strong>参数</strong><br>堆初始大小                      -Xms<br>堆最大大小                      -Xmx 或 -XX:MaxHeapSize&#x3D;size<br>新生代大小                      -Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )<br>幸存区比例（动态）       -XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy<br>幸存区比例                      -XX:SurvivorRatio&#x3D;ratio<br>晋升阈值                              -XX:MaxTenuringThreshold&#x3D;threshold<br>晋升详情                              -XX:+PrintTenuringDistribution<br>GC详情                             -XX:+PrintGCDetails -verbose:gc<br>FullGC 前 MinorGC              -XX:+ScavengeBeforeFullGC</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>程序刚加载时的堆内存情况：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648887378100-37e3a00f-3c41-43d5-8c39-92f11622161a.png#averageHue=%23dfdfd7&clientId=u64d6ddc7-8e02-4&from=paste&height=215&id=a9BI9&originHeight=269&originWidth=1365&originalType=binary&ratio=1&rotation=0&showTitle=false&size=285016&status=done&style=none&taskId=udf81d81a-5c97-47f1-8349-81474096d8f&title=&width=1092" alt="image.png"></p><ul><li>代码分析</li></ul><p>通过如下代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，什么时候 幸存区放不下，直接晋升老年代，使用前需要设置 jvm 参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_10_GCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_6MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_6MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_6MB]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大对象处理策略：</li></ul><p>当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371753545-75535f45-80d2-489c-8f35-d314afe78f87.png#averageHue=%23e8e5db&clientId=uf95f9f13-d64b-4&from=paste&height=553&id=u38548cc0&originHeight=1106&originWidth=2760&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1337545&status=done&style=none&taskId=u54c391be-757f-44d5-8341-db97e939c9a&title=&width=1380" alt="image.png"></p><ul><li>线程内存溢出：</li></ul><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行<br>这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371871415-adbf0b45-1eca-4777-b023-54ef6b489891.png#averageHue=%23e9e6dc&clientId=uf95f9f13-d64b-4&from=paste&height=440&id=ufb6758c1&originHeight=880&originWidth=2612&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1083308&status=done&style=none&taskId=u9cfd524a-0556-40ac-9981-6ac5abb0606&title=&width=1306" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371900932-82995376-8d3f-41fe-bd9a-ca5458dec7aa.png#averageHue=%23edeae1&clientId=uf95f9f13-d64b-4&from=paste&height=505&id=u0aa26855&originHeight=1010&originWidth=2768&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1449389&status=done&style=none&taskId=u4d7acb62-58d5-4aa4-b142-34e636f4208&title=&width=1384" alt="image.png"></p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706404931105-79675091-00d1-4596-afff-336934f7f63b.png#averageHue=%23fcfcfc&clientId=uf95f9f13-d64b-4&from=paste&height=350&id=u11683edb&originHeight=700&originWidth=1396&originalType=binary&ratio=2&rotation=0&showTitle=false&size=178508&status=done&style=none&taskId=u3728362f-4a56-439f-85b8-564cf624063&title=&width=698" alt="image.png"> </p><h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p> 在谈论垃圾收集器的上下文语境中， 它们可以理解为：</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>并行（Parallel） ：<br>并行描述的是多条垃圾收集器线程之间的关系， 说明同一时间有多条这样的线程在协同工作， 通常默认此时用户线程是处于等待状态。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>并发（Concurrent） ：<br> 并发描述的是垃圾收集器线程与用户线程之间的关系， 说明同一时间垃圾收集器线程与用户线程都在运行（不一定是并行的可能会交替执行）。 由于用户线程并未被冻结， 所以程序仍然能响应服务请求， 但由于垃圾收集器线程占用了一部分系统资源， 此时应用程序的处理的吞吐量将受到一定影响。 </p><h3 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h3><p>即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</p><h2 id="1）串行"><a href="#1）串行" class="headerlink" title="1）串行"></a>1）串行</h2><p>单线程<br>适用于堆内存较小，如个人电脑（CPU核数较少也可以，因为单线程）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648902517820-ef16f7d9-6770-4e5a-a046-a0e24fb4d5c5.png#averageHue=%23fafafa&clientId=u64d6ddc7-8e02-4&from=paste&height=405&id=ZMcbG&originHeight=506&originWidth=1284&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138942&status=done&style=none&taskId=u83ad8bce-fe92-4f80-9ae8-05716981832&title=&width=1027.2" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC=serial + serialOld</span><br></pre></td></tr></table></figure><h3 id="安全点："><a href="#安全点：" class="headerlink" title="安全点："></a>安全点：</h3><p>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p><h3 id="Serial-收集器："><a href="#Serial-收集器：" class="headerlink" title="Serial 收集器："></a>Serial 收集器：</h3><p>Serial 收集器是最基本的、发展历史最悠久的收集器<br>特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p><h3 id="ParNew-收集器："><a href="#ParNew-收集器：" class="headerlink" title="ParNew 收集器："></a>ParNew 收集器：</h3><ul><li>ParNew 收集器其实就是 Serial 收集器的多线程版本</li><li>除了Serial收集器外， 目前只有它能与CMS收集器配合工作。 </li><li>特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</li></ul><h3 id="Serial-Old-收集器："><a href="#Serial-Old-收集器：" class="headerlink" title="Serial Old 收集器："></a>Serial Old 收集器：</h3><p>Serial Old 是 Serial 收集器的老年代版本<br>特点：同样是单线程收集器，采用标记-整理算法</p><p>在服务端模式下，它也可能有两种用途： 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用， 另外一种就是作为CMS收集器发生失败时的后备预案， 在并发收集发生Concurrent Mode Failure时使用</p><h2 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h2><p><strong>parallel：并行的   Pause：停顿</strong></p><ul><li>多线程</li><li>适合堆内存较大，需要多核 cpu支持</li><li>让单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li>JDK1.8默认使用的垃圾回收器</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648905756956-5700f0dd-4a7a-4a73-b0b2-844407cd7d14.png#averageHue=%23fbfafa&clientId=u64d6ddc7-8e02-4&from=paste&height=633&id=UuKmC&originHeight=791&originWidth=1371&originalType=binary&ratio=1&rotation=0&showTitle=false&size=332475&status=done&style=none&taskId=u7778844b-e4a1-4067-b788-23755ea24c4&title=&width=1096.8" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个是新生代的垃圾回收器,复制算法；第二个是老年代的垃圾回收器，标记整理算法</span></span><br><span class="line"><span class="comment">//都是多线程的，只要开启一个，另外一个就会开启</span></span><br><span class="line"><span class="comment">//工作开启的回收线程数目，与cpu核数有关。回收时，cpu占有率100%</span></span><br><span class="line">-XX:+UseParallelGC ~ -XX:+UsePrallerOldGC  </span><br><span class="line">-XX:+UseAdaptiveSizePolicy   <span class="comment">//GC自适应调节策略，伊甸园和幸存区占比</span></span><br><span class="line">-XX:GCTimeRatio=ratio  <span class="comment">// 垃圾回收和总时间占比 1/(1+radio)</span></span><br><span class="line">-XX:MaxGCPauseMillis=ms  <span class="comment">//  垃圾回收暂停200ms</span></span><br><span class="line">-XX:ParallelGCThreads=n   <span class="comment">//回收线程数 控制</span></span><br></pre></td></tr></table></figure><h3 id="Parallel-Scavenge-收集器："><a href="#Parallel-Scavenge-收集器：" class="headerlink" title="Parallel Scavenge 收集器："></a>Parallel Scavenge 收集器：</h3><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同， CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间， 而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput） 。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值 。</p><p>与吞吐量关系密切，故也称为吞吐量优先收集器<br>特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与 ParNew 收集器类似）<br>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与 ParNew 收集器最重要的一个区别）</p><h3 id="GC自适应调节策略："><a href="#GC自适应调节策略：" class="headerlink" title="GC自适应调节策略："></a>GC自适应调节策略：</h3><p>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。<br>当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、<br>晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。</p><h3 id="Parallel-Scavenge-收集器使用两个参数控制吞吐量："><a href="#Parallel-Scavenge-收集器使用两个参数控制吞吐量：" class="headerlink" title="Parallel Scavenge 收集器使用两个参数控制吞吐量："></a>Parallel Scavenge 收集器使用两个参数控制吞吐量：</h3><p>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）：<br><strong>回收器一般会让堆变小，减少每次停顿的时间</strong><br>XX:GCTimeRatio&#x3D;radio 垃圾收集时间占总时间的比率，相当于吞吐量的倒数<br><strong>回收器一般会让堆变大，去减少垃圾回收次数，从而减少时间</strong></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本<br>特点：多线程，采用标记-整理算法</p><h2 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h2><ul><li>CMS（Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。 </li><li>CMS作为老年代的收集器，新生代只能选择ParNew或者Serial收集器中的一个来配合工作。</li><li>多线程</li><li>适合堆内存较大，需要多核 cpu支持</li><li>面向并发设计的程序都对处理器资源比较敏感。 在并发阶段， 它虽然不会导致用户线程停顿， 但却会因为占用了一部分线程（或者说处理器的计算能力） 而导致应用程序变慢， 降低总吞吐量。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648890886592-6db2f622-b3fb-443a-b8fd-7e7f4a023df6.png#averageHue=%23f9f8f8&clientId=u64d6ddc7-8e02-4&from=paste&height=485&id=u5ffb9327&originHeight=606&originWidth=1300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=347954&status=done&style=none&taskId=u34ec76e5-2f38-4258-b48f-49a9f14f81a&title=&width=1040" alt="image.png"></p><h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个CMS是并发标记清除算法，用户线程与垃圾回收线程并发进行，老年代浮动垃圾过多，退化为 SerialOld</span></span><br><span class="line"><span class="comment">//第二个是parnew新生代多线程回收器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个是并行的垃圾回收线程数，一般跟cpu核数一样；第二个是并发的垃圾回收线程数,一般设置为并行线程数的四分之一</span></span><br><span class="line"><span class="comment">//比如：核数为4，那就占用一个cpu核进行垃圾回收。其他用于用户线程</span></span><br><span class="line">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。</span></span><br><span class="line"><span class="comment">//设置得太高将会很容易导致大量的并发失败产生，性能反而降低;</span></span><br><span class="line"><span class="comment">//设置太低将导致内存回收频率增加，性能降低</span></span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新标记前对新生代 先做一次垃圾回收（UseParNewGC），新生代存活对象少了，减轻重新标记的压力</span></span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器<br>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片<br>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b&#x2F;s 服务</p><h3 id="CMS-收集器的运行过程分为下列4步："><a href="#CMS-收集器的运行过程分为下列4步：" class="headerlink" title="CMS 收集器的运行过程分为下列4步："></a>CMS 收集器的运行过程分为下列4步：</h3><h4 id="初始标记："><a href="#初始标记：" class="headerlink" title="初始标记："></a>初始标记：</h4><p>标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</p><h4 id="并发标记："><a href="#并发标记：" class="headerlink" title="并发标记："></a>并发标记：</h4><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行  。</p><h4 id="重新标记："><a href="#重新标记：" class="headerlink" title="重新标记："></a>重新标记：</h4><p>为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题，这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短。</p><h4 id="并发清除："><a href="#并发清除：" class="headerlink" title="并发清除："></a>并发清除：</h4><p>并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的 </p><h3 id="浮动垃圾："><a href="#浮动垃圾：" class="headerlink" title="浮动垃圾："></a>浮动垃圾：</h3><p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 程序在运行自然就还会伴随有新的垃圾对象不断产生， 但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。 这一部分垃圾就称为“浮动垃圾”。 </p><h3 id="并发失败："><a href="#并发失败：" class="headerlink" title="并发失败："></a>并发失败：</h3><h4 id="浮动垃圾过多："><a href="#浮动垃圾过多：" class="headerlink" title="浮动垃圾过多："></a>浮动垃圾过多：</h4><p>如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p><h4 id="内存碎片过多："><a href="#内存碎片过多：" class="headerlink" title="内存碎片过多："></a>内存碎片过多：</h4><p>CMS是一款基于“标记-清除”算法实现的收集器， 这意味着收集结束时会有大量空间碎片产生。 空间碎片过多时， 将会给大对象分配带来很大麻烦， 往往会出现老年代还有很多剩余空间， 但就是无法找到足够大的连续空间来分配当前对象， 而不得不提前触发一次Full GC的情况。 退化为SerialOld，进行标记整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中， 垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。  </p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706410637194-2dbc95a7-b84c-402d-874b-57919eb1efd7.png#averageHue=%23f9f9f8&clientId=ub86ce6bc-f0e5-4&from=paste&height=668&id=u7218fd82&originHeight=1336&originWidth=1768&originalType=binary&ratio=2&rotation=0&showTitle=false&size=544533&status=done&style=none&taskId=ufe5e1cb2-722f-4b3f-bc4b-a6f653613a2&title=&width=884" alt="image.png"><br><strong>相关参数</strong>：JDK8 并不是默认开启的，需要参数开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// G1开关</span></span><br><span class="line">-XX:+UseG1GC</span><br><span class="line"><span class="comment">// 所划分的每个堆内存大小：</span></span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line"><span class="comment">// 垃圾回收最大停顿时间</span></span><br><span class="line">-XX:MaxGCPauseMillis=time</span><br></pre></td></tr></table></figure><h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706410858075-d732e623-989c-4cc7-8178-1b6b1c57cd1b.png#averageHue=%23faf8f4&clientId=ub86ce6bc-f0e5-4&from=paste&height=548&id=u5ca16fdb&originHeight=1096&originWidth=1560&originalType=binary&ratio=2&rotation=0&showTitle=false&size=379155&status=done&style=none&taskId=ud0fa9d8a-81b3-498e-a14f-4875a606ea3&title=&width=780" alt="image.png"><br><strong>新生代伊甸园垃圾回收</strong>—–&gt;<strong>内存不足，新生代回收+并发标记</strong>—–&gt;<strong>回收新生代伊甸园、幸存区、老年代内存</strong>——&gt;<strong>新生代伊甸园垃圾回收</strong>(重新开始)。</p><h3 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706426885157-a745faef-0948-4621-b83d-0196c3b9fa80.png#averageHue=%23f2efec&clientId=u27dd8642-2384-4&from=paste&height=686&id=ud84899dd&originHeight=1372&originWidth=1934&originalType=binary&ratio=2&rotation=0&showTitle=false&size=472988&status=done&style=none&taskId=u3c3bd328-bfb4-45ed-87d2-3a283a1a749&title=&width=967" alt="image.png"></p><h3 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h3><p>会对E、S 、O 进行<strong>全面的回收</strong>。</p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  用于指定GC最长的停顿时间</span></span><br><span class="line">-XX:MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？<br>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的最大停顿时间，会根据最大停顿时间，有选择的<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）。<br>G1在老年代内存不足时（老年代所占内存超过阈值）：</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理。</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC。</li></ul><h3 id="FullGC概念解析"><a href="#FullGC概念解析" class="headerlink" title="FullGC概念解析"></a>FullGC概念解析</h3><p><strong>SerialGC</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc<br><strong>ParallelGC</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc<br><strong>CMS</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集，需要分2种情况，这里不做详细介绍<br><strong>G1</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集，需要分2种情况，这里不做详细介绍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;如何判断对象可回收&quot;&gt;&lt;a href=&quot;#如何判断对象可回收&quot; class=</summary>
      
    
    
    
    <category term="JVM" scheme="https://axdmdyj.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://axdmdyj.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="https://axdmdyj.github.io/posts/e614237b.html"/>
    <id>https://axdmdyj.github.io/posts/e614237b.html</id>
    <published>2024-01-26T15:55:52.000Z</published>
    <updated>2024-01-26T15:58:26.717Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="程序计数器作用"><a href="#程序计数器作用" class="headerlink" title="程序计数器作用"></a>程序计数器作用</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068166843-cbd811f0-fbc1-4e3a-9098-49bd82b4859f.png#averageHue=%23f6f5f4&clientId=ubb321bbb-5d23-4&from=paste&height=604&id=u1ce3a504&originHeight=1208&originWidth=2710&originalType=binary&ratio=2&rotation=0&showTitle=false&size=857500&status=done&style=none&taskId=u26e39ae6-aeb9-4ab2-837b-0d869bc92dc&title=&width=1355" alt="image.png"></p><h2 id="程序计数器特点"><a href="#程序计数器特点" class="headerlink" title="程序计数器特点"></a>程序计数器特点</h2><p>会通过计数器来记录线程已经执行的位置。<br>加入线程1执行到10的时候，cpu时间片被线程2抢走了，那么当程序计数器就会记录线程1现在执行到了10，当线程2执行完了，就切换回道线程1的10位置继续执行。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068507034-9d51f170-0fa5-4f27-a4f8-a0cb7799e246.png#averageHue=%23fcfbfa&clientId=ubb321bbb-5d23-4&from=paste&height=623&id=u1e352509&originHeight=1246&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=626019&status=done&style=none&taskId=u6d61bb48-f6d2-4ffc-beb3-b2448fbdac9&title=&width=1153" alt="image.png"></p><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068849024-af493dac-e10e-4ca3-9a3c-86d0ce525bbf.png#averageHue=%23e2dfd8&clientId=ubb321bbb-5d23-4&from=paste&height=184&id=ue10ac1ae&originHeight=368&originWidth=1636&originalType=binary&ratio=2&rotation=0&showTitle=false&size=332469&status=done&style=none&taskId=u9e0cf4fa-2e21-4828-8d3e-63d77e83bfa&title=&width=818" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/38717174/1706069201893-7df9fbfe-8a9e-43ad-8740-096786c993e3.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068791865-23031138-06fe-45d1-9edc-bf3f30ee7cad.png#averageHue=%23fbfbfb&clientId=ubb321bbb-5d23-4&from=paste&height=516&id=u35efbc41&originHeight=1032&originWidth=1984&originalType=binary&ratio=2&rotation=0&showTitle=false&size=290459&status=done&style=none&taskId=ud43319b0-6887-415b-a60d-3d401963780&title=&width=992" alt="image.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>垃圾回收是否涉及栈内存？</li></ol><p>不涉及，因为方法执行完之后，对应的栈帧就会自己弹出回收，并没有进行垃圾回收机制。垃圾回收一般是对堆内存的处理</p><ol start="2"><li>栈分配内存越大越好嘛？</li></ol><p>并不是，因为内存是固定的，帧分配内存的增多，也代表着线程占有的内存就减少，线程数量减少，也会减少一定的性能。</p><ol start="3"><li>方法内的局部变量是否线程安全？</li></ol><p>需要看变量是否是线程共享的。还要看是否逃离方法作用范围。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706071725265-0270b390-e87a-4930-9f05-a97b160497b7.png#averageHue=%23f7f4e5&clientId=u31b1620a-440f-4&from=paste&height=153&id=u506c9ea9&originHeight=306&originWidth=1354&originalType=binary&ratio=2&rotation=0&showTitle=false&size=130279&status=done&style=none&taskId=ucfd68fec-9ab2-4da8-86f1-e509ba7a661&title=&width=677" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706069846402-38a6c6b0-0404-4468-8641-5df5dbdb4360.png#averageHue=%23fafafa&clientId=u31b1620a-440f-4&from=paste&height=513&id=ud4fc194c&originHeight=1026&originWidth=1992&originalType=binary&ratio=2&rotation=0&showTitle=false&size=221425&status=done&style=none&taskId=ubf517727-b321-4d5a-aa52-0523f850644&title=&width=996" alt="image.png"></p><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706080173901-24b69618-3a90-4bf4-ad4a-f05a307a7315.png#averageHue=%23f8f8f7&clientId=u31b1620a-440f-4&from=paste&height=508&id=u4a8690e9&originHeight=1016&originWidth=824&originalType=binary&ratio=2&rotation=0&showTitle=false&size=189249&status=done&style=none&taskId=u712fba70-5fb7-4f6d-84d9-883189ac550&title=&width=412" alt="image.png"></p><ul><li>方法递归调用可能会造成栈内存溢出，比如无限递归。</li></ul><h2 id="线程诊断"><a href="#线程诊断" class="headerlink" title="线程诊断"></a>线程诊断</h2><h3 id="CPU占占用过多"><a href="#CPU占占用过多" class="headerlink" title="CPU占占用过多"></a>CPU占占用过多</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167252300-451dad54-a3a3-44ad-a119-32e94568d6a6.png#averageHue=%23000000&clientId=u1de935df-8cd2-4&from=paste&height=78&id=u4fbef33c&originHeight=172&originWidth=1968&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=38601&status=done&style=none&taskId=u46abd4f4-0517-41d0-8e46-a7ac3203c25&title=&width=894.5454351567045" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167298278-43ef52bc-f91a-4f7b-bbea-2956c6317cd5.png#averageHue=%2397958c&clientId=u1de935df-8cd2-4&from=paste&height=96&id=uc1de3923&originHeight=212&originWidth=1982&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=246888&status=done&style=none&taskId=u765c10d4-3ffd-4e36-87c2-81711d97423&title=&width=900.9090713824127" alt="image.png"><br>但只能查看编号。<br>定位到具体的线程<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167387393-72b1f6f0-a593-43d4-969a-1e6e4dfcf9b1.png#averageHue=%23030303&clientId=u1de935df-8cd2-4&from=paste&height=313&id=Mt9F8&originHeight=688&originWidth=1972&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=395776&status=done&style=none&taskId=u21508314-d4a5-4661-a2f3-e539d0f7d75&title=&width=896.3636169354781" alt="image.png"><br>通过jstack,展示具体的线程。<br>通过线程id找到有问题的线程，然后进入到问题代码的源码行数。</p><blockquote><p>注意： 需要将上面操作查到的编号转化为16进制，进而查找到有问题的线程。<br>jstack 【进程id】：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167818182-03f35511-b555-407f-9e17-62aa41c81700.png#averageHue=%23615a51&clientId=u1de935df-8cd2-4&from=paste&height=400&id=u31352e6f&originHeight=880&originWidth=2812&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=1045051&status=done&style=none&taskId=uabba7dc3-c3e1-4b67-9afe-e6e5fff65f6&title=&width=1278.181790477974" alt="image.png"></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>通过jstack 进程号<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706168213873-47fdd144-3cc8-47f9-b8cb-2271bcbed257.png#averageHue=%235d554c&clientId=u1de935df-8cd2-4&from=paste&height=529&id=u91f6d248&originHeight=1164&originWidth=2396&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=1164260&status=done&style=none&taskId=u8817d1b5-6b16-41f8-9df3-9b30214f32a&title=&width=1089.0908854855" alt="image.png"><br>排查死锁问题。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>native方法，由C语言实现。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706080927259-a02dbe3b-0a81-41cd-855c-54ff8b12f893.png#averageHue=%23e3e5bb&clientId=u31b1620a-440f-4&from=paste&height=619&id=u16c6b193&originHeight=1238&originWidth=2122&originalType=binary&ratio=2&rotation=0&showTitle=false&size=608129&status=done&style=none&taskId=u85466131-ecbf-4a0c-9c31-79aa2abbbe8&title=&width=1061" alt="image.png"></p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706081006420-8ef6d956-28c9-4246-9250-aa8d6fb83700.png#averageHue=%23fafaf9&clientId=u31b1620a-440f-4&from=paste&height=262&id=u209252e8&originHeight=524&originWidth=1162&originalType=binary&ratio=2&rotation=0&showTitle=false&size=205511&status=done&style=none&taskId=u2f1cbeca-1dff-4c9e-8a46-c29e2e235d0&title=&width=581" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706168543664-9e9d9da2-7137-4830-8bcc-3f99fff5a094.png#averageHue=%23f6f4e7&clientId=u1de935df-8cd2-4&from=paste&height=218&id=udc6d6332&originHeight=480&originWidth=1648&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=241833&status=done&style=none&taskId=u55731055-3e36-413a-a254-6bb3e396372&title=&width=749.0908928548013" alt="image.png"><br>自定义内存大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//限制</span><br><span class="line"> 限制：-Xms  规定的空间大小</span><br></pre></td></tr></table></figure><h2 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h2><ol><li><strong>jps 工具</strong>查看当前系统中有哪些 java 进程</li><li><strong>jmap 工具</strong>查看堆内存占用情况 jmap - heap 进程id</li><li><strong>jconsole 工具</strong>图形界面的，多功能的监测工具，可以连续监测</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706169692583-4db72f45-c9d2-4e5d-8ab1-4005d723bdb5.png#averageHue=%23fafaf9&clientId=u1de935df-8cd2-4&from=paste&height=299&id=u0d0a30f7&originHeight=658&originWidth=1184&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=356227&status=done&style=none&taskId=uc3a5f5e8-731b-4eeb-ac1e-a1334cf88ce&title=&width=538.1818065170417" alt="image.png"></p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>方法区是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类信息(比如class文件)、常量、静态变量、即时编译器编译后的代码等数据。（什么是类信息：<strong>类版本号、方法、接口</strong>。）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706171339614-3e0df9b8-47ad-4cb6-9924-cafece6a3295.png#averageHue=%23e8f1c1&clientId=u1de935df-8cd2-4&from=paste&height=366&id=u5bfb1624&originHeight=806&originWidth=1232&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=246267&status=done&style=none&taskId=u7a7a9d8c-9ca2-4fdb-bef2-b2a6bb9758e&title=&width=559.9999878623271" alt="image.png"></p><h2 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=1m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodOverFlow</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;<span class="comment">//可以用来加载类的二进制字节码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">MethodOverFlow</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodOverFlow</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++,j++) &#123;</span><br><span class="line">                    <span class="comment">//ClassWriter 作用是生产类的二进制字节码</span></span><br><span class="line">                    <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//版本号，public，类名</span></span><br><span class="line">                    cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//返回 byte[]</span></span><br><span class="line">                    <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                    <span class="comment">//执行类的加载</span></span><br><span class="line">                    test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>场景：<br>Spring<br>Mabatis</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>学会阅读反编译的字字节码与在常量池的对应关系。</p><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>常量池中的字符串仅是符号，只有在被用到时才会转化为对象<br>利用串池的机制，来避免重复创建字符串对象<br><strong>字符串变量拼接的原理是StringBuilder</strong><br><strong>字符串常量拼接的原理是编译器优化</strong><br><strong>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</strong><br>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回<br>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706179848133-12b0a2f5-5396-42bc-abc4-de92d9c118f2.png#averageHue=%23faf9f8&clientId=ubf022d95-0954-4&from=paste&height=576&id=u8cacca97&originHeight=1268&originWidth=1828&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=583009&status=done&style=none&taskId=ue49c3e37-4fe6-45b5-8551-37c0797a8f1&title=&width=830.9090728996217" alt="image.png"><br>先到串池找，找到了就不创建了。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706180110018-ca780935-9ac1-42cd-bde3-5a2bd5366c4f.png#averageHue=%23fbfbfa&clientId=ubf022d95-0954-4&from=paste&height=560&id=u0f191c65&originHeight=1232&originWidth=2602&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=730159&status=done&style=none&taskId=ub3ea0cf1-0c1e-4c50-8e15-b1072eb4cc2&title=&width=1182.7272470923501" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706180368897-e61b89f2-211b-4b04-8280-ff356905d069.png#averageHue=%23fcfbf9&clientId=ubf022d95-0954-4&from=paste&height=230&id=u691d4ea0&originHeight=506&originWidth=2588&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=286843&status=done&style=none&taskId=u57683fea-a763-42af-baa2-6bce12d8509&title=&width=1176.3636108666417" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706180510319-6b0ce27f-ee0b-4c8c-8dea-8a40c536318d.png#averageHue=%23f3f1e9&clientId=ubf022d95-0954-4&from=paste&height=491&id=u51e85250&originHeight=1080&originWidth=2756&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=670056&status=done&style=none&taskId=uefde02df-f82d-4e52-b565-5ee9f18b99d&title=&width=1252.7272455751408" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706195341809-a1ad57f3-9089-476b-910d-edbfe77aec97.png#averageHue=%23f8f7ec&clientId=u515cb933-7cc6-4&from=paste&height=223&id=uf0022656&originHeight=446&originWidth=2190&originalType=binary&ratio=2&rotation=0&showTitle=false&size=343977&status=done&style=none&taskId=u68116973-0802-4c04-bcbc-04dc3870c16&title=&width=1095" alt="image.png"><br>面试问类似的话就比较实在堆区还是在串池中。<br>可以通过以下检验自己：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706195621110-c6928310-f606-4f20-b1d0-f4334e89bb82.png#averageHue=%23fcfbfb&clientId=u515cb933-7cc6-4&from=paste&height=405&id=u5989f7a4&originHeight=810&originWidth=2140&originalType=binary&ratio=2&rotation=0&showTitle=false&size=440100&status=done&style=none&taskId=u29bee30c-7bb5-4f72-bce1-1788ec8f1ea&title=&width=1070" alt="image.png"></p><h3 id="StringTable-位置"><a href="#StringTable-位置" class="headerlink" title="StringTable 位置"></a>StringTable 位置</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706197911734-d199a8c1-10e9-4471-ac10-df2007945a32.png#averageHue=%23e9f1c4&clientId=uc914b68f-3c65-4&from=paste&height=688&id=u1927b1ba&originHeight=1376&originWidth=2260&originalType=binary&ratio=2&rotation=0&showTitle=false&size=452452&status=done&style=none&taskId=u4e29a2ec-2027-4a86-902d-6e4ba7beee2&title=&width=1130" alt="image.png"></p><ul><li>为什么需要metaspace？</li></ul><p>因为永久代的回收效率不高，如果产生太多的字符串常量，可能就会出现内存不足的情况。<br>而在1.8,StringTable在堆中，可以通过minorgc来提高回收效率，降低内存不足的概率。</p><p>案例证明；<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706198156060-7a8da379-4e89-4f79-92c0-d34b4d5a12a5.png#averageHue=%23fafaf9&clientId=uc914b68f-3c65-4&from=paste&height=543&id=uaaac0896&originHeight=1086&originWidth=2646&originalType=binary&ratio=2&rotation=0&showTitle=false&size=826908&status=done&style=none&taskId=ub15b161e-4df9-4dc6-8627-9a3c58604c3&title=&width=1323" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706198356218-bc8256f0-7e2e-4a71-913c-e2b32e87c480.png#averageHue=%23f9f8f6&clientId=uc914b68f-3c65-4&from=paste&height=454&id=u3efc1940&originHeight=908&originWidth=2730&originalType=binary&ratio=2&rotation=0&showTitle=false&size=775095&status=done&style=none&taskId=u5f2a8059-2f34-4546-ba0a-776b7a5f9c6&title=&width=1365" alt="image.png"></p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706234647220-7cc2df98-1965-4e92-a14a-ac70b4907bcb.png#averageHue=%23f1f1f1&clientId=uc914b68f-3c65-4&from=paste&height=418&id=uaac15721&originHeight=836&originWidth=2144&originalType=binary&ratio=2&rotation=0&showTitle=false&size=405082&status=done&style=none&taskId=u18de8e93-3ccc-468e-ba02-20bca185527&title=&width=1072" alt="image.png"></p><ul><li>如果需要加入很多相同的字符串，使用intern能够很大程度减少内存占用空间。</li></ul><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>不数据Java虚拟机的内存管理，而是属于系统内存。</p><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706235612677-d46dc5e4-7cd5-434b-88c4-ce7d41f4baaa.png#averageHue=%23eeede1&clientId=ue26e552d-4b6b-4&from=paste&height=538&id=u6942394a&originHeight=1076&originWidth=1554&originalType=binary&ratio=2&rotation=0&showTitle=false&size=753507&status=done&style=none&taskId=u01b78b50-534a-4ca1-b6f2-3c9bd05daa4&title=&width=777" alt="image.png"><br>很明显directBuffer用时更短，效率更高。<br>那么为什么呢？后面会讲</p><h3 id="io和directbuffer"><a href="#io和directbuffer" class="headerlink" title="io和directbuffer"></a>io和directbuffer</h3><ul><li>文件读写流程</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706235865500-c5724c71-b197-4feb-a3a4-42d15ed5588b.png#averageHue=%23eae9e5&clientId=ue26e552d-4b6b-4&from=paste&height=583&id=u038a2b19&originHeight=1166&originWidth=1866&originalType=binary&ratio=2&rotation=0&showTitle=false&size=353102&status=done&style=none&taskId=ube228090-155c-49d9-99a6-ff7fff6d756&title=&width=933" alt="image.png"></p><ul><li>使用DirectBuffer</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706235923694-f1d96a0b-1b70-46e3-8a3b-9a7d6f225bbb.png#averageHue=%23ededea&clientId=ue26e552d-4b6b-4&from=paste&height=622&id=ucbeaf507&originHeight=1244&originWidth=2070&originalType=binary&ratio=2&rotation=0&showTitle=false&size=414334&status=done&style=none&taskId=u2be3e637-22ac-4316-957e-db6931f15d8&title=&width=1035" alt="image.png"><br>Java代码可以直接访问。</p><h3 id="直接内存释放"><a href="#直接内存释放" class="headerlink" title="直接内存释放"></a>直接内存释放</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706236547363-6bffad9a-eb9e-44a4-a602-8597e6424207.png#averageHue=%23f7f3e6&clientId=ue26e552d-4b6b-4&from=paste&height=617&id=ufa3892ef&originHeight=1234&originWidth=2748&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1414676&status=done&style=none&taskId=ub05e31e3-fece-4331-986b-7369bad5482&title=&width=1374" alt="image.png"></p><ul><li>直接内存的回收机制总结</li></ul><p>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法。<br>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h1&gt;&lt;h2 id=&quot;程序计数器</summary>
      
    
    
    
    <category term="JVM" scheme="https://axdmdyj.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://axdmdyj.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程-JMM</title>
    <link href="https://axdmdyj.github.io/posts/13a1a5fd.html"/>
    <id>https://axdmdyj.github.io/posts/13a1a5fd.html</id>
    <published>2024-01-15T00:35:54.000Z</published>
    <updated>2024-01-15T00:42:14.839Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="本章内容-："><a href="#本章内容-：" class="headerlink" title="本章内容 ："></a>本章内容 ：</h1><p> Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性<br>这一章进一步深入学习<strong>共享变量</strong>在多线程间的【可见性】问题与多条指令执行时的【有序性】问题 </p><p><strong>JMM</strong> 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的<strong>原子性、可见性</strong>、<strong>有序性</strong>的<strong>规则和保障。</strong></p><h1 id="1、Java-内存模型（JMM）"><a href="#1、Java-内存模型（JMM）" class="headerlink" title="1、Java 内存模型（JMM）"></a>1、Java 内存模型（JMM）</h1><h2 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h2><ol><li>JMM 即 Java Memory Model，从java层面，定义两个抽象概念。</li><li>它定义了<strong>主存（所有线程共享的数据，即共享内存）</strong>、<strong>工作内存（线程私有的数据）</strong>抽象概念。</li><li>为什么要做这个抽象，因为在底层物理上非常复制，如果程序员直接面对底层，那就疯了，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。经过抽象，就可以<strong>用简单的关键字，来控制</strong>是否要缓存？是否要禁止指令优化？ 等等。例如：volatile syn等</li></ol><h2 id="JMM-体现在以下三方面："><a href="#JMM-体现在以下三方面：" class="headerlink" title="JMM 体现在以下三方面："></a>JMM 体现在以下三方面：</h2><p>原子性 - 保证指令<strong>不会受到线程上下文切换</strong>的影响<br>可见性 - 保证指令<strong>不会受 cpu 缓存</strong>的影响<br>有序性 - 保证指令<strong>不会受 cpu 指令并行优化</strong>的影响</p><h1 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h1><h2 id="退出不出的循环："><a href="#退出不出的循环：" class="headerlink" title="退出不出的循环："></a>退出不出的循环：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(run) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;t1 Stop&quot;</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>首先 t1 线程运行，然后过一秒，主线程设置 run 的值为 false，想让 t1 线程停止下来，但是 t1 线程并没有停，分析如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649909440350-247e77c9-f82c-4e22-9a4b-f8c0150d1553.png#averageHue=%23eaea9e&clientId=ud10f7835-6559-4&from=paste&id=u403da049&originHeight=1142&originWidth=1043&originalType=url&ratio=1&rotation=0&showTitle=false&size=501369&status=done&style=none&taskId=u1df38cca-f3e4-4926-960a-6fdf1792c4e&title=" alt="image.png"></p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id="1-syn也可解决可见性问题："><a href="#1-syn也可解决可见性问题：" class="headerlink" title="1. syn也可解决可见性问题："></a>1. syn也可解决可见性问题：</h3><p><strong>在Java内存模型中，synchronized规定， 线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存  →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</strong></p><h3 id="2-使用volitile：推荐"><a href="#2-使用volitile：推荐" class="headerlink" title="2. 使用volitile：推荐"></a>2. 使用volitile：推荐</h3><ul><li>使用 volatile （易变的   关键字）</li><li>它<strong>可以</strong>用来<strong>修饰成员变量和静态成员变量（放在主存中的变量</strong>），<strong>不能</strong>修饰<strong>局部变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作 主存，解决可见性问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用易变关键字</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">while</span> (run) &#123;</span><br><span class="line"><span class="comment">//如果run为真，则一直执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;).start(); </span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;改变run的值为false&quot;</span>);</span><br><span class="line">run = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可见性-vs-原子性："><a href="#可见性-vs-原子性：" class="headerlink" title="可见性 vs 原子性："></a>可见性 vs 原子性：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1703409850730-6c512767-2f6c-4bdf-8d6c-93a58d2f313d.png#averageHue=%23f7f7f7&clientId=u714f9d90-acae-4&from=paste&height=664&id=uec0d832a&originHeight=1328&originWidth=1988&originalType=binary&ratio=2&rotation=0&showTitle=false&size=612873&status=done&style=none&taskId=u641ce794-2848-4f94-bd7b-f8b76d26535&title=&width=994" alt="image.png"><br>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</li><li>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</li><li>如果在前面示例的<strong>死循环中加入 System.out.println() <strong>会发现</strong>即使不加 volatile 修饰符</strong>，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？ 等烟的示例 为啥没有出现可见性问题?和synchrozized是一个道理。</li></ul><h3 id="因为-println-使用syn关键字："><a href="#因为-println-使用syn关键字：" class="headerlink" title="因为 println() 使用syn关键字："></a>因为 println() 使用syn关键字：</h3><p><strong>在Java内存模型中，synchronized规定，线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line"><span class="comment">//使用了synchronized关键字</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>[</p><p>](<a href="https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN">https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN</a>)</p><h2 id="两阶终止模式之-volatile-优化："><a href="#两阶终止模式之-volatile-优化：" class="headerlink" title="两阶终止模式之 volatile 优化："></a>两阶终止模式之 volatile 优化：</h2><h3 id="对-interrupt-回顾："><a href="#对-interrupt-回顾：" class="headerlink" title="对 interrupt() 回顾："></a>对 interrupt() 回顾：</h3><p><a href="https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN">https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN</a></p><h3 id="利用停止标志-优化："><a href="#利用停止标志-优化：" class="headerlink" title="利用停止标志 优化："></a>利用停止标志 优化：</h3><p>之前的 interrupt() ，需要重新设置打断标记为真，很容易遗漏。<br>现在使用 volatile 关键字来实现两阶段终止模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">Monitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monitor</span>();</span><br><span class="line">monitor.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">monitor.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span></span><br><span class="line"><span class="comment">// 我们的例子中，即主线程把它修改为 true 对  子线程可见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread monitor;</span><br><span class="line"><span class="comment">//设置停止标志，用于判断是否被终止了。必须为volatile，因为一个线程启动监控，另外一个线程暂停监控，相当于一个线程读，一个线程写，写的操作要被读线程感知，所以必须为volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//设置线控器线程，用于监控线程状态</span></span><br><span class="line">monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//开始不停的监控</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(stop) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//线程休眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">System.out.println(<span class="string">&quot;被打断了&quot;</span>); <span class="comment">//不需要重新设置打断标记，因为优化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">monitor.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于停止监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//打断线程，就是当监控线程在sleep时，那也会被立刻终止</span></span><br><span class="line">monitor.interrupt();</span><br><span class="line">        <span class="comment">//修改标记</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步模式之-犹豫模式："><a href="#同步模式之-犹豫模式：" class="headerlink" title="同步模式之 犹豫模式："></a>同步模式之 犹豫模式：</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>Balking （犹豫）模式：用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p><h3 id="前面volatile优化存在的问题："><a href="#前面volatile优化存在的问题：" class="headerlink" title="前面volatile优化存在的问题："></a>前面volatile优化存在的问题：</h3><ul><li>若多次调用 start() ，监控程序会有多个，没有意义。</li><li>需要解决的问题是，某个方法只被执行一次，下次执行的时候直接返回，不要往下执行，这就是犹豫模式</li><li>防止反射破坏单例时候，也是这套路。</li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><ul><li>用一个标志来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题，若两个线程同时执行到 if(starting) ，那就会有线程安全问题，需要加锁处理。此时，volitile 不能解决问题，因为不能保证原子性<ul><li>并且，加锁的代码块要尽量的小，以保证性能。</li><li>双重检查锁更好，在外面加个if，可以减少频繁获取锁的情况</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">Monitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monitor</span>();</span><br><span class="line">monitor.start();</span><br><span class="line">monitor.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">monitor.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread monitor;</span><br><span class="line"><span class="comment">//设置标记，用于判断是否被终止了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//设置标记，用于判断是否已经启动过了</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//双重检查锁</span></span><br><span class="line"><span class="keyword">if</span>(!starting)&#123;</span><br><span class="line">            <span class="comment">//上锁，避免多线程运行时出现线程安全问题</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                    <span class="comment">//已被启动，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次启动监视器，改变标记</span></span><br><span class="line">                starting = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//设置线控器线程，用于监控线程状态</span></span><br><span class="line">monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//开始不停的监控</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(stop) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//线程休眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;被打断了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">monitor.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于停止监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//打断线程</span></span><br><span class="line">monitor.interrupt();</span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="犹豫模式-应用："><a href="#犹豫模式-应用：" class="headerlink" title="犹豫模式 应用："></a>犹豫模式 应用：</h3><p><strong>保证监控线程只启动一次</strong></p><h4 id="对于以下Tomcat监控线程："><a href="#对于以下Tomcat监控线程：" class="headerlink" title="对于以下Tomcat监控线程："></a>对于以下Tomcat监控线程：</h4><ul><li>监控线程停止时，设 starting 为false ，此时 starting 变量没有在同步代码块内，不能保证可见性，所以也加 volatile 关键字</li><li>如果不保证可见性那么下一次点击 开始 按钮tomcat运行同步代码块里的staring还是true，就不能启动监控线程了</li><li>那为什么不用syn？因为用syn性能消耗大，使用 volatile 轻量级的保证可见性即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.monitor.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.monitor.controller.MonitorController;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.monitor.vo.Info;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yihang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> stop;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> starting;</span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 双重检查锁</span></span><br><span class="line">        <span class="keyword">if</span>(!starting)&#123;</span><br><span class="line">            <span class="comment">// 缩小同步范围，提升性能</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;该监控线程已启动?(&#123;&#125;)&quot;</span>, starting);</span><br><span class="line">                <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                starting = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于之前的 balking 模式，以下代码只可能被一个线程执行，因此无需互斥</span></span><br><span class="line">        monitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                report();</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里的监控线程只可能启动一个，因此只需要用 volatile 保证 starting 的可见性</span></span><br><span class="line">            log.info(<span class="string">&quot;监控线程已停止...&quot;</span>);</span><br><span class="line">            starting = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        stop = <span class="literal">false</span>;</span><br><span class="line">        log.info(<span class="string">&quot;监控线程已启动...&quot;</span>);</span><br><span class="line">        monitorThread.start(); <span class="comment">//启动监控线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">report</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Info</span>();</span><br><span class="line">        info.setTotal(Runtime.getRuntime().totalMemory());</span><br><span class="line">        info.setFree(Runtime.getRuntime().freeMemory());</span><br><span class="line">        info.setMax(Runtime.getRuntime().maxMemory());</span><br><span class="line">        info.setTime(System.currentTimeMillis());</span><br><span class="line">        MonitorController.QUEUE.offer(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> seconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 不加打断需要等到下一次 sleep 结束才能退出循环，这里是为了更快结束</span></span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现线程安全的单例："><a href="#实现线程安全的单例：" class="headerlink" title="实现线程安全的单例："></a>实现线程安全的单例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//优化</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h1><h2 id="3-1-指令重排："><a href="#3-1-指令重排：" class="headerlink" title="3.1 指令重排："></a>3.1 指令重排：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1703465371216-28d49e05-c15d-45af-81b4-a7eeebfae9e5.png#averageHue=%23f7f6f4&clientId=ue31d7846-9f43-4&from=paste&height=334&id=u2ae422e1&originHeight=668&originWidth=2240&originalType=binary&ratio=2&rotation=0&showTitle=false&size=579732&status=done&style=none&taskId=u7714e233-09b2-4cd0-b9c9-c2c9d8e29ed&title=&width=1120" alt="image.png"></p><ul><li>JVM 会在<strong>不影响结果正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序，</strong>这种特性称之为『<strong>指令重排</strong>』</li><li>但是在<strong>多线程下『指令重排』会影响正确性。</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649924182419-4b9e3d2e-2907-45b6-8bb9-8ad285b2130e.png#averageHue=%23f7f7f6&clientId=ud10f7835-6559-4&from=paste&id=ud4bd176e&originHeight=586&originWidth=1039&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1ee2594c-eef6-4b2a-91af-a67373d196d&title="></p><h2 id="3-2-那为什么要有-指令重排-优化呢？"><a href="#3-2-那为什么要有-指令重排-优化呢？" class="headerlink" title="3.2 那为什么要有 指令重排 优化呢？"></a>3.2 那为什么要有 指令重排 优化呢？</h2><p>从cpu角度，看 CPU执行指令 的原理来理解一下</p><h3 id="指令重排序优化："><a href="#指令重排序优化：" class="headerlink" title="指令重排序优化："></a>指令重排序优化：</h3><ul><li>现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649926023127-7b8a2fb9-0a75-40d3-b36e-da46caa3dc92.png#averageHue=%23f5f5f5&clientId=ud10f7835-6559-4&from=paste&id=u378d7b24&originHeight=225&originWidth=1145&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u221ed5c8-e766-4ad6-a18c-c759b9aaa32&title="><br>现代 CPU 支持<strong>多级指令流水线</strong>，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为<strong>五级指令流水线</strong>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC &#x3D; 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。<br> <img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649934793764-970b1769-f240-4f1a-82d1-11efd67976a7.png#averageHue=%23f2f2f2&clientId=ud10f7835-6559-4&from=paste&height=291&id=u57f92fc0&originHeight=327&originWidth=1057&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38744&status=done&style=none&taskId=uc37d119c-e9ca-44ee-8944-39215c15db0&title=&width=939.5555555555555" alt="image.png"></p><ul><li>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行,提高并发度</strong></li><li>流水线有时候会因为指令间的依赖关系被阻塞，重排可以减少阻塞</li><li>指令重排的<strong>前提</strong>是，重排指令<strong>不能影响结果</strong>，例如</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以重排的例子 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>; </span><br><span class="line">System.out.println( a + b );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能重排的例子 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a - <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="3-3-多线程下指令重排问题："><a href="#3-3-多线程下指令重排问题：" class="headerlink" title="3.3 多线程下指令重排问题："></a>3.3 多线程下指令重排问题：</h2><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="首先看一段代码："><a href="#首先看一段代码：" class="headerlink" title="首先看一段代码："></a>首先看一段代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在多线程环境下，以上的代码-r1-的值有三种情况："><a href="#在多线程环境下，以上的代码-r1-的值有三种情况：" class="headerlink" title="在多线程环境下，以上的代码 r1 的值有三种情况："></a>在多线程环境下，以上的代码 r1 的值有三种情况：</h3><p>第一种：线程 2 先执行，然后线程 1 后执行，r1 的结果为 4；<br>第二种：线程 1 先执行，然后线程 2 后执行，r1 的结果为 1；<br>第三种：线程 2 先执行，但是发送了指令重排，num &#x3D; 2 与 ready &#x3D; true 这两行代码语序发生装换，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ready = <span class="literal">true</span>; <span class="comment">// 前</span></span><br><span class="line">num = <span class="number">2</span>; <span class="comment">// 后</span></span><br></pre></td></tr></table></figure><p>然后执行 ready &#x3D; true 后，线程 1 运行了，那么 r1 的结果是为 0。<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1703466012493-c87d1923-8917-4ab1-b1b4-d17b2726dac1.png#averageHue=%23fdfdfd&clientId=uf81aeecb-5d94-4&from=paste&height=376&id=u5e4903d9&originHeight=752&originWidth=2656&originalType=binary&ratio=2&rotation=0&showTitle=false&size=341401&status=done&style=none&taskId=u4ad2738f-07e0-4639-b082-f6690553e7b&title=&width=1328" alt="image.png"></p><h2 id="3-4-解决方法："><a href="#3-4-解决方法：" class="headerlink" title="3.4 解决方法："></a>3.4 解决方法：</h2><p>volatile 修饰的变量，可以<strong>禁用指令重排</strong>，<strong>禁止</strong>的是 加 volatile 关键字的变量 <strong>之前的代码进行</strong>重排序<br>这里也就是ready之前的代码禁止重排序</p><h2 id="3-5-volatile-原理："><a href="#3-5-volatile-原理：" class="headerlink" title="3.5 volatile 原理："></a>3.5 volatile 原理：</h2><p><strong>volatile可以保证 共享变量的可见性、有序性，底层如何实现？</strong><br>答：volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后  会加入写屏障</li><li>对 volatile 变量的读指令前  会加入读屏障</li></ul><h3 id="先看一下内存屏障："><a href="#先看一下内存屏障：" class="headerlink" title="先看一下内存屏障："></a>先看一下内存屏障：</h3><ul><li>可见性<ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中</li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后的</strong>，对共享变量的读取，加载的是主存中的最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul></li></ul><h3 id="如何保证可见性："><a href="#如何保证可见性：" class="headerlink" title="如何保证可见性："></a>如何保证可见性：</h3><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936015305-62534166-2f53-470e-a096-cfdaa7ffb4c8.png#averageHue=%23f4f3f1&clientId=u2908829a-b6ac-4&from=paste&id=ua99e1cbf&originHeight=343&originWidth=1157&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc0ae16b0-4252-4fb5-9326-11d760cb91d&title="></p><ul><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中的最新数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936027298-cdd29306-6019-4fda-a99a-0a65e9efd74c.png#averageHue=%23f8efa9&clientId=u2908829a-b6ac-4&from=paste&id=u18500d7d&originHeight=716&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7a1b9dd7-d32a-42a7-bb17-10b5ce40706&title="></p><h3 id="如何保证有序性："><a href="#如何保证有序性：" class="headerlink" title="如何保证有序性："></a>如何保证有序性：</h3><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936043737-e0f7a843-afc6-42d6-a4df-48923dc4b291.png#averageHue=%23f4f3f1&clientId=u2908829a-b6ac-4&from=paste&id=u53639ad9&originHeight=233&originWidth=760&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3223ba4b-068a-465b-a7e3-511ab611186&title="></p><ul><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936055748-fc78c467-778f-469a-ba71-43b1475ed191.png#averageHue=%23f5f4f3&clientId=u2908829a-b6ac-4&from=paste&id=uf680dff8&originHeight=380&originWidth=659&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubf0964af-09aa-4dbd-af37-0deb5bf5f35&title="><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936066371-31aea7ce-e5ae-404d-9d29-02c4d0a859df.png#averageHue=%23f8efa9&clientId=u2908829a-b6ac-4&from=paste&id=u818c4e63&originHeight=701&originWidth=1201&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8dcc9f71-b00b-4f7e-8e7c-f8ad5e5a04b&title="></p><h4 id="只保证了本线程的有序性，线程间的交错无法保证："><a href="#只保证了本线程的有序性，线程间的交错无法保证：" class="headerlink" title="只保证了本线程的有序性，线程间的交错无法保证："></a>只保证了本线程的有序性，线程间的交错无法保证：</h4><ul><li>jvm 无法控制线程调度，即线程上下文切换。是由cpu的时间片决定的，A线程的时间片用完了，切换到B线程，在线程间的代码就会交错执行</li><li>而有序性的保证也<strong>只是保证了本线程内</strong>相关代码不被重排序</li></ul><h3 id="不能解决指令交错问题：原子性"><a href="#不能解决指令交错问题：原子性" class="headerlink" title="不能解决指令交错问题：原子性"></a>不能解决指令交错问题：原子性</h3><ul><li>即不能保证原子性。写屏障仅仅是保证<strong>之后的读能够读到新的结果</strong>，但<strong>不能保证另外线程的读跑到它前面去，进而不能解决线程安全问题</strong></li></ul><h2 id="syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。"><a href="#syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。" class="headerlink" title="syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。"></a>syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。</h2><h2 id="3-6-double-checked-locking-问题"><a href="#3-6-double-checked-locking-问题" class="headerlink" title="3.6 double-checked locking 问题:"></a>3.6 double-checked locking 问题:</h2><h3 id="最初代码："><a href="#最初代码：" class="headerlink" title="最初代码："></a>最初代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最开始的单例模式是这样的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 首次访问会同步，而之后的使用可以不用进入synchronized，减少性能损耗</span></span><br><span class="line">       <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">       <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">       INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">           <span class="keyword">return</span> INSTANCE;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h4><p>上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响性能！因此就有了模式如下double-checked locking：</p><h3 id="改进1："><a href="#改进1：" class="headerlink" title="改进1："></a>改进1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h4><p>懒惰实例化<br>首次使用 getInstance() 才使用 synchron ized 加锁，后续使用时无需加锁。里面的if是为了防止前面的线程重复创建对象，而外面的if是为了后面的线程重复加锁,损耗性能<br><strong>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外，</strong>不能享有synchronized保证的原子性，可见性、有序性，可能会由于syn代码块中 new 过程 产生指令重排 导致获取到一个半成品对象。</p><h3 id="getInstance-方法对应的字节码为："><a href="#getInstance-方法对应的字节码为：" class="headerlink" title="getInstance 方法对应的字节码为："></a>getInstance 方法对应的字节码为：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="comment">// ldc是获得类对象</span></span><br><span class="line"><span class="number">6</span>: ldc #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span></span><br><span class="line"><span class="comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span></span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line"><span class="number">11</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="comment">// 新建一个实例</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span> #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="comment">// 复制了一个实例的引用</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="comment">// 通过这个复制的引用调用它的构造方法</span></span><br><span class="line"><span class="number">21</span>: invokespecial #<span class="number">4</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="comment">// 最开始的这个引用用来进行赋值操作</span></span><br><span class="line"><span class="number">24</span>: putstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ul><li>17 表示创建对象，将对象引用入栈 &#x2F;&#x2F; new Singleton</li><li>20 表示复制一份对象引用 &#x2F;&#x2F; 复制了引用地址到栈中</li><li>21 表示利用一个对象引用，调用构造方法 &#x2F;&#x2F; 根据复制的引用地址调用 构造方法()</li><li>24 表示利用一个对象引用，**赋值给 static INSTANCE **</li></ul><h4 id="多线程环境下，是有问题的："><a href="#多线程环境下，是有问题的：" class="headerlink" title="多线程环境下，是有问题的："></a>多线程环境下，是有问题的：</h4><p>也许 jvm 会优化为：在syn代码块中发生 指令重排，先执行 24，再执行 21。   **  **<br><strong>并且 两个线程 t1，t2  按如下时间序列执行：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649940127913-311c97d3-1655-44fb-b66f-b419e9f0b69e.png#averageHue=%23fafafa&clientId=u2908829a-b6ac-4&from=paste&id=uc746b838&originHeight=820&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&size=141258&status=done&style=none&taskId=ud3ea8fec-dadf-4267-b6fa-66d071b4e0f&title=" alt="image.png"></p><h3 id="最终解决方案："><a href="#最终解决方案：" class="headerlink" title="最终解决方案："></a>最终解决方案：</h3><ol><li>关键在于** 0: getstatic <strong>这行字节码 在 monitor 控制之外，它就像之前举例中不守规则的人，</strong>可以越过 monitor 读取 INSTANCE 变量的值**</li><li>这时 t1 <strong>还未完全将构造方法执行完毕</strong>，如果在构造方法中要执行很多初始化操作，那么 **t2 <strong>拿到的是将是一个</strong>未初始化完毕的单例 **</li><li>对 INSTANCE 使用 volatile 修饰即可，<strong>volatile可以禁用指令重排</strong>，底层是内存屏障。但要注意在 JDK 5 以上的版本的 volatile 才会真正有效。</li></ol><h4 id="代码：加volatile就行了"><a href="#代码：加volatile就行了" class="headerlink" title="代码：加volatile就行了"></a>代码：加volatile就行了</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">//可以在构造方法里面加个判断，如果INSTANCE != null，就抛个异常。因为反射可以拿到私有的构造方法，从而创建对象。</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">           <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">                   <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                   <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                       INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> INSTANCE;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="字节码上看不出来-volatile-指令的效果："><a href="#字节码上看不出来-volatile-指令的效果：" class="headerlink" title="字节码上看不出来 volatile 指令的效果："></a>字节码上看不出来 volatile 指令的效果：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span></span><br><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="number">6</span>: ldc #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性</span><br><span class="line"><span class="number">11</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span> #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial #<span class="number">4</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">24</span>: putstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><h5 id="从底层内存屏障分析："><a href="#从底层内存屏障分析：" class="headerlink" title="从底层内存屏障分析："></a>从底层内存屏障分析：</h5><p>如上面的注释内容所示，读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入内存屏障（Memory Barrier（Memory Fence）），<strong>保证下面两点：</strong></p><ol><li>可见性<ol><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ol></li><li><strong>有序性</strong><ol><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ol></li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649943204849-2a5ee5b4-f5fe-430d-b2ce-5e12249fe9c9.png#averageHue=%23fafafa&clientId=u2908829a-b6ac-4&from=paste&height=783&id=u6bc6a86a&originHeight=881&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132190&status=done&style=none&taskId=udeada633-0be2-428d-94b2-3ac559e8e79&title=&width=837.3333333333334" alt="image.png"></p><h5 id="volatile是保证线程内指令禁用重排序，管不到线程间："><a href="#volatile是保证线程内指令禁用重排序，管不到线程间：" class="headerlink" title="volatile是保证线程内指令禁用重排序，管不到线程间："></a>volatile是保证线程内指令禁用重排序，管不到线程间：</h5><p>就算cpu这样子调度，也是ok的，此时t2线程if（&#x3D;&#x3D;null） 判断成功<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649942964600-1a29b3dc-4b1f-4640-9488-3ec0cac0104d.png#averageHue=%23f8f8f8&clientId=u2908829a-b6ac-4&from=paste&height=757&id=u0c86551f&originHeight=852&originWidth=908&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138939&status=done&style=none&taskId=u040aa0d6-d72a-4788-a3e2-fca26a85a7c&title=&width=807.1111111111111" alt="image.png"></p><h1 id="4、happens-before："><a href="#4、happens-before：" class="headerlink" title="4、happens-before："></a>4、happens-before：</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>happens-before 规定了对共享变量的<strong>写操作</strong>对其它线程的<strong>读操作</strong>可见，它是可见性与有序性的<strong>一套规则总结</strong>。抛开以下 happens-before 规则，JM </p><h2 id="几种规则："><a href="#几种规则：" class="headerlink" title="几种规则："></a>几种规则：</h2><p>下面说的变量都是指成员变量或静态成员变量，即共享变量<br>① 线程A 解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程B 对该变量的读可见<br>因为 线程A 解锁前将x变量的值保存到了主内存，在释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">           x = <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">           System.out.println(x);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>② 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见<br>volatile 保证写入操作是写入主存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>③ 线程 start 前对变量的写，对该线程开始后对该变量的读可见<br>这是启动线程前将工作内存保存到了主内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>④ 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><p>⑤ 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                   System.out.println(x);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">       t2.start();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           sleep(<span class="number">1</span>);</span><br><span class="line">           x = <span class="number">10</span>;</span><br><span class="line">           t2.interrupt();</span><br><span class="line">       &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">       <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">           Thread.<span class="keyword">yield</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>⑥ 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见<br>⑦ 具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子<br>写屏障之上的代码对共享变量的改动都同步到主存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">     y = <span class="number">10</span>;</span><br><span class="line">     x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line"> &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h1 id="volatile总结："><a href="#volatile总结：" class="headerlink" title="volatile总结："></a>volatile总结：</h1><p>volatile<strong>主要用在</strong>一个线程写 多个线程读 时的来保证可见性，和double-checked locking模式中保证synchronized代码块外的共享变量的重排序问题。</p><h1 id="5、练习："><a href="#5、练习：" class="headerlink" title="5、练习："></a>5、练习：</h1><h2 id="1）balking-模式习题："><a href="#1）balking-模式习题：" class="headerlink" title="1）balking 模式习题："></a>1）balking 模式习题：</h2><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？<br>volatile 无法保证原子性，多线程下肯定要加synchronized<br>volatile 可以保存线程的可见性，有序性，但是不能保证原子性，doInit 方法没加锁，可能会被调用多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        doInit();</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2）线程安全单例习题"><a href="#2）线程安全单例习题" class="headerlink" title="2）线程安全单例习题:"></a>2）线程安全单例习题:</h2><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试着分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建<ul><li>饿汉式依靠类加载时的clinit静态初始化时执行，保证了线程安全，对内存不友好，类准备阶段直接赋值</li></ul></li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li></ul><h3 id="实现1：饿汉式"><a href="#实现1：饿汉式" class="headerlink" title="实现1：饿汉式"></a>实现1：饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final? 防止子类继承这个单例类 然后重写方法</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例?  进行反序列化的时候会生成新的对象，就破坏单例了。要解决直接加上readResolve()方法就行了，如下所示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有? 防止其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?可以，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性。clinit方法，线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</span></span><br><span class="line">    <span class="comment">//1.提供更好的封装性，可以进行懒惰的初始化；  2.提供范型的支持</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法名是：readResolve()，是为了防止类在反序列化的时候创建对象。</span></span><br><span class="line">    <span class="comment">//当用反序列化创建对象时，会调用readResovle()，因此我们直接给它重写，让它返回我们创建的对象就行了。</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现2：枚举类-饿汉式"><a href="#实现2：枚举类-饿汉式" class="headerlink" title="实现2：枚举类-饿汉式"></a>实现2：枚举类-饿汉式<img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649985872537-ac83cb76-b326-4fd2-ba85-4467753f110b.png#averageHue=%23faf5f2&clientId=uc3c01388-aa91-4&from=paste&height=610&id=u5a706353&originHeight=686&originWidth=1337&originalType=binary&ratio=1&rotation=0&showTitle=false&size=322387&status=done&style=none&taskId=ub599bb76-9739-468f-8472-d6ffdd76fba&title=&width=1188.4444444444443" alt="image.png"></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的？</span></span><br><span class="line">    创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量</span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题？</span></span><br><span class="line">    没有，这是静态成员变量，在类加载阶段创建，JVM保证线程安全</span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例？</span></span><br><span class="line">    不能，枚举类型不能通过newInstance反射，Class#newInstance()方法会判断是否是枚举类，如果是   会抛出异常</span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例？</span></span><br><span class="line">    枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例</span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式？</span></span><br><span class="line">    饿汉式，类加载时就创建了</span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？</span></span><br><span class="line">    加构造方法就行了</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现3：懒汉式"><a href="#实现3：懒汉式" class="headerlink" title="实现3：懒汉式"></a>实现3：懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点？</span></span><br><span class="line">    <span class="keyword">synchronized</span>加在静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次访问都会加锁，性能   比较低。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现4：DCL-懒汉式"><a href="#实现4：DCL-懒汉式" class="headerlink" title="实现4：DCL 懒汉式"></a>实现4：DCL 懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile ?</span></span><br><span class="line">        为了防止重排序问题，保证拿到的对象是完整无缺的</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率，不用每次都加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？</span></span><br><span class="line">            <span class="comment">//    这是为了防止第一次判断时的并发问题。</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现5：静态内部类-懒汉式"><a href="#实现5：静态内部类-懒汉式" class="headerlink" title="实现5：静态内部类-懒汉式"></a>实现5：静态内部类-懒汉式</h3><p>静态内部类是在使用的时候才完成类加载，不会因为外部类的加载而加载。此例是调用getInstance() 方法才完成静态内部类的 类加载<br>这是 静态内部类 和 静态代码块、静态变量 的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式？</span></span><br><span class="line">    懒汉式，这是一个静态内部类，是在使用的时候才完成类加载，不会因为外部类的加载而加载。在没有 调用getInstance方法时，是不会执行LazyHolder内部类的类加载操作的。</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题？</span></span><br><span class="line">        这是线程安全的，类加载时，jvm保证类加载操作的线程安全</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、结论："><a href="#6、结论：" class="headerlink" title="6、结论："></a>6、结论：</h1><p>本章重点讲解了 JMM 中的</p><ol><li>可见性 - 由 JVM 缓存优化引起</li><li>有序性 - 由 JVM 指令重排序优化引起</li><li>happens-before 规则 七条</li><li>原理方面<ol><li>CPU指令级别并行</li><li>volatile -&gt; 内存屏障</li></ol></li><li>模式方面<ol><li>两阶段终止模式的  volatile 改进</li><li>同步模式之 balking(犹豫模式)  –&gt; 保证某段代码只执行一次</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;本章内容-：&quot;&gt;&lt;a href=&quot;#本章内容-：&quot; class=&quot;headerlink&quot; title=&quot;本章内容 ：&quot;&gt;&lt;/a&gt;本章内容 ：&lt;/h1&gt;&lt;p&gt; Monit</summary>
      
    
    
    
    <category term="JUC并发编程" scheme="https://axdmdyj.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC" scheme="https://axdmdyj.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（1）</title>
    <link href="https://axdmdyj.github.io/posts/cc7ca809.html"/>
    <id>https://axdmdyj.github.io/posts/cc7ca809.html</id>
    <published>2023-12-22T16:54:02.000Z</published>
    <updated>2024-01-15T00:42:04.021Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p><strong>常见题型:</strong></p><ul><li>背包问题</li><li>打家劫舍</li><li>股票问题</li><li>子序列问题</li></ul><p>态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，<br>动态规划中dp[j]是由<code>dp[j-weight[i]]</code>推导出来的，然后取<code>max(dp[j], dp[j - weight[i]] + value[i])</code>。<br>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。<br><strong>解题步骤</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p><strong>如何debug</strong><br>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！<br>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</p><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>题目链接: <a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><h2 id="动态规划五部曲"><a href="#动态规划五部曲" class="headerlink" title="动态规划五部曲"></a>动态规划五部曲</h2><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>入门题原因:  递推公式已经给了:** **dp[i] &#x3D; dp[i - 1] + dp[i - 2];</p><ol start="3"><li>dp数组初始化</li></ol><p>题目给了: dp[0] &#x3D; 0; dp[1] &#x3D; 1;</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2]，推导一下，当N为10的时候，dp数组应该是如下的数列：<br>0 1 1 2 3 5 8 13 21 34 55</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><p>题目链接:<br><a href="https://leetcode.cn/problems/climbing-stairs/description/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p><h2 id="DP五部曲"><a href="#DP五部曲" class="headerlink" title="DP五部曲"></a>DP五部曲</h2><ul><li><ol><li>确定dp数组以及下标定义</li></ol></li></ul><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p><ul><li><ol start="2"><li>确定递推公式</li></ol></li></ul><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。<br>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。<br>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！<br>所以**dp[i] &#x3D; dp[i - 1] + dp[i - 2] **。<br>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。<br>这体现出确定dp数组以及下标的含义的重要性！</p><ul><li><ol start="3"><li>dp数组如何初始化</li></ol></li></ul><p>题目说了, n是一个正整数<br>不考虑dp[0]如何初始化，只初始化dp[1] &#x3D; 1，dp[2] &#x3D; 2，然后从i &#x3D; 3开始递推，这样才符合dp[i]的定义。</p><ul><li><ol start="4"><li>确定遍历顺序</li></ol></li></ul><p>从递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><ul><li><ol start="5"><li>推到dp数组</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697472840603-278be474-e26a-42bf-9b0e-e7f7df782d25.png#averageHue=%23f2f2f2&clientId=u35be678d-fe85-4&from=paste&height=384&id=u4b3a3af1&originHeight=384&originWidth=814&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26258&status=done&style=none&taskId=u507c4ece-7908-43fb-b8b9-d0cffdc4b53&title=&width=814" alt="image.png"><br>这不就是斐波那契嘛</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">2</span>] + dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>看不懂就先看动态视频的演示，注意max的含义。<br>【【算法演示】动态规划求解最长公共子序列】<br><a href="https://www.bilibili.com/video/BV1PA411w7CW?vd_source=fcae3ca58a4c2446a58b5aaacbaa4bbe">【算法演示】动态规划求解最长公共子序列_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理论基础&quot; class=&quot;headerlink&quot; title=&quot;理论基础&quot;&gt;&lt;/a&gt;理论基础&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;常见题型:&lt;</summary>
      
    
    
    
    
    <category term="动态规划" scheme="https://axdmdyj.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>redis实战篇</title>
    <link href="https://axdmdyj.github.io/posts/6bd5204f.html"/>
    <id>https://axdmdyj.github.io/posts/6bd5204f.html</id>
    <published>2023-11-20T11:17:34.000Z</published>
    <updated>2023-11-20T11:42:25.332Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h1><h2 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698801356928-1038c401-76d3-4029-9ade-1af6e5c0280f.png#averageHue=%23e9e9e6&clientId=u023eb198-87b4-4&from=paste&height=538&id=u539f0ea2&originHeight=673&originWidth=300&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=94508&status=done&style=none&taskId=ub2bffcf8-da03-4137-8da5-73895a1347d&title=&width=240" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 检验手机号码是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号码无效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 保存到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送验证码成功, 验证码是:&#123;&#125;&quot;</span>, code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 返回成功</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698801410162-5c8e46f4-74f7-42f6-8895-eef95eed91e9.png#averageHue=%23fcf6f5&clientId=u023eb198-87b4-4&from=paste&height=474&id=ufa498d0e&originHeight=593&originWidth=1366&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58225&status=done&style=none&taskId=u603ec55b-759d-49f3-8cbb-8911b4f3cac&title=&width=1092.8" alt="image.png"><br>将生成的验证码根据key-value的形式存入redis</p><blockquote><p>这里有一个小细节：<br><strong>这里虽然后端配置的端口时8081，但这里的请求仍然时8080，是因为前端使用nginx，反向代理，请求先发送到了nginx服务，然后反向代理再去请求tomcat服务器</strong></p></blockquote><p>补充：</p><blockquote><p>@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。<br>@Autowired只根据type进行注入，不会去匹配name</p></blockquote><h2 id="短信验证码登录和注册"><a href="#短信验证码登录和注册" class="headerlink" title="短信验证码登录和注册"></a>短信验证码登录和注册</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825277887-0fd5dc23-0660-4ee6-b1dc-3bc7caa0ae8e.png#averageHue=%23eeeaea&clientId=u8fd209ed-60a0-4&from=paste&height=500&id=u90d93351&originHeight=500&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61551&status=done&style=none&taskId=ub8f396b4-717d-45a7-94b3-93c30f8ce35&title=&width=400" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">       <span class="comment">// 检验手机格式</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">       <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2. 校验验证码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">       <span class="keyword">if</span> (code==<span class="literal">null</span>  || !code.equals(session.getAttribute(<span class="string">&quot;code&quot;</span>)))&#123;</span><br><span class="line">           <span class="comment">// 3. 校验验证码失败</span></span><br><span class="line">           Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3. 根据手机号查询用户</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span>  query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">       <span class="comment">// 用户不存在</span></span><br><span class="line">       <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">          user =  createUserWithPhone(phone);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4. 用户存在, 保存到session中</span></span><br><span class="line">       session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825445004-a6016290-a7e2-4fe7-9ad2-5baf4d03322f.png#averageHue=%23f5f4f4&clientId=u8fd209ed-60a0-4&from=paste&height=936&id=ubc9ca8c3&originHeight=936&originWidth=2111&originalType=binary&ratio=1&rotation=0&showTitle=false&size=390396&status=done&style=none&taskId=u281196a9-354a-4025-af73-c4739038dc8&title=&width=2111" alt="image.png"><br>这么做有问题, 当Controller层多的时候, 这样的业务逻辑就都得重写,<br>&#x3D;&gt; 可以加一个拦截器来解决<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825629609-6369cd15-7ea9-4cdf-ba2c-80283907b44e.png#averageHue=%23f2ebea&clientId=u8fd209ed-60a0-4&from=paste&height=785&id=uc48a18cc&originHeight=981&originWidth=2229&originalType=binary&ratio=1&rotation=0&showTitle=false&size=299850&status=done&style=none&taskId=u74fe0f76-4930-4709-9978-758d1c82770&title=&width=1783.2" alt="image.png"><br>每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.User;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">          response.setStatus(<span class="number">401</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        UserHolder.saveUser((UserDTO) user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span>  <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意隐藏信息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698828563629-a0f2d4c2-f931-4571-995d-dca9ebd7cd72.png#averageHue=%232c2b2b&clientId=u8fd209ed-60a0-4&from=paste&height=192&id=u967c724b&originHeight=192&originWidth=1256&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22166&status=done&style=none&taskId=u27b2f1ae-fd8f-4669-bf8c-0d819eefc48&title=&width=1256" alt="image.png"></p><blockquote><p>注意BeanUtil和BeanUtils区别</p></blockquote><p>使用ThreadLocal</p><blockquote><p><strong>ThreadLocal</strong>：为每个线程提供一份单独存储空间，只有在线程内才能获取对应的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.UserDTO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO userId)</span>&#123;</span><br><span class="line">        tl.set(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698828260112-414e2510-ddfd-49e5-984f-097b13fee144.png#averageHue=%23fcfaf9&clientId=u8fd209ed-60a0-4&from=paste&height=667&id=u63ffab52&originHeight=667&originWidth=375&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34061&status=done&style=none&taskId=udb64cb68-f96c-40d8-9d43-adfa17565b0&title=&width=375" alt="image.png"></p><h2 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h2><p>多台tomcat服务器之间并不共享数据, 容易造成切换服务器数据丢失的问题<br>session的替代方案应满足:</p><ul><li>数据共享</li><li>内存存储</li><li>key value结构</li></ul><p>解决办法 &#x3D;&gt; redis</p><h2 id="基于redis实现session共享登录"><a href="#基于redis实现session共享登录" class="headerlink" title="基于redis实现session共享登录"></a>基于redis实现session共享登录</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698829850748-a6352f14-367c-419a-abb1-32da0047725d.png#averageHue=%23c5918e&clientId=u8fd209ed-60a0-4&from=paste&height=1053&id=ueaf61fbb&originHeight=1053&originWidth=1799&originalType=binary&ratio=1&rotation=0&showTitle=false&size=391683&status=done&style=none&taskId=ue0eea36f-38a4-41fc-9fd2-1f329f33447&title=&width=1799" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698846050148-bff23449-9187-4ead-8533-d7f57e910afd.png#averageHue=%23efeae9&clientId=u5a170d56-888a-4&from=paste&height=1108&id=u1c766697&originHeight=1108&originWidth=2089&originalType=binary&ratio=1&rotation=0&showTitle=false&size=496399&status=done&style=none&taskId=u9056657b-38a3-48ca-8a27-07f62fd1dcb&title=&width=2089" alt="image.png"></p><h2 id="基于redis实现短信登录"><a href="#基于redis实现短信登录" class="headerlink" title="基于redis实现短信登录"></a>基于redis实现短信登录</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699027861571-80106832-60b3-4bee-a610-0de8c9ccd0b1.png#averageHue=%23ece6e6&clientId=uc77679ca-2224-4&from=paste&height=751&id=u5e8e06ac&originHeight=939&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=208747&status=done&style=none&taskId=u69fc68a2-4a66-4abc-ba34-971cb892e11&title=&width=504" alt="image.png"><br>先生成UUID<br>转换成HashMap存储<br>存储token<br>设置有效期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        // 4. 用户存在, 保存到session中</span></span><br><span class="line"><span class="comment">//        session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));</span></span><br><span class="line">        <span class="comment">// 保存用户信息到Redis中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        log.debug(<span class="string">&quot;token:&#123;&#125;&quot;</span>,token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换HashMap存储</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY+token;</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);</span><br><span class="line">        <span class="comment">//设置token有效期  </span></span><br><span class="line">        stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br></pre></td></tr></table></figure><p><strong>但这段代码没有更新token有效期:</strong><br>在preHandle中实现;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span>  request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">   <span class="comment">//判断用户是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (StrUtil.isBlank(token))&#123;</span><br><span class="line">      response.setStatus(<span class="number">401</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 基于token获取Hash数据的用户</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY+token;</span><br><span class="line">    Map&lt;Object,Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);</span><br><span class="line">    <span class="comment">// 判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (userMap.isEmpty())&#123;</span><br><span class="line">        response.setStatus(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    UserHolder.saveUser(userDTO);</span><br><span class="line">    <span class="comment">// 刷新token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699031051581-9951aaef-bd4b-4f9d-9379-a1a44e51acfe.png#averageHue=%232c2b2b&clientId=uc77679ca-2224-4&from=paste&height=758&id=ub014d843&originHeight=947&originWidth=1814&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146553&status=done&style=none&taskId=ua7d97c5d-ce29-44e6-a456-623f2a888f5&title=&width=1451.2" alt="image.png"><br><a href="https://blog.csdn.net/qq3434569/article/details/113940767">使用Hutool的BeanUtil优雅的讲Map转为javaBean_beanutil map转对象-CSDN博客</a><br>但是会报错服务器异常<br>解决:<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699031558738-b9faeca0-1063-41b7-9d18-c10d1aeb77bc.png#averageHue=%232d2c2c&clientId=uc77679ca-2224-4&from=paste&height=561&id=u94138825&originHeight=701&originWidth=1708&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118546&status=done&style=none&taskId=u0b8c18e8-4e47-446b-b156-004339a07a6&title=&width=1366.4" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">               CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((filename, fileValue)-&gt; fileValue.toString())</span><br><span class="line">               );</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拦截器优化"><a href="#拦截器优化" class="headerlink" title="拦截器优化"></a>拦截器优化</h2><p><strong>问题: 如果用户访问一些不需要登录的界面, 那么过期时间到了之后, 就会自动退出登录</strong><br>**解决办法: **</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698916213005-332df564-3b55-43a9-a60f-74d549dcbbbf.png#averageHue=%23e8d7d4&clientId=uc0c97467-78c9-4&from=paste&height=611&id=ud9121bae&originHeight=1222&originWidth=2366&originalType=binary&ratio=2&rotation=0&showTitle=false&size=671865&status=done&style=none&taskId=u1b7bf3be-3c11-424d-9b49-642a36aac1d&title=&width=1183" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshIntercepter</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshIntercepter</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span>  request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token))&#123;`</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基于token获取Hash数据的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY+token;</span><br><span class="line">        Map&lt;Object,Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);</span><br><span class="line">        <span class="comment">// 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699033166224-6b311249-d8ac-4919-8bfb-01fde2904928.png#averageHue=%232c2b2b&clientId=uc77679ca-2224-4&from=paste&height=460&id=u7eeb875c&originHeight=575&originWidth=1535&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85465&status=done&style=none&taskId=u5687a791-fddf-43ee-82f9-4c29ac5ba08&title=&width=1228" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699033178566-858b9d04-7fa0-40c5-b495-538b8e77d349.png#averageHue=%232c2c2b&clientId=uc77679ca-2224-4&from=paste&height=382&id=u40b497e8&originHeight=478&originWidth=1259&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56335&status=done&style=none&taskId=uc9b1de4c-840a-493c-9bf1-1db531df6cb&title=&width=1007.2" alt="image.png"></p><h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p>临时存储数据的地方<br><strong>缓存的作用: 降低后端负载,降低响应时间, 应对更多的并发请求</strong><br><strong>缓存的成本: 数据一致性成本, 代码维护下成本, 运维成本</strong></p><h2 id="添加用户缓存"><a href="#添加用户缓存" class="headerlink" title="添加用户缓存"></a>添加用户缓存</h2><pre><code>  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/38717174/1699082099728-62ad2f9e-259c-4e25-9e18-fcdce88f80cc.png#averageHue=%23f2f1f1&amp;clientId=u603f9972-ee0f-4&amp;from=paste&amp;height=826&amp;id=uec12dec0&amp;originHeight=1032&amp;originWidth=2120&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=398838&amp;status=done&amp;style=none&amp;taskId=u16271973-331e-47ac-b1d3-c7926ef6e65&amp;title=&amp;width=1696)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">  StringRedisTemplate stringRedisTemplate;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> CACHE_SHOP_KEY +id;</span><br><span class="line">      <span class="comment">// 从redis查询商铺缓存</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果存在, 返回商铺信息</span></span><br><span class="line">      <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">          <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson,Shop.class);</span><br><span class="line">          <span class="keyword">return</span>  Result.ok(shop);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果不存在, 查询数据库</span></span><br><span class="line">      <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">      <span class="comment">// 判断数据库信息是否存在</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//不存在则返回404</span></span><br><span class="line">      <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 存在, 则将商品信息写入redis</span></span><br><span class="line">      stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));</span><br><span class="line">      <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699084036007-5f956627-b2b8-44ae-9dcb-cb15421c3fe5.png#averageHue=%23a3a2a2&clientId=uae1f6871-ad73-4&from=paste&height=500&id=ub61c05fe&originHeight=625&originWidth=1707&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=151609&status=done&style=none&taskId=uf1d67d00-ee1a-4615-a71f-20d43375455&title=&width=1365.6" alt="image.png"></p><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>由于数据库数据改变,而缓存中数据没有改变,造成用户从缓存中得到的数据与数据库中的数据不一致<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699103143774-ea4905f1-7972-4462-a657-662e7c59b612.png#averageHue=%23e1cdcc&clientId=uae1f6871-ad73-4&from=paste&height=598&id=uc5a9af08&originHeight=748&originWidth=2065&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=272856&status=done&style=none&taskId=u4a9bfdfe-d102-4ff0-882b-fe301ffa8f4&title=&width=1652" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699103259583-b9059fb3-2054-4d80-9340-ec3db709035e.png#averageHue=%23f0f0f0&clientId=uae1f6871-ad73-4&from=paste&height=199&id=ud4e5ebb2&originHeight=249&originWidth=1550&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137644&status=done&style=none&taskId=u733c391e-4a63-4269-868c-1d176ea5381&title=&width=1240" alt="image.png"><br>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。<br><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式),但是当时间很长,缓存就不会被更新<br><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存<br>如果在设置的时间内,数据库发生变化,也会导致数据库不一致<br>**主动更新： 在修改数据库的同时,更新缓存 **我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题,<br><strong>主动更新业务实现:</strong><br>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699108883261-845c3698-3df3-4bc3-af21-c6ee09a080bc.png#averageHue=%23f4f3f3&clientId=uae1f6871-ad73-4&from=paste&height=791&id=u99508fb0&originHeight=989&originWidth=2221&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=364799&status=done&style=none&taskId=ueb35e8bf-0e9a-4a31-a62a-732f7099e79&title=&width=1776.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109050443-3b914bfa-4354-40e2-a38e-e6c7188835bd.png#averageHue=%23f5f4f4&clientId=uae1f6871-ad73-4&from=paste&height=751&id=u932f7a09&originHeight=939&originWidth=2206&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=545799&status=done&style=none&taskId=u93e3d3fa-f060-4ce1-b661-eaa94b08374&title=&width=1764.8" alt="image.png"></p><p><strong>缓存安全问题</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109457009-b58327fb-1853-4230-8fae-c80c6d23bf87.png#averageHue=%23f3f2f2&clientId=uae1f6871-ad73-4&from=paste&height=828&id=u65c2a515&originHeight=1035&originWidth=2001&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=357984&status=done&style=none&taskId=ub9fec107-412a-436c-8def-1419a45a991&title=&width=1600.8" alt="image.png"><br>方案二相对来说发生概率低一些, 同时也可以加入超时时间, 万一发生旧数据进入 缓存,也可以进行清除<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109497850-cc021bf3-3261-4972-af61-43df6990d8fa.png#averageHue=%23f1f1f1&clientId=uae1f6871-ad73-4&from=paste&height=563&id=uc77f74fc&originHeight=704&originWidth=1252&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=276299&status=done&style=none&taskId=uf8d14cb0-461a-40f3-b58f-de404a6a33a&title=&width=1001.6" alt="image.png"></p><h2 id="实现商品缓存和数据库一致"><a href="#实现商品缓存和数据库一致" class="headerlink" title="实现商品缓存和数据库一致"></a>实现商品缓存和数据库一致</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699150811280-843ac537-e79d-4bef-9afa-eacc07858936.png#averageHue=%232c2b2b&clientId=u8a7806e8-b16d-4&from=paste&height=550&id=u454baf3b&originHeight=687&originWidth=1805&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106945&status=done&style=none&taskId=udb5f5a95-64d9-4f70-b5fa-552a75064d5&title=&width=1444" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (shop.getId()==<span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新数据库</span></span><br><span class="line">      updateById(shop);</span><br><span class="line">      <span class="comment">//删除缓存</span></span><br><span class="line">      stringRedisTemplate.delete(CACHE_SHOP_KEY+shop.getId());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Result.ok();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699150935337-7bba4650-cf0c-4b03-8c06-936b79a49b78.png#averageHue=%23fbfbfb&clientId=u8a7806e8-b16d-4&from=paste&height=716&id=u6d0ceee5&originHeight=895&originWidth=2130&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=170185&status=done&style=none&taskId=uea060b02-c509-4ab6-ab89-910cf0bcb89&title=&width=1704" alt="image.png"><br>如果通过并发,无限到达数据库, 就容易给数据库弄垮<br><strong>解决办法</strong></p><ol><li><strong>数据库返回NUll对象,缺点是有额外的内存消耗(可以设置TTL解决)</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151041627-5b3c3aea-5d04-4717-8afc-d6622bd35dc9.png#averageHue=%23fafafa&clientId=u8a7806e8-b16d-4&from=paste&height=576&id=uab32b173&originHeight=720&originWidth=1646&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=172693&status=done&style=none&taskId=u32000052-6e1e-429a-b628-48817bc2525&title=&width=1316.8" alt="image.png"></p><ol start="2"><li><strong>布隆过滤器</strong></li></ol><p>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151188719-0e6360f7-7e8f-4ef4-b388-f2f880690a5a.png#averageHue=%23f7f4f2&clientId=u8a7806e8-b16d-4&from=paste&height=589&id=u8698caf1&originHeight=736&originWidth=641&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=143003&status=done&style=none&taskId=u5dfcd73b-9d0f-4f28-a98c-ee4dc90faa2&title=&width=512.8" alt="image.png"><br>通过哈希算法,将计算出来的放到布隆过滤器, 但有一点的穿透风险</p><h2 id="编码解决缓存穿透问题"><a href="#编码解决缓存穿透问题" class="headerlink" title="编码解决缓存穿透问题"></a>编码解决缓存穿透问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151426970-975a19c5-190a-4cbc-9cb8-7730a4e0eeae.png#averageHue=%23eeeceb&clientId=u8a7806e8-b16d-4&from=paste&height=724&id=ufd2bf6d2&originHeight=905&originWidth=2216&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=489525&status=done&style=none&taskId=ud00847b5-9d3d-4995-92a5-3208ec8b719&title=&width=1772.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699152411753-22724bfd-50be-4397-a9d3-de819dfb08c6.png#averageHue=%232c2b2b&clientId=u8a7806e8-b16d-4&from=paste&height=821&id=ueccd8b74&originHeight=1026&originWidth=1725&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=182832&status=done&style=none&taskId=ucfa5cf87-6015-449d-abdb-63ddb17a991&title=&width=1380" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> CACHE_SHOP_KEY +id;</span><br><span class="line">      <span class="comment">// 从redis查询商铺缓存</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果存在, 返回商铺信息</span></span><br><span class="line">      <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">          <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson,Shop.class);</span><br><span class="line">          <span class="keyword">return</span>  Result.ok(shop);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">      <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">          Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果不存在, 查询数据库</span></span><br><span class="line">      <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">      <span class="comment">// 判断数据库信息是否存在</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//不存在则返回404</span></span><br><span class="line">      <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">          stringRedisTemplate.opsForValue().set(key, <span class="literal">null</span>, CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 存在, 则将商品信息写入redis</span></span><br><span class="line">      stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">      <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>shopJson !&#x3D; null改成shopJson&#x3D;&#x3D;”” 会好理解一些<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151837524-18fef19d-e4f4-44a6-9d1b-59bd831ed3b5.png#averageHue=%23f3f3f3&clientId=u8a7806e8-b16d-4&from=paste&height=606&id=ua6e3adc9&originHeight=757&originWidth=1159&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=258097&status=done&style=none&taskId=u63150d66-1512-4adc-8e89-cde31dd00fd&title=&width=927.2" alt="image.png"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时段大量的缓存key同时失效或者redis服务宕机, 导致大量请求数据库, 带来巨大的压力<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699156133884-03a9e60a-e486-4753-855f-cb3d665e4f55.png#averageHue=%23f4f1f1&clientId=u8a7806e8-b16d-4&from=paste&height=708&id=u21bd2e8b&originHeight=885&originWidth=2131&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=428063&status=done&style=none&taskId=ud80e8200-7410-4930-a7a7-94d2a5fff06&title=&width=1704.8" alt="image.png"></p><h2 id="2-8-缓存击穿"><a href="#2-8-缓存击穿" class="headerlink" title="2.8 缓存击穿"></a>2.8 缓存击穿</h2><p>某一个key在同一时间内被多次访问,这个key突然失效了, 就会在这个时间给数据库带来巨大的冲击力<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699164935235-f9e69e3a-9839-4988-bcf3-05fcc8bbe7e5.png#averageHue=%23eee7e0&clientId=u8a7806e8-b16d-4&from=paste&height=634&id=uedae8863&originHeight=792&originWidth=1375&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=184549&status=done&style=none&taskId=u07604b7c-d211-4032-a2fb-2c54e505ba2&title=&width=1100" alt="image.png"><br>线程1 本来是想查询数据库载入缓存, 但这时候同时又线程2, 3, 4 同时访问缓存, 都没有查到数据, 那么就会造成多个线程同时访问数据的情况 , 从而给数据带来巨大的压力.<br><strong>解决办法</strong></p><ul><li><strong>互斥锁</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165112699-f82c55bc-80d4-4901-93de-d12a6cc22f19.png#averageHue=%23f0efee&clientId=u8a7806e8-b16d-4&from=paste&height=885&id=u2a142e12&originHeight=1106&originWidth=858&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=237978&status=done&style=none&taskId=ua33f7dbc-07cd-42f0-ba18-f5706ab877c&title=&width=686.4" alt="image.png"></p><ul><li>缓存过期</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165423813-dc9dfe19-82d4-4c5f-be78-48ffd666753d.png#averageHue=%23eae4e3&clientId=u4e51b1c4-2b80-4&from=paste&height=850&id=u953941fc&originHeight=1062&originWidth=1273&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=295603&status=done&style=none&taskId=ucbf9f236-40c4-4475-ac4c-726224769e3&title=&width=1018.4" alt="image.png"><br>返回的是过期的数据<br><strong>对比</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165463393-d285571e-7568-4c7e-9424-8f549a8680ba.png#averageHue=%23e5cecd&clientId=u4e51b1c4-2b80-4&from=paste&height=741&id=uedc66771&originHeight=926&originWidth=2075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=217678&status=done&style=none&taskId=u83a615ea-ced1-49ae-8338-90263514659&title=&width=1660" alt="image.png"></p><h2 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699171874898-e4083975-1612-4c7b-b4e8-9ffb2336aa1f.png#averageHue=%23faf7f7&clientId=uad14f619-a4eb-4&from=paste&height=655&id=ud00ad32f&originHeight=819&originWidth=1703&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=266694&status=done&style=none&taskId=uc956f7fb-48f5-4dfc-8727-1924bce78e9&title=&width=1362.4" alt="image.png">在多个线程并行执行的时候需要达到一个效果, 一个成功, 其他失败的效果<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699172055792-65c7c469-65fa-41f5-92dc-60fef825831e.png#averageHue=%230b2138&clientId=uad14f619-a4eb-4&from=paste&height=526&id=u02efe0ef&originHeight=657&originWidth=998&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=379673&status=done&style=none&taskId=ue71c7007-c3ba-448e-8a7a-5540e3405fc&title=&width=798.4" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span>   <span class="keyword">void</span> <span class="title function_">delLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> CACHE_SHOP_KEY +id;</span><br><span class="line">       <span class="comment">// 从redis查询商铺缓存 </span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断是否存在</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果存在, 返回商铺信息</span></span><br><span class="line">       <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">           <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson,Shop.class);</span><br><span class="line">           <span class="keyword">return</span> shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">           Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.如果不存在, 尝试获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lock_key</span> <span class="operator">=</span> <span class="string">&quot;lock:shop&quot;</span>+key;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lock_key);</span><br><span class="line">       <span class="comment">// 1.1 判断是否获取锁</span></span><br><span class="line">       <span class="comment">//1.2 没有获得互斥锁=&gt;  休眠</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//1.3 获得互斥锁=&gt; 根据id查询数据库</span></span><br><span class="line">           shop = getById(id);</span><br><span class="line">           <span class="comment">// 判断数据库信息是否存在</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//不存在则返回错误信息</span></span><br><span class="line">           <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">               stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//1.4 将商铺数据写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//1.5 释放互斥锁</span></span><br><span class="line">           delLock(key);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="利用逻辑过期方式解决缓存击穿问题"><a href="#利用逻辑过期方式解决缓存击穿问题" class="headerlink" title="利用逻辑过期方式解决缓存击穿问题"></a>利用逻辑过期方式解决缓存击穿问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699193223625-18f4022d-72dd-473e-86e0-ab6d318323eb.png#averageHue=%23f8f4f4&clientId=uad14f619-a4eb-4&from=paste&height=707&id=u720bf9b2&originHeight=884&originWidth=1892&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=451704&status=done&style=none&taskId=uc3f96aaf-10d2-4b74-a921-dae73e262f4&title=&width=1513.6" alt="image.png"><br><a href="https://blog.csdn.net/u012448904/article/details/84292821">https://blog.csdn.net/u012448904/article/details/84292821</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveShop2RedisData</span><span class="params">(Long id, Long expireTime)</span>&#123;</span><br><span class="line">       <span class="comment">// 查询店铺数据</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//封装逻辑过期时间</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(shop);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireTime));</span><br><span class="line">       <span class="comment">// 将数据写入redis, 并设置过期时间</span></span><br><span class="line">      stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(redisData));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> CACHE_SHOP_KEY +id;</span><br><span class="line">      <span class="comment">// 从redis查询商铺缓存</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1.判断是否存在</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//1.1 如果不存在</span></span><br><span class="line">      <span class="keyword">if</span> (StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//1.2如果命中, 先把Json反序列化为对象</span></span><br><span class="line">      <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span>  JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">      <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">      <span class="comment">//2. 判断缓存是否过期</span></span><br><span class="line">      <span class="comment">// 2.1 如果没有过期, 返回商品信息</span></span><br><span class="line">     <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">         <span class="keyword">return</span> shop;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 3. 如果过期, 则需要缓存重建</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">      <span class="comment">// 3.1 如果获取到了互斥锁</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">              <span class="comment">//开启独立线程, 实现缓存重建</span></span><br><span class="line">              CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">                  <span class="comment">//重建缓存</span></span><br><span class="line">                  <span class="built_in">this</span>.saveShop2RedisData(id,<span class="number">20L</span>);</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放锁</span></span><br><span class="line">          delLock(lockKey);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果过期, 则直接返回商品信息</span></span><br><span class="line">      <span class="keyword">return</span> shop;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699232522556-19d223a8-d12d-4403-85b3-b930bfb9f710.png#averageHue=%23ebebeb&clientId=ud845c73b-0205-4&from=paste&height=336&id=cd6f7&originHeight=672&originWidth=2300&originalType=binary&ratio=2&rotation=0&showTitle=false&size=362660&status=done&style=none&taskId=u169a78f1-9a1c-491f-9414-b91bb3abcdd&title=&width=1150" alt="image.png"><br>封装后的<code>CacheClient</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.Shop;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.events.Event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">          stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 设置逻辑过期时间</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">          redisData.setData(value);</span><br><span class="line">          redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">          <span class="comment">// 写入redis</span></span><br><span class="line">          stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithThrough</span><span class="params">(String prefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFailBack</span></span><br><span class="line"><span class="params">     ,Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> prefix +id;</span><br><span class="line">          <span class="comment">// 从redis查询商铺缓存</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断是否存在</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果存在, 返回商铺信息</span></span><br><span class="line">          <span class="keyword">if</span>(StrUtil.isNotBlank(json))&#123;</span><br><span class="line">          <span class="comment">// 存在, 直接返回</span></span><br><span class="line">               <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">          <span class="keyword">if</span> (json == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">               Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果不存在, 查询数据库</span></span><br><span class="line">          <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFailBack.apply(id);</span><br><span class="line">          <span class="comment">// 判断数据库信息是否存在</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//不存在则返回错误信息</span></span><br><span class="line">          <span class="keyword">if</span> (r == <span class="literal">null</span>)&#123;</span><br><span class="line">               stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 存在, 则将商品信息写入redis</span></span><br><span class="line">         <span class="built_in">this</span>.set(key,r, time, timeUnit);</span><br><span class="line">          <span class="keyword">return</span> r;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">     <span class="keyword">public</span> &lt;R,ID&gt;R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String prefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFailBack</span></span><br><span class="line"><span class="params">             ,Long time, TimeUnit timeUnit)</span>&#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> prefix +id;</span><br><span class="line">          <span class="comment">// 从redis查询商铺缓存</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">          <span class="comment">// 1.判断是否存在</span></span><br><span class="line">          <span class="comment">//1.1 如果不存在</span></span><br><span class="line">          <span class="keyword">if</span> (StrUtil.isBlank(json))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//1.2如果命中, 先把Json反序列化为对象</span></span><br><span class="line">          <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span>  JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">          <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject)redisData.getData(), type);</span><br><span class="line">          <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">          <span class="comment">//2. 判断缓存是否过期</span></span><br><span class="line">          <span class="comment">// 2.1 如果没有过期, 返回商品信息</span></span><br><span class="line">          <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">               <span class="keyword">return</span> r;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 3. 如果过期, 则需要缓存重建</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">          <span class="comment">// 3.1 如果获取到了互斥锁</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">                    <span class="type">R</span> <span class="variable">r1</span> <span class="operator">=</span> dbFailBack.apply(id);</span><br><span class="line">                    <span class="comment">//开启独立线程, 实现缓存重建</span></span><br><span class="line">                    CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">                         <span class="comment">//重建缓存</span></span><br><span class="line">                         <span class="built_in">this</span>.setWithLogicalExpire(key,r1,time,timeUnit);</span><br><span class="line">                    &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 释放锁</span></span><br><span class="line">               delLock(lockKey);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果过期, 则直接返回商品信息</span></span><br><span class="line">          <span class="keyword">return</span> r;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">          <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">          <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">delLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">          stringRedisTemplate.delete(key);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><dl><dt>里面分别封装了解决缓存穿透和逻辑过期解决缓存击穿的两个函数<br>在通过逻辑过期解决缓存击穿问题中遇到入<code>   R r = JSONUtil.toBean((JSONObject)redisData.getData(), type);</code>  <code>redisData</code>为空的情况</dt><dd>解决办法<br><a href="https://blog.csdn.net/uiguion/article/details/106047677">JSONObject.toBean()方法转成对象报错，或者bean属性全为null-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699372507632-4139d56e-787c-4399-a44d-abc6640a24fb.png#averageHue=%239c7544&clientId=u03392ae4-edfa-4&from=paste&height=325&id=uaa40b9c8&originHeight=325&originWidth=1401&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53374&status=done&style=none&taskId=uc57e265d-757a-444a-8936-5e6c833c53c&title=&width=1401" alt="image.png"><br>不要小写</dd></dl><p>使用Redis工具类:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699372542710-3d357c3b-7365-49fd-9a33-4f850fb63e14.png#averageHue=%232d2c2c&clientId=u03392ae4-edfa-4&from=paste&height=374&id=u87a92367&originHeight=374&originWidth=1629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57706&status=done&style=none&taskId=u4d0ee664-0235-4b98-9707-755d8d45d63&title=&width=1629" alt="image.png"></p><blockquote><p>在逻辑过期中,封装了<code>RedisData</code>是为了将数据和其对应的过期时间封装到一起处理 </p></blockquote><h2 id="缓存总结"><a href="#缓存总结" class="headerlink" title="缓存总结"></a>缓存总结</h2><h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而 订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>当把表进行拆分, 也会破坏这种唯一性<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699426255848-40136d31-4503-444f-9155-5fafaf1a0bdc.png#averageHue=%23fbf2f2&clientId=u03392ae4-edfa-4&from=paste&height=166&id=u64d05cd3&originHeight=208&originWidth=1134&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19066&status=done&style=none&taskId=ucef96a17-421f-4ead-98a3-0f7b4f44969&title=&width=907.2" alt="image.png"><br>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p> 时间戳：31bit，以秒为单位，可以使用69年<br>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 生成序列号,精确到天,确保序列号不会被占满</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span>+prefix+<span class="string">&quot;:&quot;</span>+date);</span><br><span class="line">        <span class="comment">//拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp&lt;&lt;COUNT_BITS|  ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699451963201-96d090a8-10c9-45e5-a77d-09a80bc9bb70.png#averageHue=%23f3f7f1&clientId=u03392ae4-edfa-4&from=paste&height=464&id=u92c542a6&originHeight=580&originWidth=2065&originalType=binary&ratio=1&rotation=0&showTitle=false&size=372721&status=done&style=none&taskId=u9b6d7e2b-ddcc-439b-8c70-4f17bf917b9&title=&width=1652" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">               <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">           &#125;</span><br><span class="line">           latch.countDown();</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">           es.submit(task);</span><br><span class="line">       &#125;</span><br><span class="line">       latch.await();</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h2><p>平价券<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699453018061-98e0c0ec-7b51-47c7-804a-3ad046f592e0.png#averageHue=%23f6f8f6&clientId=u03392ae4-edfa-4&from=paste&height=394&id=u52d9c459&originHeight=493&originWidth=1525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=584380&status=done&style=none&taskId=u68370840-18ab-4403-9307-b8ec30147fc&title=&width=1220" alt="image.png"><br><strong>秒杀券</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699453049584-e0e2bbd2-5e0f-4db2-a0b7-300f056d5300.png#averageHue=%23eef0ed&clientId=u03392ae4-edfa-4&from=paste&height=301&id=ude83893e&originHeight=376&originWidth=1463&originalType=binary&ratio=1&rotation=0&showTitle=false&size=406404&status=done&style=none&taskId=u307cfd87-d489-4177-a9b4-6bdc1093625&title=&width=1170.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699452886736-1cc3a40d-139d-4581-a74a-c8c5686c823b.png#averageHue=%23f1ecea&clientId=u03392ae4-edfa-4&from=paste&height=837&id=udf628ffe&originHeight=1046&originWidth=1904&originalType=binary&ratio=1&rotation=0&showTitle=false&size=557282&status=done&style=none&taskId=uf05654fe-beef-48a5-9b31-98eb188f656&title=&width=1523.2" alt="image.png"></p><h2 id="实现优惠券秒杀的下单功能"><a href="#实现优惠券秒杀的下单功能" class="headerlink" title="实现优惠券秒杀的下单功能"></a>实现优惠券秒杀的下单功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699491830080-d020dec5-6734-4da9-b359-0d0d60d22824.png#averageHue=%23faf8f8&clientId=u62c8c1ac-49eb-4&from=paste&height=718&id=ue1b324d1&originHeight=898&originWidth=1497&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=239141&status=done&style=none&taskId=uaacbd06a-3e0a-4874-bab7-52087d33fd3&title=&width=1197.6" alt="image.png"></p><h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699512912475-448ad530-a79a-493a-9a1b-6ff8dd9c0d1b.png#averageHue=%23ddded5&clientId=ua529897f-17be-4&from=paste&height=143&id=ua95713de&originHeight=286&originWidth=1642&originalType=binary&ratio=2&rotation=0&showTitle=false&size=211099&status=done&style=none&taskId=u58c38c8c-22d1-47c6-893c-b66827e1164&title=&width=821" alt="image.png"><br>在高并发的场景下， 库存变成了负数<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699512954758-1083414b-371d-4821-8cee-70cde0636ffa.png#averageHue=%23637aa8&clientId=ua529897f-17be-4&from=paste&height=396&id=u4af4cf38&originHeight=792&originWidth=1996&originalType=binary&ratio=2&rotation=0&showTitle=false&size=471026&status=done&style=none&taskId=u99d7ebdc-d14a-4f3a-ad94-da9355b9a8f&title=&width=998" alt="image.png"><br>说明这一块的逻辑是有问题的<br>先查询-&gt;判断-&gt;减库存<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513390567-d0602fd3-5f64-43a2-8adc-94ad44a21d21.png#averageHue=%23f5f5f5&clientId=ua529897f-17be-4&from=paste&height=612&id=ue45a8fd8&originHeight=1224&originWidth=2534&originalType=binary&ratio=2&rotation=0&showTitle=false&size=309881&status=done&style=none&taskId=u5b1e322d-15c6-4a68-a1b6-66f01a9da12&title=&width=1267" alt="image.png"><br><strong>解决方案：</strong><br>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513646487-c306a577-0758-45bb-aae4-9e238dee5241.png#averageHue=%23f4f3f3&clientId=uaa6d1fb2-8a9a-4&from=paste&height=505&id=u4f34f58b&originHeight=1010&originWidth=2378&originalType=binary&ratio=2&rotation=0&showTitle=false&size=584418&status=done&style=none&taskId=uf944ddba-4b79-47a7-80de-6a14b5bab2b&title=&width=1189" alt="image.png"><br>乐观锁不用去加锁，而是在执行时才做判断，因此性能高</p><p><strong>乐观锁：</strong></p><ul><li>**版本号法： **</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513930001-21760dc2-af8c-4d02-a702-e3c765847dd6.png#averageHue=%23fafafa&clientId=uaa6d1fb2-8a9a-4&from=paste&height=511&id=u581002a7&originHeight=1022&originWidth=2538&originalType=binary&ratio=2&rotation=0&showTitle=false&size=406163&status=done&style=none&taskId=u03c7ed5e-fb7d-47f6-854d-24371d40d2c&title=&width=1269" alt="image.png"><br>通过版本号来查是否需要-1，来避免超卖问题  </p><ul><li><strong>CAS</strong>优化版本号</li></ul><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699514621548-7c59ea00-55dc-4562-a416-74a211905a37.png#averageHue=%23fbfbfb&clientId=uaa6d1fb2-8a9a-4&from=paste&height=540&id=ubb7b39b4&originHeight=1080&originWidth=2496&originalType=binary&ratio=2&rotation=0&showTitle=false&size=373639&status=done&style=none&taskId=u0ffb655f-ec53-4e13-899d-3537570f4bd&title=&width=1248" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517224445-eea01797-f3b5-4895-a5f9-3e793409fd3d.png#averageHue=%23f2f7ef&clientId=u757ca0cc-a2af-4&from=paste&height=444&id=u6a5ec8e4&originHeight=888&originWidth=2546&originalType=binary&ratio=2&rotation=0&showTitle=false&size=739428&status=done&style=none&taskId=u690bc5ae-1e68-435d-9b63-fd67f80d615&title=&width=1273" alt="image.png"><br> <strong>但是这样就会有一个问题：当stock不为1的时候， 看stock来确定扣不扣减，就会造成更多人抢不到优惠券</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517619198-ba7b27ab-fea1-41bc-a470-87d9fcf71017.png#averageHue=%23f8f8f8&clientId=u757ca0cc-a2af-4&from=paste&height=204&id=u30b15279&originHeight=408&originWidth=1876&originalType=binary&ratio=2&rotation=0&showTitle=false&size=44498&status=done&style=none&taskId=ua120d0fb-d33f-4f68-b8c5-5ffd2253dc6&title=&width=938" alt="image.png">** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517538369-c1b3a1cc-e780-4aec-a3ac-9d7096938cf4.png#averageHue=%23f0f5eb&clientId=u757ca0cc-a2af-4&from=paste&height=140&id=ua90beb84&originHeight=280&originWidth=1962&originalType=binary&ratio=2&rotation=0&showTitle=false&size=277162&status=done&style=none&taskId=ue5bae5be-56b8-45d4-9984-881f5a5c952&title=&width=981" alt="image.png"><br>如果<code>stock&gt;0</code>,就可以购买优惠券</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517838400-7ed70785-bf23-4533-a7c6-fae87940f329.png#averageHue=%23efefef&clientId=u757ca0cc-a2af-4&from=paste&height=333&id=u09d910b9&originHeight=666&originWidth=1222&originalType=binary&ratio=2&rotation=0&showTitle=false&size=232094&status=done&style=none&taskId=u3f41d4e9-e1f4-4df0-a6a8-270e463319b&title=&width=611" alt="image.png"></p><blockquote><p>对于更高并发的场景下， 光这样使用乐观锁是远远不够的， 需要进行进一步优化，</p></blockquote><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699518088817-4d0d4240-ae7d-479a-bec9-a4e3bf28bd6f.png#averageHue=%23fbf9f9&clientId=u757ca0cc-a2af-4&from=paste&height=562&id=ufa5d2047&originHeight=1124&originWidth=2036&originalType=binary&ratio=2&rotation=0&showTitle=false&size=361555&status=done&style=none&taskId=ueffa5321-5918-4f42-966e-a1d7dbe937d&title=&width=1018" alt="image.png"><br>事务失效的情况:<br>加锁<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699693153645-12717c5e-49c8-4d75-92f6-ce805fa03602.png#averageHue=%23f0f5ef&clientId=u2b828817-5288-4&from=paste&height=842&id=u873f76a6&originHeight=842&originWidth=1957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=512561&status=done&style=none&taskId=u89ad8637-7e27-4b78-b23e-60e3f15831a&title=&width=1957" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">           <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">           <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span>&#123;</span><br><span class="line">           <span class="comment">// 1. 提交优惠券id</span></span><br><span class="line">           <span class="comment">//2. 查询优惠券信息</span></span><br><span class="line">           <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">           <span class="comment">//3. 判断秒杀是否开始</span></span><br><span class="line">           <span class="comment">//3.1 如果没有开始, 返回异常结果</span></span><br><span class="line">           <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">               Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 3.2 判断秒杀是否已经结束</span></span><br><span class="line">           <span class="keyword">if</span> (LocalDateTime.now().isAfter(voucher.getEndTime()))&#123;</span><br><span class="line">               Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 4. 秒杀开始, 判断库存是否充足</span></span><br><span class="line">           <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">//4.1 不足, 返回异常结果</span></span><br><span class="line">               Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 实现一人一单</span></span><br><span class="line">           <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">           <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>,userId).eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId).count();</span><br><span class="line">           <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               Result.fail(<span class="string">&quot;用户已经购买过一次&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.2 充足, 扣减库存</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock=stock-1&quot;</span>)</span><br><span class="line">                   .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>) <span class="comment">// 如果大于0就能购买优惠券</span></span><br><span class="line">                   .update();</span><br><span class="line">           <span class="keyword">if</span> (!isSuccess)&#123;</span><br><span class="line">               <span class="keyword">return</span>  Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.3 创建订单</span></span><br><span class="line">           <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">           <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">           voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">           voucherOrder.setUserId(userId);</span><br><span class="line"></span><br><span class="line">           voucherOrder.setVoucherId(voucherId);</span><br><span class="line">           save(voucherOrder);</span><br><span class="line">           <span class="comment">//4.4 返回订单id</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/hanjiaqian/article/details/120501741">【精选】spring 事务失效的 12 种场景_spring 截获duplicatekeyexception 不抛异常_hanjq_code的博客-CSDN博客</a></p><h2 id="一人一单并发安全问题"><a href="#一人一单并发安全问题" class="headerlink" title="一人一单并发安全问题"></a>一人一单并发安全问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699705699282-d6e5cfc6-d0b1-4692-9045-b3bd7c1752b0.png#averageHue=%23f0eded&clientId=u2b828817-5288-4&from=paste&height=990&id=u2b5403a6&originHeight=990&originWidth=2087&originalType=binary&ratio=1&rotation=0&showTitle=false&size=506190&status=done&style=none&taskId=u76807860-0e90-4ec5-ace9-4f40d89a0bc&title=&width=2087" alt="image.png"><br>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699763384484-e83248bd-53cc-43e6-b5b2-1aa92f9982c2.png#averageHue=%23f4f2f2&clientId=u2b828817-5288-4&from=paste&height=864&id=ufa6eb578&originHeight=1080&originWidth=2262&originalType=binary&ratio=1&rotation=0&showTitle=false&size=482845&status=done&style=none&taskId=uf703bade-d8ba-409f-ba8e-9c0101b0700&title=&width=1809.6" alt="image.png"><br>让多个JVM都能看到同一个锁监视器<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699763801336-f81b5646-caff-4432-bfb4-7ddf5afaa5a9.png#averageHue=%23e4d5d5&clientId=u2b828817-5288-4&from=paste&height=1001&id=uc6a8dd14&originHeight=1001&originWidth=2209&originalType=binary&ratio=1&rotation=0&showTitle=false&size=366621&status=done&style=none&taskId=u9cb2dfa0-cdd0-4344-9431-950df9bda81&title=&width=2209" alt="image.png"></p><h2 id="Redis分布式锁实现思路"><a href="#Redis分布式锁实现思路" class="headerlink" title="Redis分布式锁实现思路"></a>Redis分布式锁实现思路</h2><p><a href="https://blog.csdn.net/huo065000/article/details/119970629">【精选】redis分布式锁(一）set NX实现_心心念念的小鼠标的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699764476731-6ac1814f-7f3f-4442-b0af-43405c724fd9.png#averageHue=%23102a3d&clientId=u2b828817-5288-4&from=paste&height=298&id=uadcf17e7&originHeight=298&originWidth=1888&originalType=binary&ratio=1&rotation=0&showTitle=false&size=235838&status=done&style=none&taskId=uea343540-7380-459c-bb72-201b12a7257&title=&width=1888" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699764614586-e1387af2-56e8-4cc4-a022-c87c0a93bb55.png#averageHue=%23f9f8f8&clientId=u2b828817-5288-4&from=paste&height=1031&id=u34b6c92a&originHeight=1031&originWidth=2069&originalType=binary&ratio=1&rotation=0&showTitle=false&size=460353&status=done&style=none&taskId=u61d17e47-f8a8-43d1-84b2-2d401efb444&title=&width=2069" alt="image.png"></p><h2 id="实现分布式锁初级版本"><a href="#实现分布式锁初级版本" class="headerlink" title="实现分布式锁初级版本"></a>实现分布式锁初级版本</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771133816-3aa47901-f070-4aa4-924f-e0f8dc690bb4.png#averageHue=%23faf9f8&clientId=u2b828817-5288-4&from=paste&height=781&id=uace818c4&originHeight=859&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188710&status=done&style=none&taskId=u70b504e5-e6d1-4ed9-a8c6-5c9baa37a74&title=&width=699.0908939385221" alt="image.png"></p><ul><li><strong>锁的基本接口</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699770874269-dc390610-18b3-4234-8c58-280d2c2e64b4.png#averageHue=%23f0f3ee&clientId=u2b828817-5288-4&from=paste&height=415&id=u965c0e3d&originHeight=415&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117726&status=done&style=none&taskId=ubc19fde2-7ab1-4e2d-8c5c-37256633aa9&title=&width=1037" alt="image.png"></p><ul><li><strong>SimpleRedisLock</strong></li></ul><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedis</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedis</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock :&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> longTimeSec)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取线程标识</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, id + <span class="string">&quot;&quot;</span>, longTimeSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 避免自动拆箱</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(aBoolean) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改业务代码</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771107955-f9d0ac98-aad1-4920-a963-a22da1ace571.png#averageHue=%232c2c2b&clientId=u2b828817-5288-4&from=paste&height=1185&id=u17f30d65&originHeight=1304&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174600&status=done&style=none&taskId=uc3445396-9b6e-48fa-b184-5190fc14a44&title=&width=1099.9999761581425" alt="image.png"></p><h2 id="Redis分布式锁的误删问题"><a href="#Redis分布式锁的误删问题" class="headerlink" title="Redis分布式锁的误删问题"></a>Redis分布式锁的误删问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771472494-df7802e3-1e3e-48db-a2be-11d3466f206b.png#averageHue=%23fbfafa&clientId=u2b828817-5288-4&from=paste&height=781&id=u7f928350&originHeight=859&originWidth=2200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=326266&status=done&style=none&taskId=u96caefbb-0f03-4002-8df2-fafa9619487&title=&width=1999.9999566511683" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771503937-7b6b9c51-b148-4087-85f5-5e40d94de5a5.png#averageHue=%23edebeb&clientId=u2b828817-5288-4&from=paste&height=785&id=u69cf30e6&originHeight=864&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157135&status=done&style=none&taskId=u1afa3fa6-c0ca-4a34-a934-49729056b1e&title=&width=750.9090746335751" alt="image.png"><br>在释放锁之前增加一层判断逻辑</p><h2 id="解决锁的误删问题"><a href="#解决锁的误删问题" class="headerlink" title="解决锁的误删问题"></a>解决锁的误删问题</h2><p><a href="https://www.cnblogs.com/jasonboren/p/12939852.html">java UUID的作用和使用 - jason小蜗牛 - 博客园</a><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771765473-775cddd0-965a-4408-9acc-934cbec110d0.png#averageHue=%23f3f2f2&clientId=u2b828817-5288-4&from=paste&height=498&id=u09492cfa&originHeight=548&originWidth=1267&originalType=binary&ratio=1&rotation=0&showTitle=false&size=240179&status=done&style=none&taskId=u64ef6819-7ec7-4225-bb5c-40c34a513c1&title=&width=1151.8181568531957" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699772446928-2bb328ee-e2f8-4e78-b3b8-1fe4f5b17083.png#averageHue=%232c2c2b&clientId=u2b828817-5288-4&from=paste&height=1118&id=u58788f34&originHeight=1230&originWidth=1596&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206341&status=done&style=none&taskId=u97a17e7e-6ba0-4459-9bfe-bc617761e6c&title=&width=1450.909059461484" alt="image.png"></p><h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699796424412-f2c361aa-52b8-4395-81ef-b1628281fd56.png#averageHue=%23f5f3f3&clientId=u24e974b6-b49d-4&from=paste&height=866&id=uf39233f4&originHeight=866&originWidth=2162&originalType=binary&ratio=1&rotation=0&showTitle=false&size=504589&status=done&style=none&taskId=ud0a673e8-d152-4459-983c-188bfa3615a&title=&width=2162" alt="image.png"></p><h2 id="Lua解决多条命令原子性问题"><a href="#Lua解决多条命令原子性问题" class="headerlink" title="Lua解决多条命令原子性问题"></a>Lua解决多条命令原子性问题</h2><p><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a><br>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。<br>可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699880933064-77dee115-28f2-45cc-9773-6f6a5e124376.png#averageHue=%23d3d4d2&clientId=u92f804e2-0ef3-4&from=paste&height=638&id=u99462bf3&originHeight=798&originWidth=1620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=374301&status=done&style=none&taskId=u506ee292-5250-4856-9db0-a03c13e6c4d&title=&width=1296" alt="image.png">  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881087375-df2ee1b5-d8de-4f04-95b3-f1f9f415392f.png#averageHue=%23d4d7ce&clientId=u92f804e2-0ef3-4&from=paste&height=631&id=u56132fa4&originHeight=789&originWidth=1980&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=450447&status=done&style=none&taskId=u711f0716-833b-4d54-abf2-1c92700e50a&title=&width=1584" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881108549-4fc8f91d-920a-4b92-abba-c1067984756c.png#averageHue=%230e283c&clientId=u92f804e2-0ef3-4&from=paste&height=438&id=ufa0cda3a&originHeight=548&originWidth=1831&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=424857&status=done&style=none&taskId=ucfaaba09-ac69-4b7f-9153-cd3d2cfb9c4&title=&width=1464.8" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881232331-845d5b44-b145-4e58-9fed-20a28245927a.png#averageHue=%238ac2a2&clientId=u92f804e2-0ef3-4&from=paste&height=275&id=u8841d17e&originHeight=344&originWidth=2182&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=316067&status=done&style=none&taskId=u4b4b0479-e121-4cc0-b8b7-79ba8438af2&title=&width=1745.6" alt="image.png">  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881493990-b8608b49-856e-48fd-8c89-fd9adab0eef6.png#averageHue=%23efefef&clientId=u92f804e2-0ef3-4&from=paste&height=556&id=u217bfdf2&originHeight=695&originWidth=1642&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=460710&status=done&style=none&taskId=ucc2afb76-fb02-468e-8334-95ed95e25b7&title=&width=1313.6" alt="image.png"><br>优化后:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881563797-921e1dbf-f656-419e-b0f3-8f047a74ec57.png#averageHue=%23d3dcd0&clientId=u92f804e2-0ef3-4&from=paste&height=353&id=u409c8838&originHeight=441&originWidth=1908&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=409800&status=done&style=none&taskId=ud7f2cc77-b11a-428e-961d-17caf406a5a&title=&width=1526.4" alt="image.png"></p><h2 id="再次改进Redis的分布式锁"><a href="#再次改进Redis的分布式锁" class="headerlink" title="再次改进Redis的分布式锁"></a>再次改进Redis的分布式锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881705712-7b360bee-7d40-4dbb-a339-9c6eaebe02a9.png#averageHue=%23ecefe7&clientId=u92f804e2-0ef3-4&from=paste&height=751&id=u9ae334e3&originHeight=939&originWidth=1913&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=592210&status=done&style=none&taskId=u1225738a-2bcb-4bea-bb86-1caaf4d9339&title=&width=1530.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699882174692-9e036f2c-ef32-4bea-a179-9bfea183a8e4.png#averageHue=%23f0f5ef&clientId=u92f804e2-0ef3-4&from=paste&height=871&id=u40b269f1&originHeight=1089&originWidth=1722&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=518841&status=done&style=none&taskId=u4c0e6e69-a223-45fc-973e-3393b5e0bb7&title=&width=1377.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699882344511-6207e555-2c39-4f2e-9bdf-ea38db59b776.png#averageHue=%23efefef&clientId=u92f804e2-0ef3-4&from=paste&height=427&id=ufd8c3a1b&originHeight=534&originWidth=1071&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223373&status=done&style=none&taskId=uad9dd949-1b2c-4817-8c6e-7dcdd58f793&title=&width=856.8" alt="image.png"></p><h2 id="Redisson功能介绍"><a href="#Redisson功能介绍" class="headerlink" title="Redisson功能介绍"></a>Redisson功能介绍</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699979826880-5d8dda27-fa55-4c01-96aa-4b8a7b45ac1f.png#averageHue=%23fcfcfc&clientId=ub5bfeee0-49d7-4&from=paste&height=517&id=u83b9b5cf&originHeight=1034&originWidth=2120&originalType=binary&ratio=2&rotation=0&showTitle=false&size=600636&status=done&style=none&taskId=udc199d20-1fa7-4ced-9073-3f467d8844e&title=&width=1060" alt="image.png"></p><h2 id="Redisson可重入锁原理原理"><a href="#Redisson可重入锁原理原理" class="headerlink" title="Redisson可重入锁原理原理"></a>Redisson可重入锁原理原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700018645762-279974a1-1dd6-45ca-9137-7d97dcf1722b.png#averageHue=%23f2f4ef&clientId=u581ad08b-35c6-4&from=paste&height=631&id=u985b8ce9&originHeight=1262&originWidth=2514&originalType=binary&ratio=2&rotation=0&showTitle=false&size=949703&status=done&style=none&taskId=u48284284-8e00-42df-b8e4-fd63c27ab94&title=&width=1257" alt="image.png"><br>通过执行任务完成减1来实现。<br>但这么复杂的逻辑。 需要通过Lua脚本来实现，确保原子性。<br>获取锁过程。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700018849312-e6676ce5-f980-445b-995c-1946733368bf.png#averageHue=%23eff1eb&clientId=u581ad08b-35c6-4&from=paste&height=614&id=u9a7b9e93&originHeight=1228&originWidth=2530&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1223900&status=done&style=none&taskId=u4de41c11-5b16-4b1b-8219-d5138838503&title=&width=1265" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019201833-de25b267-f566-4248-b001-6b3219bc861d.png#averageHue=%23eef1eb&clientId=u581ad08b-35c6-4&from=paste&height=595&id=ua4c740d1&originHeight=1190&originWidth=2492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1177806&status=done&style=none&taskId=ue12f011f-611b-497c-9475-5d181fbae4d&title=&width=1246" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019729671-7907b6e9-3ce3-46f2-9c2f-15af55b0f90a.png#averageHue=%23e7eee5&clientId=u581ad08b-35c6-4&from=paste&height=538&id=ufe7345c9&originHeight=1076&originWidth=2676&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1379062&status=done&style=none&taskId=uecac0475-8044-4070-baae-172b3f09512&title=&width=1338" alt="image.png"><br>tryLock底层就是用了Lua脚本<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019806532-f028d6ff-e7b6-4d6a-8d84-bd814933273d.png#averageHue=%23eff5ec&clientId=u581ad08b-35c6-4&from=paste&height=509&id=u15053e07&originHeight=1018&originWidth=2654&originalType=binary&ratio=2&rotation=0&showTitle=false&size=917520&status=done&style=none&taskId=u0fb71384-75f0-4ea9-a6ff-8eb71718abb&title=&width=1327" alt="image.png"><br>核心就是通过Hash结构来记录锁的调用次数。<br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700055978583-286839e3-3017-4406-90df-b6e930f55ab0.png#averageHue=%23f4f2f2&clientId=u50dd14e7-a648-4&from=paste&height=760&id=uca34f263&originHeight=760&originWidth=1843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=316805&status=done&style=none&taskId=u973abdad-f003-4415-a81a-05f0d2801d3&title=&width=1843" alt="image.png"></p><h2 id="基于redis分布式锁优化"><a href="#基于redis分布式锁优化" class="headerlink" title="基于redis分布式锁优化"></a>基于redis分布式锁优化</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056217601-0c6e7d65-7fab-45c1-9989-38132616d579.png#averageHue=%23f9f0ef&clientId=u50dd14e7-a648-4&from=paste&height=761&id=ub1c7888f&originHeight=951&originWidth=1840&originalType=binary&ratio=1&rotation=0&showTitle=false&size=342512&status=done&style=none&taskId=uf5e10912-f68c-4b07-a9c1-5b60e80ea2a&title=&width=1472" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056481920-222e2d99-5e68-4a84-86d3-14bae28ffa37.png#averageHue=%23f5e6e5&clientId=u50dd14e7-a648-4&from=paste&height=782&id=u834d1a86&originHeight=977&originWidth=2234&originalType=binary&ratio=1&rotation=0&showTitle=false&size=496050&status=done&style=none&taskId=u16887b86-dff6-4f7c-a321-a688a0d78a0&title=&width=1787.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056738489-ecee9d44-ea43-4c3e-abd0-cb305af85adc.png#averageHue=%23f2f7f1&clientId=u50dd14e7-a648-4&from=paste&height=403&id=u87f6f193&originHeight=504&originWidth=1681&originalType=binary&ratio=1&rotation=0&showTitle=false&size=295692&status=done&style=none&taskId=ufa3ae324-8dce-4a6c-8ff7-33f9d1d079b&title=&width=1344.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700057236183-e8f70303-b73e-4043-ae37-5c1415ded4b6.png#averageHue=%23eeeeee&clientId=u50dd14e7-a648-4&from=paste&height=733&id=ua4c7a83f&originHeight=916&originWidth=1222&originalType=binary&ratio=1&rotation=0&showTitle=false&size=391430&status=done&style=none&taskId=ua38b47d1-6d94-4778-9c98-ba092437f32&title=&width=977.6" alt="image.png"></p><h1 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108211115-77067f67-a25b-48e4-8bc2-a573d82fb72d.png#averageHue=%23fbf8f7&clientId=u3efe4494-fe3d-4&from=paste&height=1055&id=u7b2571e0&originHeight=1055&originWidth=2165&originalType=binary&ratio=1&rotation=0&showTitle=false&size=393738&status=done&style=none&taskId=u57881431-e1b4-4e7f-a0f1-14fdc052a34&title=&width=2165" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108448724-60d6a6e1-e83c-4eda-bff2-8ce93f1286c1.png#averageHue=%23faf7f6&clientId=u3efe4494-fe3d-4&from=paste&height=1002&id=u58a39a79&originHeight=1002&originWidth=2181&originalType=binary&ratio=1&rotation=0&showTitle=false&size=432047&status=done&style=none&taskId=u52738e3a-12a1-4fc3-8241-c320d24c34f&title=&width=2181" alt="image.png"><br>使用Lua脚本保证原子性<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108815144-7c7f9c4e-1e85-4a10-878f-e519097dbc39.png#averageHue=%23f4f0f0&clientId=u3efe4494-fe3d-4&from=paste&height=1037&id=u44050025&originHeight=1037&originWidth=2257&originalType=binary&ratio=1&rotation=0&showTitle=false&size=446673&status=done&style=none&taskId=ufd15cf1f-404c-4a32-b5b0-1350b67aec7&title=&width=2257" alt="image.png"><br>为避免所有操作都在数据库上执行，分离成两个线程，一个线程判断用户的购买资格，发现用户有购买资格后再开启一个独立的线程来处理耗时较久的减库存、写订单的操作。<br>可以将耗时较短的两步操作放到 Redis 中，在 Redis 中处理对应的秒杀资格的判断。Redis 的性能是比 MySQL 要好的。此外，还需要引入异步队列记录相关的信息。<br>redis部分处理逻辑， Lua脚本封装操作保证原子性， redis这里选择的存储类型为set，因为key不能重复，而set恰好是无序不重复的<br><strong>基于Redis实现秒杀资格判断</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700143137919-cce8210f-eb55-4cb3-bb70-da4607a4e40c.png#averageHue=%23f1efef&clientId=u3efe4494-fe3d-4&from=paste&height=524&id=u1b444d16&originHeight=524&originWidth=1353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=275261&status=done&style=none&taskId=u9d3d2a8e-d869-43ab-b8c7-412b7836f55&title=&width=1353" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700142114007-8be488d5-8675-44a7-8b42-e48a81b29293.png#averageHue=%230f263c&clientId=u3efe4494-fe3d-4&from=paste&height=494&id=ubcf455b5&originHeight=494&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293776&status=done&style=none&taskId=u2a5cd725-d0d0-47cb-a1a6-437db6b30cd&title=&width=1488" alt="image.png"></p><ul><li>新增优惠券同时,将优惠券信息保存到Redis中</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700143188577-2b7e916f-5102-4a7a-93e3-eb4ec45367b6.png#averageHue=%232c2c2b&clientId=u3efe4494-fe3d-4&from=paste&height=555&id=u4976e03b&originHeight=555&originWidth=1658&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74949&status=done&style=none&taskId=uf10ee419-96a5-4062-a0f5-89a0a83cfcd&title=&width=1658" alt="image.png"></p><ul><li>基于Lua脚本, 判断秒杀库存,一人一单,决定用户是否抢购成功</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.1 订单id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2 用户id</span></span><br><span class="line"><span class="keyword">local</span> useId = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据key</span></span><br><span class="line"><span class="comment">-- 2.1 库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1 判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 不足返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2 库存充足,sismember看userId是否存在于orderId</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3 如果存在,说明下单了,返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4 扣减库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incriby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5下单(保存用户)</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br></pre></td></tr></table></figure><ul><li>java代码中执行lua脚本，并判断，抢购成功的生成订单并存入阻塞队列<br>首先注入脚本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;<span class="comment">//定义代理对象，提前定义后面会用到</span></span><br><span class="line"><span class="comment">//注入脚本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行脚本，且判断不满足的请求直接返回提示信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123; <span class="comment">//使用lua脚本</span></span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), <span class="comment">//这里是key数组，没有key，就传的一个空集合</span></span><br><span class="line">            voucherId.toString(), userId.toString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//2.判断结果是0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();<span class="comment">//Long型转为int型，便于下面比较</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1 不为0，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span>  Result.fail(r == <span class="number">1</span>?<span class="string">&quot;优惠券已售罄&quot;</span>:<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是将满足条件的给存放进阻塞队列中<br>创建一个BlockingQueue阻塞队列</p><blockquote><p><strong>BlockingQueue这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒并获取元素</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建阻塞队列  这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒获取</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);<span class="comment">//初始化阻塞队列的大小</span></span><br></pre></td></tr></table></figure><p>接下来就是将满足条件的请求，给生成订单，并把订单对象add到阻塞队列中，接上面的代码，完成整个第三步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//2.2 为0，有购买资格，把下单信息保存到阻塞队列中</span></span><br><span class="line">    <span class="comment">//7.创建订单   向订单表新增一条数据，除默认字段，其他字段的值需要set</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//7.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//7.2用户id</span></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">//7.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    <span class="comment">//放入阻塞对列中</span></span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="comment">//3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.开启线程任务，实现异步下单功能<br>首先创建一个线程池<br>再定义一个线程任务，但是注意，线程任务需要在用户秒杀订单之前开始，用户一但开始秒杀，队列就会有新的订单，线程任务就应该立即取出订单信息，<strong>这里利用spring提供的注解，在类初始化完毕后立即执行线程任务。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//利用spring提供的注解，在类初始化完毕后立即执行线程任务</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程任务代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程任务，内部类方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取队列中的订单信息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">            <span class="comment">//2.创建订单，这是调之前那个创建订单的方法，需要稍作改动</span></span><br><span class="line">            handleVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;异常信息:&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建调用的handleVoucherOrder方法，这里的获取锁操作只是做最后的兜底，以防万一，因为前面lua脚本都已经判断过了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="comment">//创建锁对象</span></span><br><span class="line">    <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line">    <span class="comment">//判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (!isLock)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;您已购买过该商品，不能重复购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        proxy.createVoucherOrder(voucherOrder);<span class="comment">//使用代理对象，最后用于提交事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>createVoucherOrder创建订单方法，这里一人一单的其实也不必判读了，lua脚本都写好了，这里只是兜底</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">       <span class="comment">//5.一人一单</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getId();</span><br><span class="line">       <span class="comment">//5.1查询订单</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">       <span class="comment">//5.2判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           log.error(<span class="string">&quot;您已经购买过了&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//6.扣减库存</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">               .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)<span class="comment">//set stock = stock -1</span></span><br><span class="line">               .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">               .update();</span><br><span class="line">       <span class="keyword">if</span> (!success)&#123;</span><br><span class="line">           log.error(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后来分析以下整个优化思路</p><p>①编写lua脚本，对于超卖问题和一人一单进行解决处理，超卖用CAS方法判断库存是否大于0，一人一单用redis的set集合的sismenber判读该优惠券（key）下的用户id（value）是否唯一<br>②Java代码中注入脚本，并执行脚本判断脚本返回结果，若不为脚本结果0，直接返回错误提示<br>③若脚本结果为0，代表有购买优惠券资格，将new VoucherOrder创建订单对象，并set orderId，userId，voucherId。再把订单对象放入阻塞队列中，返回订单id给用户<br>④创建线程池，并定义线程任务，但注意，线程任务必须在方法执行前执行，使用到spring提供的注解在类初始化完成后执行线程任务<br>⑤线程任务中获取阻塞队列的订单对象，然后调用handleVoucherOrder方法传入voucherOrder<br>⑥handleVoucherOrder方法其实是再次获取锁，这个就是个纯兜底，作用不大。并在获取锁成功后调用createVoucherOrder方法扣减库存创建订单，由于都是对数据库的操作，因此要提交事务</p><h1 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h1><h2 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192287868-9a1187af-243a-48bc-aa09-c915e6be9d49.png#averageHue=%232d2c2b&clientId=uf4fd22ef-b30f-4&from=paste&height=467&id=uf2e5d9c1&originHeight=584&originWidth=1635&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71962&status=done&style=none&taskId=ud5a1a946-f9b8-4357-b93a-c60d894d2ca&title=&width=1308" alt="image.png"><br>   <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192303259-735adad5-6b92-424d-bad0-ad0848be8aaf.png#averageHue=%23fbf9f8&clientId=uf4fd22ef-b30f-4&from=paste&height=649&id=ua57afb52&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=55014&status=done&style=none&taskId=u5a954408-ad69-4f84-b89b-0f3dca79db5&title=&width=363.2" alt="fd58151acf51b465fc8430594373e22.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192308132-1578fabd-b085-4d49-bc95-4ddf6dbff04e.png#averageHue=%23e2d3cb&clientId=uf4fd22ef-b30f-4&from=paste&height=649&id=u121eda6c&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=241575&status=done&style=none&taskId=ufda28241-dcd6-4295-a2a3-daae5345516&title=&width=363.2" alt="4542b554a076d20a0a6da9b3a770e93.png"></p><h2 id="查看探店笔记"><a href="#查看探店笔记" class="headerlink" title="查看探店笔记"></a>查看探店笔记</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> blogService.queryBlogById(id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">  UserServiceImpl userService;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="comment">// 查询blog</span></span><br><span class="line">      <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">      <span class="keyword">if</span> (blog == <span class="literal">null</span>)Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">      <span class="comment">//查询跟笔记有关的用户</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">      blog.setName(user.getNickName());</span><br><span class="line">      blog.setIcon(user.getIcon());</span><br><span class="line">      <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700193985582-21a43285-d97d-41fb-bb96-008d81a39809.png#averageHue=%23dfd9d4&clientId=u7b8926cd-a983-4&from=paste&height=649&id=ua3a177b0&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223031&status=done&style=none&taskId=ucea36795-d007-4ff6-9d5f-ff0ca06b5a7&title=&width=363.2" alt="image.png"></p><h2 id="完善点赞功能"><a href="#完善点赞功能" class="headerlink" title="完善点赞功能"></a>完善点赞功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700194315711-c845fe89-d025-42f0-a3fe-8d28061c0ded.png#averageHue=%23f5f5f5&clientId=u7b8926cd-a983-4&from=paste&height=761&id=ue7aaec9e&originHeight=951&originWidth=1802&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=443516&status=done&style=none&taskId=u76cbef0d-d4c1-44e3-8596-7e873bba294&title=&width=1441.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700198316712-283624f0-1627-4410-a753-5bf72beb9611.png#averageHue=%23f6f5f5&clientId=u7b8926cd-a983-4&from=paste&height=691&id=ufe8821b3&originHeight=864&originWidth=2126&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=469370&status=done&style=none&taskId=u01a71424-ac53-4a05-9b87-257031d9649&title=&width=1700.8" alt="image.png"><br>为什么采用set集合：<br>因为我们的数据是不能重复的.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700222974076-5d45ce71-9321-483f-a627-6dd08c6181cd.png#averageHue=%232b2b2b&clientId=u7b8926cd-a983-4&from=paste&height=516&id=u3e6ea984&originHeight=516&originWidth=1552&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37622&status=done&style=none&taskId=u9c1bc59f-ab5a-4eaa-87d4-e42e289448a&title=&width=1552" alt="image.png"><br>不是数据库字段,使我们自己加的.</p><h2 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700232547308-8fe2e403-8645-44db-94e9-45b0899fe658.png#averageHue=%23e9e0e0&clientId=u7b8926cd-a983-4&from=paste&height=1022&id=u357df1e0&originHeight=1022&originWidth=1860&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=321342&status=done&style=none&taskId=uff5dce92-5d94-43c9-ad68-921e086026a&title=&width=1860" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700232637405-256dc518-8c4b-4e8c-b74b-6e6cea1bb3fe.png#averageHue=%23072136&clientId=u7b8926cd-a983-4&from=paste&height=631&id=u4fd4e0b9&originHeight=631&originWidth=1910&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=447275&status=done&style=none&taskId=u64a8ae48-4c76-452d-8bd0-12d7bf2e608&title=&width=1910" alt="image.png"><br>修改代码<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700234060791-0ebd8375-a41f-4e12-bd90-fc92631d084a.png#averageHue=%232c2c2b&clientId=u7b8926cd-a983-4&from=paste&height=1281&id=u4782a1b4&originHeight=1281&originWidth=1511&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=213137&status=done&style=none&taskId=uddafbb8c-4fa0-4209-9c32-52b206e5e6f&title=&width=1511" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLike</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + blog.getId();</span><br><span class="line">       <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">       blog.setIsLike(BooleanUtil.isTrue(score!=<span class="literal">null</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span> ( score == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//3.2 保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">               stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">               stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700236822763-c63a3595-c66d-4c79-8e45-9cc24c3c9a3b.png#averageHue=%23fafafa&clientId=u7b8926cd-a983-4&from=paste&height=619&id=u7e9d0869&originHeight=619&originWidth=1329&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=187179&status=done&style=none&taskId=u2994ebf1-e3c6-4b24-a443-7171bad45eb&title=&width=1329" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700236872571-05c9d8c0-3b3c-45b7-ad7a-b8de86d81275.png#averageHue=%23f9f9f9&clientId=u7b8926cd-a983-4&from=paste&height=663&id=u15fb46a1&originHeight=663&originWidth=1475&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=191782&status=done&style=none&taskId=u5769bd53-1963-4081-b4ce-f7373863462&title=&width=1475" alt="image.png"></p><h1 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h1><h2 id="实现关注和取关功能"><a href="#实现关注和取关功能" class="headerlink" title="实现关注和取关功能"></a>实现关注和取关功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700278801806-7cd17c25-2eeb-48d5-bc32-e9c9d92e8740.png#averageHue=%23f7f7f7&clientId=u239d3de8-271e-4&from=paste&height=694&id=ub93a3038&originHeight=694&originWidth=1438&originalType=binary&ratio=1&rotation=0&showTitle=false&size=364764&status=done&style=none&taskId=u03326a0e-5c7c-4ada-baa1-62aa4cf9bb4&title=&width=1438" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.获取登录用户</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">      <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">      <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">          <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">          <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">          follow.setUserId(userId);</span><br><span class="line">          follow.setFollowUserId(followUserId);</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">          <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">              <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">              stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                  .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">          <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">              <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">              stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Result.ok();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.获取登录用户</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">      <span class="comment">// 3.判断</span></span><br><span class="line">      <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.获取当前用户</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">      <span class="comment">// 2.求交集</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">      Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">      <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// 无交集</span></span><br><span class="line">          <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.解析id集合</span></span><br><span class="line">      List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">      <span class="comment">// 4.查询用户</span></span><br><span class="line">      List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">              .stream()</span><br><span class="line">              .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">              .collect(Collectors.toList());</span><br><span class="line">      <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700278760191-0a31a5e5-4de5-4df2-b30b-d31be97f6836.png#averageHue=%23776141&clientId=u239d3de8-271e-4&from=paste&height=667&id=ub85ab2ae&originHeight=667&originWidth=375&originalType=binary&ratio=1&rotation=0&showTitle=false&size=381847&status=done&style=none&taskId=ub8184d02-201d-4d21-94c8-32944030eec&title=&width=375" alt="image.png"></p><h2 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700280435793-fb72ba40-d4e0-487c-b6dd-0e1da5cf9353.png#averageHue=%23e7e3df&clientId=u239d3de8-271e-4&from=paste&height=814&id=u4629bab6&originHeight=814&originWidth=1639&originalType=binary&ratio=1&rotation=0&showTitle=false&size=689686&status=done&style=none&taskId=ub478a468-8946-482c-980f-60b696f1351&title=&width=1639" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700280752986-320ed5f4-5fcd-4d5f-90b4-edae3dd270a3.png#averageHue=%23faf9f8&clientId=u239d3de8-271e-4&from=paste&height=602&id=u625ec156&originHeight=602&originWidth=1312&originalType=binary&ratio=1&rotation=0&showTitle=false&size=173418&status=done&style=none&taskId=ud6ac5584-1554-4d53-9570-60c92c538cc&title=&width=1312" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700281004775-9773e98c-2e37-47a5-8ee2-60226f75274e.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=257&id=u584f6121&originHeight=257&originWidth=1316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115430&status=done&style=none&taskId=u03405a14-a5d9-4f52-8b77-c63fc0c227f&title=&width=1316" alt="image.png"><br>应该改造以前的关注接口,每次关注一个人, 就存到set集合中, 从而来找共同好友.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700281686178-2beec8e2-4921-4e60-9d1b-3dbead131073.png#averageHue=%23fdfaf9&clientId=u239d3de8-271e-4&from=paste&height=811&id=ufccf59b2&originHeight=811&originWidth=454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47333&status=done&style=none&taskId=u71095f78-67ca-40cd-b547-2198ac7725c&title=&width=454" alt="image.png"></p><h2 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284790050-a87ac7ad-37c8-45a6-a97a-217c7ff84a55.png#averageHue=%23ece1e1&clientId=u239d3de8-271e-4&from=paste&height=747&id=ua6122419&originHeight=747&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204743&status=done&style=none&taskId=u931ebda5-1422-465c-8776-dbe2a8d7d36&title=&width=1562" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284912975-b1b44dcf-fa79-4486-880d-c7e728ec945c.png#averageHue=%23e9e5e3&clientId=u239d3de8-271e-4&from=paste&height=783&id=u630c0be9&originHeight=783&originWidth=1689&originalType=binary&ratio=1&rotation=0&showTitle=false&size=659610&status=done&style=none&taskId=u59cff10f-6c53-4e1f-b2d3-de7c8248ea1&title=&width=1689" alt="image.png"><br>我们的业务<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284953779-20675930-1bba-4136-9abf-0e9e6f7813f7.png#averageHue=%23f6f5f5&clientId=u239d3de8-271e-4&from=paste&height=790&id=u615ca396&originHeight=790&originWidth=1496&originalType=binary&ratio=1&rotation=0&showTitle=false&size=320765&status=done&style=none&taskId=u17e3405f-ece1-4575-a7af-1d81065951a&title=&width=1496" alt="image.png"><br><strong>拉模式</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285079923-6e24b596-9068-4f4d-b758-bb4fdc8a9ac3.png#averageHue=%23fcfcfb&clientId=u239d3de8-271e-4&from=paste&height=774&id=u0e7376e8&originHeight=774&originWidth=1607&originalType=binary&ratio=1&rotation=0&showTitle=false&size=255182&status=done&style=none&taskId=u58815847-18cf-4897-9ae6-49320c7314b&title=&width=1607" alt="image.png"><br><strong>推模式</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285123680-ec4a5326-8214-4684-9f7f-d07dfd246f9c.png#averageHue=%23fcfcfc&clientId=u239d3de8-271e-4&from=paste&height=767&id=u79b63f5c&originHeight=767&originWidth=1409&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210966&status=done&style=none&taskId=u4eb2e920-1149-474e-b179-d9e325fd0dc&title=&width=1409" alt="image.png"><br>缺点是发给每一个粉丝, 内存占用很高.<br><strong>推拉结合</strong><br>粉丝少-&gt; 推模式<br>粉丝多-&gt;拉模式<br>  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285260959-e254c589-1fe5-400f-afd6-32a228e3e27a.png#averageHue=%23fbfafa&clientId=u239d3de8-271e-4&from=paste&height=782&id=u451f38b3&originHeight=782&originWidth=1589&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281607&status=done&style=none&taskId=ud1193503-c2e3-4550-810d-c43aadf42f6&title=&width=1589" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285315021-96ff8b73-54e3-42f3-9887-0d61244668aa.png#averageHue=%23e7dad9&clientId=u239d3de8-271e-4&from=paste&height=730&id=u73c06178&originHeight=730&originWidth=1660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157594&status=done&style=none&taskId=u07bfb312-1ad0-45a1-b5e4-412fb7ed5c0&title=&width=1660" alt="image.png"></p><h2 id="基于推模式实现关注推送功能"><a href="#基于推模式实现关注推送功能" class="headerlink" title="基于推模式实现关注推送功能."></a>基于推模式实现关注推送功能.</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700289493961-b55cfb33-3b8a-405d-be38-74923204e2d3.png#averageHue=%23faf9f8&clientId=u239d3de8-271e-4&from=paste&height=1090&id=ud8164f58&originHeight=1090&originWidth=2163&originalType=binary&ratio=1&rotation=0&showTitle=false&size=333264&status=done&style=none&taskId=u2a2398b4-0278-4287-a678-2513b79acc7&title=&width=2163" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700289532336-17506c65-7a74-48cb-b271-08c0739c424d.png#averageHue=%23f9f8f7&clientId=u239d3de8-271e-4&from=paste&height=1087&id=u4a4bd886&originHeight=1087&originWidth=2072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=327415&status=done&style=none&taskId=ude5e1872-71c9-4418-b3c4-d5c8cfd29c6&title=&width=2072" alt="image.png">不依赖角标<br>使用sorted来实现<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700292674877-9e3a48dc-dc13-4505-97cb-8cfcf6751a35.png#averageHue=%23092437&clientId=u239d3de8-271e-4&from=paste&height=320&id=u451267d9&originHeight=320&originWidth=1975&originalType=binary&ratio=1&rotation=0&showTitle=false&size=291864&status=done&style=none&taskId=u1c4f9e33-201b-4bd7-867f-da34c378449&title=&width=1975" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700292757855-54286e90-8db5-41f3-89c9-15c76cd933dd.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=737&id=q78vy&originHeight=737&originWidth=1517&originalType=binary&ratio=1&rotation=0&showTitle=false&size=294942&status=done&style=none&taskId=u5e677409-2aa1-450e-9671-40371b52f00&title=&width=1517" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293092245-43e5c4b8-a8fe-46d7-afaf-0b17404bbf6c.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=922&id=u174d75a2&originHeight=922&originWidth=1894&originalType=binary&ratio=1&rotation=0&showTitle=false&size=557957&status=done&style=none&taskId=uddb0a0f8-3bb2-438f-9848-7d551401ab4&title=&width=1894" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293221589-5eb005f4-0ebf-4ec2-b7c8-2a1d3360f855.png#averageHue=%23072236&clientId=u239d3de8-271e-4&from=paste&height=782&id=u52f79ff7&originHeight=782&originWidth=1791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=371832&status=done&style=none&taskId=u6e5fdb5a-2bd8-48b4-ab10-5f202986a7c&title=&width=1791" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293348844-fb32c3bb-2876-4750-9c42-707dc06e54ba.png#averageHue=%23052035&clientId=u239d3de8-271e-4&from=paste&height=1040&id=u12dd3b88&originHeight=1040&originWidth=2053&originalType=binary&ratio=1&rotation=0&showTitle=false&size=490628&status=done&style=none&taskId=ubea8abf6-2439-449d-a4d0-b0f686b3281&title=&width=2053" alt="image.png"><br><strong>总结:</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293443441-20ddb32f-62d1-491d-bd6c-99d851ca0791.png#averageHue=%23deddd4&clientId=u239d3de8-271e-4&from=paste&height=647&id=uc2ef59e7&originHeight=647&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=355611&status=done&style=none&taskId=u586e5a50-8e82-4add-91b6-5e05d8f2a31&title=&width=1526" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293509310-beb1b064-aa7f-41ba-90cf-ba42c80b120f.png#averageHue=%23e4dddb&clientId=u239d3de8-271e-4&from=paste&height=1041&id=ubbdd503e&originHeight=1041&originWidth=1632&originalType=binary&ratio=1&rotation=0&showTitle=false&size=725755&status=done&style=none&taskId=u3b34c4e8-a8c0-4436-ac54-688f03597d9&title=&width=1632" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700325372958-8f591a79-b9e9-47e8-a2e4-f609a0375182.png#averageHue=%23f1f6f0&clientId=u239d3de8-271e-4&from=paste&height=1165&id=u12e9f56d&originHeight=1165&originWidth=2085&originalType=binary&ratio=1&rotation=0&showTitle=false&size=702953&status=done&style=none&taskId=ue74b11e5-7449-4ddd-99e2-f08a5278a64&title=&width=2085" alt="image.png"></p><h1 id="附件商铺"><a href="#附件商铺" class="headerlink" title="附件商铺"></a>附件商铺</h1><h2 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363000628-b5dedeca-c042-4f08-90ad-60df5f7522fd.png#averageHue=%23f1f0e6&clientId=u239d3de8-271e-4&from=paste&height=866&id=u3dc15f61&originHeight=866&originWidth=2131&originalType=binary&ratio=1&rotation=0&showTitle=false&size=753135&status=done&style=none&taskId=u0c009a19-cd8a-4a61-92a9-3fa7fbaf3eb&title=&width=2131" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363043045-b3ac121e-24a7-4fd9-b399-9e2f6e3d428e.png#averageHue=%230a2339&clientId=u239d3de8-271e-4&from=paste&height=694&id=u23e1efbc&originHeight=694&originWidth=2258&originalType=binary&ratio=1&rotation=0&showTitle=false&size=495603&status=done&style=none&taskId=ufb3cfff0-c609-4166-b553-fb9ddb9ee3c&title=&width=2258" alt="image.png">·<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363175122-099789de-43e6-4ff0-bb47-877588a426fd.png#averageHue=%23092039&clientId=u239d3de8-271e-4&from=paste&height=490&id=ubc3cbe65&originHeight=490&originWidth=1244&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232721&status=done&style=none&taskId=u23c9cfd6-39d7-43aa-a1c2-dc2dfe8ebb5&title=&width=1244" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363356088-ccb6e01e-68f1-47a9-8a49-05123ba218ca.png#averageHue=%23092039&clientId=u239d3de8-271e-4&from=paste&height=431&id=ud8d9a339&originHeight=431&originWidth=1949&originalType=binary&ratio=1&rotation=0&showTitle=false&size=259143&status=done&style=none&taskId=u6b0822bd-889a-4a4d-9985-905390c20d5&title=&width=1949" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363406537-6ed70eb9-89eb-4c9d-ae10-fb97cf024acb.png#averageHue=%230d233b&clientId=u239d3de8-271e-4&from=paste&height=394&id=u54ff8dd6&originHeight=394&originWidth=1333&originalType=binary&ratio=1&rotation=0&showTitle=false&size=283704&status=done&style=none&taskId=ud95865d6-3368-4985-915b-68f16f143d4&title=&width=1333" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700364076459-65d2dc7c-c5b4-4111-b461-e328bce52977.png#averageHue=%23b9c3b1&clientId=u239d3de8-271e-4&from=paste&height=1075&id=u8c317c0a&originHeight=1075&originWidth=2192&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1077835&status=done&style=none&taskId=u0bf4ad10-69a6-425d-8d77-0cf322fc1e7&title=&width=2192" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700364201359-0875e76e-f0f3-458f-8672-83907bafbb8d.png#averageHue=%23e0e6e7&clientId=u239d3de8-271e-4&from=paste&height=765&id=u3093abbb&originHeight=765&originWidth=1790&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1124022&status=done&style=none&taskId=u0a775965-a9cf-415e-907f-cd528f57d9d&title=&width=1790" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700369316288-66b9818b-eed9-44bc-9335-0b965e51cc11.png#averageHue=%23777777&clientId=u239d3de8-271e-4&from=paste&height=612&id=ud6756531&originHeight=612&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112120&status=done&style=none&taskId=u27a9d1e8-8e9a-4ec4-876a-f129ec4cbfa&title=&width=1613" alt="image.png"></p><h2 id="查找附近商铺功能"><a href="#查找附近商铺功能" class="headerlink" title="查找附近商铺功能"></a>查找附近商铺功能</h2><p>实现数据的导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SpringDataRedis 的 2.3.9 版本并不支持 Redis 6.2 提供的 GEOSEARCH 命令<br>因此我们需要提示其版本，修改自己的 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h1><h2 id="bitmap用法"><a href="#bitmap用法" class="headerlink" title="bitmap用法"></a>bitmap用法</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700379557735-4efe8b5e-0d59-414a-9423-17d6142b3451.png#averageHue=%23f3f1ea&clientId=ud7e70bf7-514d-4&from=paste&height=556&id=u7e3a41c0&originHeight=1112&originWidth=2472&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1044266&status=done&style=none&taskId=u11207de4-f623-425e-bdaa-0c7eda7a48c&title=&width=1236" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380108867-8b8dbe78-bd4c-465f-a3f8-6d9c3af3316e.png#averageHue=%23f8f8f8&clientId=ud7e70bf7-514d-4&from=paste&height=548&id=ude7763cd&originHeight=1096&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=345948&status=done&style=none&taskId=u15b9380d-2591-44d6-ba35-ed98945e2a7&title=&width=1153" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380440914-1de72eab-f672-4c2d-ad95-33b18e248dca.png#averageHue=%23f3f3f3&clientId=ud7e70bf7-514d-4&from=paste&height=462&id=ua8835d34&originHeight=924&originWidth=2134&originalType=binary&ratio=2&rotation=0&showTitle=false&size=567878&status=done&style=none&taskId=u5f675c73-c2aa-4859-98ee-3ed58201b79&title=&width=1067" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380779465-409513e1-6552-4131-8344-55b6b794f10e.png#averageHue=%230a2435&clientId=ud7e70bf7-514d-4&from=paste&height=221&id=ud1a26804&originHeight=442&originWidth=1588&originalType=binary&ratio=2&rotation=0&showTitle=false&size=291832&status=done&style=none&taskId=u69122527-cce5-4409-97ff-314e595fe8d&title=&width=794" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380819411-62c986bb-66ef-4214-8797-eb0e85645e88.png#averageHue=%2310293a&clientId=ud7e70bf7-514d-4&from=paste&height=170&id=u30917650&originHeight=340&originWidth=1920&originalType=binary&ratio=2&rotation=0&showTitle=false&size=238370&status=done&style=none&taskId=u9ab23b8e-4b42-4454-82e6-464bd5d58f6&title=&width=960" alt="image.png"></p><h2 id="实现签到功能"><a href="#实现签到功能" class="headerlink" title="实现签到功能"></a>实现签到功能</h2><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380949589-c9919d6c-a5f2-41a9-b188-d0302c6694e1.png#averageHue=%23f2f2f2&clientId=ud7e70bf7-514d-4&from=paste&height=578&id=u0bf95cbb&originHeight=1156&originWidth=1908&originalType=binary&ratio=2&rotation=0&showTitle=false&size=447500&status=done&style=none&taskId=u9b5261d8-5e1b-4637-9fb9-71a7af9dfb6&title=&width=954" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.获取日期</span></span><br><span class="line">       <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">       <span class="comment">// 3.拼接key</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">       <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">       <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">       stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700399217681-4d4061bc-adb9-4708-add8-bd9d29cf86cc.png#averageHue=%230e283b&clientId=u239d3de8-271e-4&from=paste&height=295&id=u25f36d64&originHeight=295&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102345&status=done&style=none&taskId=u76fe03cb-82dc-4e64-8fe0-1a1a538f72e&title=&width=967" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700400801636-d5f48bdc-ddcb-4bd7-b197-5e9845d50821.png#averageHue=%23f3f3f3&clientId=u239d3de8-271e-4&from=paste&height=447&id=u5833066c&originHeight=447&originWidth=1609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178150&status=done&style=none&taskId=ueef19a98-2e62-4286-a3ac-40a5ba7a3df&title=&width=1609" alt="image.png"><br>举自己的个人博客网站的例子:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700400834771-bf1af00f-3d3f-40ec-ba7b-ee82d8446f49.png#averageHue=%23f7f7f7&clientId=u239d3de8-271e-4&from=paste&height=82&id=u05146455&originHeight=82&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4969&status=done&style=none&taskId=u84d83b80-b749-4862-b015-344bcfa6604&title=&width=360" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700401716213-68550223-ad11-4850-8639-54483a560d74.png#averageHue=%23a9ac9e&clientId=u239d3de8-271e-4&from=paste&height=743&id=ua6f5d2d9&originHeight=743&originWidth=1651&originalType=binary&ratio=1&rotation=0&showTitle=false&size=517952&status=done&style=none&taskId=ua2ba5f5d-23dc-4194-9a48-ec3fd79b420&title=&width=1651" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700402111007-fec55a72-871e-4ccd-90e8-3a29ca73f275.png#averageHue=%230e283b&clientId=u239d3de8-271e-4&from=paste&height=514&id=u39fc541a&originHeight=514&originWidth=1001&originalType=binary&ratio=1&rotation=0&showTitle=false&size=254600&status=done&style=none&taskId=u69394d77-a7d2-4d5e-a8b6-a85c87c5a85&title=&width=1001" alt="image.png"></p><h2 id="实现UV统计"><a href="#实现UV统计" class="headerlink" title="实现UV统计"></a>实现UV统计</h2><p>每一次充满容量为1000的数组发给redis. 不能一次发送100万条数据呀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] values = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        j = i % <span class="number">1000</span>;</span><br><span class="line">        values[j] = <span class="string">&quot;user_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">999</span>)&#123;</span><br><span class="line">            <span class="comment">// 发送到Redis</span></span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;hl2&quot;</span>, values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计数量</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;hl2&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700402938508-b14c9aa3-ca7e-4601-a734-0e8d9ed51826.png#averageHue=%232c2c2b&clientId=u239d3de8-271e-4&from=paste&height=135&id=ub131f0bb&originHeight=135&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5181&status=done&style=none&taskId=u34cce56e-e5ae-4949-91b7-55d0ed80cf9&title=&width=516" alt="image.png"><br>会有一些误差. 问题不大</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;短信登录&quot;&gt;&lt;a href=&quot;#短信登录&quot; class=&quot;headerlink&quot; title=&quot;短信登录&quot;&gt;&lt;/a&gt;短信登录&lt;/h1&gt;&lt;h2 id=&quot;发送验证码&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Redis" scheme="https://axdmdyj.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://axdmdyj.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>数据结构常见面试题（1）</title>
    <link href="https://axdmdyj.github.io/posts/e7c3359a.html"/>
    <id>https://axdmdyj.github.io/posts/e7c3359a.html</id>
    <published>2023-11-11T14:47:19.000Z</published>
    <updated>2023-11-12T08:53:08.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day1-链表"><a href="#day1-链表" class="headerlink" title="day1-链表"></a>day1-链表</h1><ul><li><strong>描述一下链表的数据结构？</strong></li></ul><p>链表是由节点类组成 ,其中包括值, 以及其他节点的引用组成, 通过引用指向 , 串成一个链表.</p><p>链表包含三种类型:  单向链表(每个节点只有指向下一个节点的引用), 双向链表:(有上一个节点和下一个节点的引用),  循环链表(最后一个节点的next引用指向头结点,形成循环结构)</p><ul><li><strong>Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</strong></li></ul><p>LinkedList 使用的是双向链表,</p><ul><li><strong>链表中数据的插入、删除、获取元素，时间复杂度是多少？</strong></li></ul><p>插入和删除的时间复杂度是O(1) , 获取元素的时间复杂度是O(n)</p><ul><li><strong>什么场景下使用链表更合适？</strong></li></ul><p> 在需要频繁的增加或删除节点的场景下使用链表更合适</p><p>不需要预先分配内存大小.</p><p>不需要快速随机访问</p><p>节省内存,   不需要分配连续的内存块.这在内存优先的嵌入式系统或移动设备很有用</p><h1 id="day2-数组"><a href="#day2-数组" class="headerlink" title="day2-数组"></a>day2-数组</h1><ol><li><strong>数据结构中有哪些是线性表数据结构？</strong></li></ol><p>数组: 每个元素都有唯一的索引, 在内存中地址连续</p><p>链表: 动态数据结构, 由节点构成, 每个节点存储着数据和指向下一个节点的引用</p><p>栈: 只有栈顶元素可以被访问, 插入和删除操作都发生在栈顶</p><p>队列: 插入在队尾, 删除在队首</p><ol><li>数<strong>组的元素删除和获取，时间复杂度是多少？</strong></li></ol><p>获取时间复杂度是O(1) </p><p>删除操作时间复杂度也是O(1), 但是删除的元素后面都需要向前移动, 所以平均情况下也是O(n)</p><p>删除是O(n), 获取是O(1)</p><ol><li>A<strong>rrayList 中默认的初始化长度是多少？</strong></li></ol><p>10</p><ol><li><strong>ArrayList 中扩容的范围是多大一次？</strong></li></ol><p><strong>先判断是否需要扩容,</strong> 如果扩容,咋会扩容1.5倍一次</p><ol><li>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什</li></ol><p> <code>System.arraycopy</code> 是 Java 标准库提供的数组拷贝方法:</p><ul><li><code>src</code>：原数组，即要复制的数据源。</li><li><code>srcPos</code>：从原数组的哪个位置开始复制。</li><li><code>dest</code>：目标数组，即复制到的位置。</li><li><code>destPos</code>：从目标数组的哪个位置开始粘贴。</li><li><code>length</code>：要复制的元素数量。</li></ul><p>在 <code>ArrayList</code> 的情境中，<code>src</code> 是原数组，<code>srcPos</code> 是0（从第一个元素开始复制），<code>dest</code> 是新数组，<code>destPos</code> 是0（从第一个位置开始粘贴），<code>length</code> 是原数组中的元素数量。这就完成了原数组元素到新数组的复制操作。</p><p>最后，<code>ArrayList</code> 更新内部的引用，将原数组引用指向新数组，使新数组成为 <code>ArrayList</code> 的内部数组缓冲区。原数组将被垃圾回收。 </p><h1 id="day3-队列"><a href="#day3-队列" class="headerlink" title="day3-队列"></a>day3-队列</h1><p><strong>单端队列和双端队列，分别对应的实现类是哪个？</strong></p><p><strong>单端队列可以有链表(LinkedList)实现或者是</strong><code>**ArrayDeque**</code><strong>类实现, 使用add和remove方法操作</strong></p><p><strong>简述延迟队列&#x2F;优先队列的实现方式以及应用场景?</strong></p><p><strong>延迟队列:</strong> </p><p><strong>实现方式</strong>：延迟队列通常是基于优先队列实现的。在Java中，常用的实现类是<strong>DelayQueue</strong>。它内部使用了一个优先队列（通常是二叉堆）来存储元素，但每个元素都有一个延迟时间，通过延迟时间作为条件排序, 只有当元素的延迟时间到达后，它才能被取出。这是通过元素的<strong>getDelay</strong>方法来实现的。</p><p>优先队列: </p><p><strong>优先队列（Priority Queue）</strong>：</p><ul><li><strong>实现方式</strong>：优先队列可以使用多种数据结构来实现，其中最常见的是二叉堆。在Java中，<strong>PriorityQueue</strong>就是一个二叉堆实现的优先队列。它使用小顶堆（最小元素在队头）或大顶堆（最大元素在队头）来维护元素的优先级顺序。元素的优先级通常由它们的自然顺序（实现<strong>Comparable</strong>接口）或自定义比较器（实现<strong>Comparator</strong>接口）来决定。</li></ul><p><strong>延迟队列和优先队列应用场景?</strong></p><p>延迟队列常用于实现定时任务调度，任务的执行时间可以被设置为延迟时间，从而实现任务的延迟执行。</p><p>优先队列常用于需要按照优先级顺序处理元素的场景，如任务调度、Dijkstra算法等。在任务调度中，任务的优先级可以表示任务的紧急程度或重要性，高优先级任务会先被执行。</p><h1 id="day4-堆栈"><a href="#day4-堆栈" class="headerlink" title="day4-堆栈"></a>day4-堆栈</h1><p><strong>堆栈使用场景?</strong></p><p>需要使用先入后出的数据结构和场景, 比如:递归算法(每次递归,调用相关信息压入堆栈), 浏览器历史, 函数调用等</p><p><strong>为什么不是用 Stack 类？</strong></p><p>Stack十分粗糙并且过时, 效率低下</p><p><strong>ArrayDeque是基于什么实现的?</strong></p><p>基于数组实现的堆栈数据结构</p><p><strong>ArrayDeque 数据结构使用过程叙述。</strong></p><p>ArrayDeque是双端队列, 提供两端插入和弹出的方法, 支持在队头和队尾执行各种操作</p><p><strong>ArrayDeque为什么要初始化2的n次幂个长度</strong></p><p>为了便于无符号取模(2^n - 1) 得到索引, 比一般的取模运算快得多, 减少扩容次数, </p><h1 id="day5-哈希表（散列）"><a href="#day5-哈希表（散列）" class="headerlink" title="day5-哈希表（散列）"></a>day5-哈希表（散列）</h1><ul><li><strong>介绍一下散列表</strong></li></ul><p>散列表是一种数据结构, 基于散列函数, 将键映射到存储值数组的特定位置,  以便在常数时间内进行快速查找, 插入, 删除操作. 通常适用于需要快速查找和插入的情况, 特别是当数据集较大且充足时.</p><ul><li><strong>为什么使用散列表</strong></li></ul><p>能够快速查找和输入, 提供了平均情况O(1)的时间复杂度</p><p>灵活的键-值映射,</p><ul><li><strong>拉链寻址和开放寻址的区别</strong></li></ul><p>拉链寻址中, 每个散列槽(或哈希桶)都存储一个链表, 数组或其他数据结构. 消耗内存</p><p>开放寻址, 所有元素都存储在散列槽中, 如果发生冲突, 查找下一个可用的槽, 直到找到空槽, 或遍历整个散列表. 可能会导致散列表出现堆积, 使得性能下降</p><ul><li><strong>还有其他什么方式可以解决散列哈希索引冲突</strong></li></ul><p>通过合并散列, 杜鹃散列, 跳房子散列,  罗宾汉哈希算法也是可以解决散列哈希索引冲突</p><ul><li>对应的Java源码中，对于哈希索引冲突提供了什么样的解决方案</li></ul><p>通过拉链法, 在冲突位置(索引位置)上, 有一个链表, 将具有相同索引的元素串起来</p><h1 id="day6-堆-Heap"><a href="#day6-堆-Heap" class="headerlink" title="day6-堆 Heap"></a>day6-堆 Heap</h1><ul><li><strong>堆的数据结构是什么样？</strong></li></ul><p>堆是一种特殊的树形结构, 通常是一种完全二叉树. 在堆中, 每个节点都有一个值, 通常从父节点-&gt;子节点 或子节点-&gt;父节点都有一种特定的顺序 </p><ul><li><strong>堆的数据结构使用场景？</strong></li></ul><p>可以实现一种高效的排序算法-&gt;堆排序</p><p>可以用作优先队列, 允许高优先级的快速出队</p><p>可以实现高效的数据结构,比如斐波那契堆</p><ul><li><strong>堆的数据结构实现方式有哪些？</strong></li></ul><p>二叉堆(最小堆和最大堆) , 二顶堆, 后面不了解: 斐波那契堆,左偏树.</p><ul><li><strong>最小堆和最大堆的区别是什么？</strong></li></ul><p><strong>在最小堆中, 根节点的值最小, 每一个父节点的值小于等于子节点</strong></p><p><strong>最大堆则相反</strong></p><ul><li><strong>有了解斐波那契堆吗？</strong></li></ul><p>斐波那契堆是一种多叉堆，通常用于一些高级的图算法和优化问题。与二叉堆不同，斐波那契堆允许节点具有任意数量的子节点，使得合并操作更加高效。斐波那契堆的插入和删除操作通常具有分摊常数时间复杂度。这种堆的一个应用是最小生成树算法Prim和Dijkstra的高效实现。它还在某些离线最小生成树算法中得到了广泛应用。</p><h1 id="day7-字典树Trie"><a href="#day7-字典树Trie" class="headerlink" title="day7-字典树Trie"></a>day7-字典树Trie</h1><ul><li><strong>简述字典树的数据结构</strong></li></ul><p>字典树是一中树型的数据结构, 每个节点包含一个字符, 从根节点开始的路径代表一个字符串. 树的分支代表字符的不同选择.</p><ul><li><strong>叙述你怎么来实现一个字典树</strong></li></ul><p>先创建一个根节点 -&gt; 插入字符串, 从根节点开始, 按照字符串每个字符依次创建节点 . 直到构建整个字符串. 最后的结点标记为字符串的结束</p><ul><li><strong>字典树的实际业务场景举例</strong></li></ul><p>排序、全文搜索、网络搜索引擎、生物信息</p><ul><li><strong>字典树的存入和检索的时间复杂度</strong></li></ul><p>插入O(L)  检索O(L)  L是字符串的长度, 都需要遍历字符串的每个字符</p><ul><li>还有哪些字典树的实现方式</li></ul><p>【<a href="https://en.wikipedia.org/wiki/Suffix_tree">后缀树(opens new window)</a>、<a href="https://en.wikipedia.org/wiki/Hash_trie">哈希树(opens new window)</a>、<a href="https://en.wikipedia.org/wiki/HAT-trie">帽子树(opens new window)</a>】</p><h1 id="day8-二叉树"><a href="#day8-二叉树" class="headerlink" title="day8-二叉树"></a>day8-二叉树</h1><ul><li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li></ul><p>二叉搜索树是一种特殊的属性结构, 每个节点都包含一个值, 左子节点的值小于父节点, 右子节点的值大于父节点. 每一个左子树和右子树同样也是一个二叉搜索树</p><ul><li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li></ul><p>平均情况下, 均为Log(n) 最坏情况下均为O(n)</p><ul><li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li></ul><ol><li>找到要删除的节点，通常找其右子树中最小的节点或左子树中最大的节点，也可以选择前驱节点或后继节点。</li><li>复制该节点的值到要删除的节点。</li><li>删除找到的前驱节点或后继节点，此时它可能只有一个子节点或没有子节点，这是一个递归操作。</li></ol><ul><li><p>二<strong>叉搜索树的节点都包括了哪些信息</strong></p><pre><code>节点值, 左子树, 右子树</code></pre></li><li><p><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></p></li></ul><p>出于性能和平衡的考虑, 红黑树的时间复杂度能够维持在O(logn)范围内</p><p>同时避免了树退化成链表的情况</p><h1 id="day9-AVL"><a href="#day9-AVL" class="headerlink" title="day9-AVL"></a>day9-AVL</h1><ul><li><strong>AVL 树平衡因子怎么计算？</strong></li></ul><p>左子树的高度减去右子树；</p><ul><li><strong>AVL 树左旋操作的目的是什么？</strong></li></ul><p>将一个节点的右子树变为新的根节点，以保持 AVL 树的平衡性。左旋操作用于解决右子树高度过高的情况</p><ul><li><strong>AVL 树左旋操作的流程是什么？</strong></li></ul><ol><li>假设要左旋的节点为 N，它的右子节点为 R。</li><li>将 R 的左子节点变为 N 的右子节点，同时更新 N 的右子节点为 R 的左子节点。</li><li>将 N 的父节点（如果存在）指向 R，以及将 R 的父节点指向 N 的原父节点。</li><li>最后，更新 N 和 R 的高度信息。</li></ol><ul><li><strong>AVL 树什么情况下要左旋+右旋？</strong></li></ul><ol><li>当一个节点的平衡因子为 2，且其左子树的平衡因子为 -1（或者是左子树的平衡因子为 0）时，需要先对左子树进行左旋，再对当前节点进行右旋，以达到平衡。</li><li>当一个节点的平衡因子为 -2，且其右子树的平衡因子为 1（或者是右子树的平衡因子为 0）时，需要先对右子树进行右旋，再对当前节点进行左旋，以达到平衡。</li></ol><ul><li><strong>AVL 树的插入和读取的时间复杂度？</strong></li></ul><p>AVL 树的插入和读取的时间复杂度为 O(log n)，其中 n 表示树中节点的数量。这是因为 AVL 树通过旋转操作来保持平衡，使得树的高度保持在 O(log n) 的水平。因此，插入和读取操作的时间复杂度都是 O(log n)。</p><h1 id="day10-2-3-树"><a href="#day10-2-3-树" class="headerlink" title="day10-2-3-树"></a>day10-2-3-树</h1><ul><li><p><strong>2-3树的数据结构描述</strong></p><ul><li><p>每个节点可以包含 1 个或 2 个元素。</p></li><li><p>如果一个节点包含 1 个元素，它有 2 个子节点。</p></li><li><p>如果一个节点包含 2 个元素，它有 3 个子节点。</p></li></ul></li><li><p>2-3树一个节点最多可以存放几个元素</p></li></ul><p>2个</p><ul><li><strong>2-3树插入节点时间复杂度</strong></li></ul><p>时间复杂度是 O(log n)，其中 n 表示树中节点的数量。</p><ul><li><strong>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></strong></li></ul><p>当一个节点已经包含 3 个元素时，需要进行分裂操作。分裂操作会将这个节点分为两个节点，每个节点包含 1 个元素。分裂操作的过程不需要旋转，而是将中间元素上移，形成一个新的父节点。</p><ul><li><strong>2-3树，你能手写一下吗</strong>？</li></ul><p>以下是一个简单的示例，假设我们要插入元素 7 到一个已经包含元素 4、9 的节点中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before Insertion:</span><br><span class="line">     4 9</span><br><span class="line"></span><br><span class="line">After Insertion:</span><br><span class="line">    4 7 9</span><br></pre></td></tr></table></figure><p>在这个示例中，插入元素 7 后，原节点中的元素 4 和 9 会变成两个独立的节点，中间元素 7 上移，成为它们的新父节点。这就是 2-3树的分裂操作。</p><h1 id="day11-红黑树"><a href="#day11-红黑树" class="headerlink" title="day11-红黑树"></a>day11-红黑树</h1><ul><li><strong>红黑树都有哪些使用场景？</strong></li></ul><ol><li>数据库系统中，用于索引的实现，例如 InnoDB 存储引擎使用 B+树，而 B+树本质上是一种特殊的红黑树。</li><li>在编程语言的编译器和解释器中，用于实现符号表（Symbol Table）。</li><li>在 Java 的集合框架中，TreeMap 和 TreeSet 使用红黑树来实现有序的数据结构。</li></ol><ul><li><strong>相比于BST树，红黑树有什么用途？</strong></li></ul><ol><li>自平衡性：红黑树能够自动维护平衡，确保树的高度保持在较低的水平，因此查找、插入和删除等操作的时间复杂度是 O(log n)。</li><li>有序性：红黑树是有序的数据结构，可以方便地进行范围查询和有序遍历。</li><li>稳定性：插入和删除操作不会导致树的大规模重构，保持了数据的稳定性</li></ol><ul><li><strong>B-树是什么意思，都包括哪些？</strong></li></ul><p>是一种平衡的多路搜索树，通常用于外部存储，例如数据库和文件系统中的索引结构。B-树是一棵多叉树，每个节点可以包含多个子节点。B-树的特点包括：</p><ol><li>所有叶子节点都在同一层，使得每次查询时磁盘 I&#x2F;O 次数保持较低。</li><li>每个节点可以包含多个键值对，不仅仅包含 2 个（如红黑树的节点）。</li></ol><ul><li><strong>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</strong></li></ul><ol><li>当新插入节点是根节点时，需要将该节点染成黑色，以满足红黑树性质。</li><li>当新插入节点的父节点是黑色时，不需要进行任何操作，红黑树性质不受影响。</li><li>当新插入节点的父节点是红色时，需要进行染色和旋转操作，以恢复红黑树性质。</li></ol><p>具体的左旋和左旋+右旋操作会在不满足红黑树性质的情况下进行，以重新平衡树的结构。</p><ul><li><strong>红黑树的特点是什么？</strong></li></ul><p>红黑树的特点包括：</p><ol><li>每个节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL 节点）是黑色。</li><li>如果一个节点是红色，那么它的子节点必须是黑色。</li><li>从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li><li>没有两个相邻的红色节点，即红黑树中不存在连续的红色节点。</li></ol><h1 id="day12-并查集"><a href="#day12-并查集" class="headerlink" title="day12-并查集"></a>day12-并查集</h1><ul><li><strong>并查集叙述？</strong></li></ul><p>并查集（Disjoint-Set Union，DSU）是一种数据结构，用于管理一系列不相交的集合（或称为集合分区）。它支持两种主要操作：查找（Find）和合并（Union）。并查集的主要目标是确定两个元素是否属于同一个集合，以及将两个集合合并为一个集合。</p><ul><li><strong>并查集的使用场景？</strong></li></ul><ol><li>连通性问题：并查集常用于解决网络连通性问题，如判断网络中的设备是否互通。</li><li>图的连通分量：在图论中，它可用于查找图的连通分量。</li><li>集合的合并：在算法和数据结构中，用于合并不相交的集合，例如 Kruskal 算法中用于最小生成树的构建</li></ol><ul><li><strong>并查集怎么合并元素？</strong></li></ul><p>合并元素： 合并两个元素的集合通常是通过将其中一个元素的根节点连接到另一个元素的根节点来实现。</p><ul><li>并查集合并元素的优化策略？</li></ul><ol><li>“Union by Rank”（按秩合并）：将较短的树合并到较高的树上。每个树的节点维护一个秩（或者称为深度），合并时将秩较小的树连接到秩较大的树上，以确保树的高度不会过大。</li><li>“Path Compression”（路径压缩）：在查找根节点时，将遍历过的节点都直接连接到根节点，以减小后续查找操作的时间复杂度。这是通过递归或循环方式实现的。</li></ol><ul><li><strong>如何压缩路径？</strong></li></ul><p>路径压缩是指在查找根节点时，将沿途的节点直接连接到根节点，以减小树的高度，从而提高后续操作的效率。路径压缩可以通过递归或迭代方式实现。</p><p>在路径压缩中，当查找根节点时，会将当前节点的父节点直接更新为根节点。这样，在后续查找操作中，沿途的节点都会指向根节点，从而加速查找操作。</p><h1 id="day13-图"><a href="#day13-图" class="headerlink" title="day13-图"></a>day13-图</h1><ul><li><strong>图的使用场景是什么？</strong></li></ul><ol><li>社交网络：图可用于表示社交网络中的用户和他们之间的关系，如朋友关系、关注关系等。</li><li>地图和导航系统：地图应用可以使用图来表示道路、城市和导航路径，以帮助用户找到最短路径。</li><li>网络拓扑：在计算机网络中，图可用于表示网络拓扑结构，包括路由器、交换机和连接。</li><li>任务调度：图可以表示任务和它们之间的依赖关系，用于任务调度和优化。</li><li>推荐系统：用于生成用户和项目之间的关系图，以提供个性化推荐。</li><li>数据分析：在数据分析中，图可以用于表示数据之间的关系，以进行关联性分析和可视化。</li><li>语义网络：图可用于构建语义网络，用于自然语言处理和知识表示。</li><li>游戏开发：图可用于表示游戏中的地图、任务和角色之间的关系。</li></ol><ul><li><strong>图有的分类？</strong></li></ul><ol><li>有向图（Directed Graph）：图中的边具有方向，表示从一个顶点到另一个顶点的有向关系。</li><li>无向图（Undirected Graph）：图中的边没有方向，表示两个顶点之间的无向关系。</li><li>带权图（Weighted Graph）：图中的边带有权重或成本，表示不同路径的成本。</li><li>有向无环图（DAG，Directed Acyclic Graph）：有向图中不存在形成环的路径。</li><li>连通图（Connected Graph）：无向图中的任意两个顶点之间都存在路径。</li><li>无环图（Acyclic Graph）：图中不存在形成环的路径。</li></ol><ul><li><strong>图怎么存放权重值？</strong></li></ul><p>权重通常存放在图的边上，每条边都可以具有一个权重值，用于表示连接两个顶点之间的成本或距离。在编程中，可以使用邻接矩阵或邻接表等数据结构来存储带权图的权重信息。</p><ul><li><strong>图的广度遍历</strong></li></ul><p>图的广度遍历（Breadth-First Search，BFS）： BFS 是一种用于遍历图的算法，它从起始顶点开始，首先访问起始顶点的所有相邻顶点，然后逐层扩展，依次访问更远的顶点。BFS 可用于查找最短路径、连通性检查和拓扑排序等任务。</p><ul><li><strong>图的深度遍历</strong></li></ul><p>DFS 是一种递归或栈的方式来遍历图的算法，它从起始顶点开始，首先访问一个相邻顶点，然后递归地访问这个相邻顶点的未访问邻居，直到到达最远的顶点，然后回溯并继续遍历其他分支。DFS 可用于查找路径、拓扑排序和连通性检查等任务。</p><h1 id="day14-布隆过滤器"><a href="#day14-布隆过滤器" class="headerlink" title="day14-布隆过滤器"></a>day14-布隆过滤器</h1><ul><li><strong>布隆过滤器的使用场景？</strong></li></ul><ol><li>数据缓存：用于快速检查某个数据是否在缓存中，从而避免查询数据库或磁盘操作。</li><li>防止缓存穿透：用于检查请求的数据是否有效，避免频繁请求不存在的数据。</li><li>网页爬虫去重：用于检查已经爬取的网页 URL，避免重复爬取。</li><li>邮件服务器：用于检查电子邮件地址是否有效，防止垃圾邮件地址。</li><li>数据库查询优化：用于加速数据库查询操作，判断数据是否存在于数据库表中。</li><li>拦截器过滤：用于拦截恶意请求，检查是否在黑名单中。</li></ol><ul><li><strong>布隆过滤器的实现原理和方式？</strong></li></ul><p>布隆过滤器的基本思想是使用多个哈希函数（通常称为哈希算法），将元素映射到位数组（Bit Array）中的多个位上。当检查某个元素是否存在时，计算它的哈希值，然后查看位数组上对应位置的位是否都为1。如果所有哈希值对应的位都为1，说明元素可能存在；如果有一个或多个位为0，说明元素肯定不存在。</p><ul><li><strong>如何提高布隆过滤器的准确性</strong>？</li></ul><p>关于提高布隆过滤器的准确性：</p><ul><li><p>增加哈希函数的数量：使用更多的哈希函数可以减小碰撞的概率，提高准确性。但需要权衡时间和空间开销。</p></li><li><p>动态调整布隆过滤器的大小：根据实际使用情况，动态调整布隆过滤器的大小，以降低误判率。</p></li><li><p><strong>有哪些中哈希计算方式？</strong></p></li></ul><ol><li>哈希函数：应用单一哈希函数，计算元素的哈希值。</li><li>多哈希函数：应用多个哈希函数，计算多个哈希值。</li></ol><ul><li><strong>都有哪些类型的布隆过滤器实现？<em>Google 开源的 Guava 中自带的布隆过滤器、Redis 中的布隆过滤器</em></strong></li></ul><ol><li>基本布隆过滤器：实现基本的布隆过滤器功能，例如判断元素是否存在。</li><li>可动态扩展的布隆过滤器：支持动态添加元素和自动扩展位数组大小，以适应不断变化的数据。</li><li>可序列化的布隆过滤器：支持将布隆过滤器序列化到文件或内存，以便后续加载和使用。</li><li>支持删除操作的布隆过滤器：支持从布隆过滤器中删除元素，通常需要额外的位数组标记删除。</li><li>高级性能布隆过滤器：优化过的布隆过滤器，提供更高的性能和低误判率。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day1-链表&quot;&gt;&lt;a href=&quot;#day1-链表&quot; class=&quot;headerlink&quot; title=&quot;day1-链表&quot;&gt;&lt;/a&gt;day1-链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;描述一下链表的数据结构？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="面试题" scheme="https://axdmdyj.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://axdmdyj.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://axdmdyj.github.io/posts/43a71ae4.html"/>
    <id>https://axdmdyj.github.io/posts/43a71ae4.html</id>
    <published>2023-10-22T08:08:27.000Z</published>
    <updated>2023-11-12T14:07:13.163Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>索引是帮助MySQL高效获取数据的数据结构(有序)</p><p>没有索引查询是这样的: 全表扫描</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697437417364-8d8105ad-4ba4-4eb2-b0a0-03fc4e6df378.png#averageHue=%23f9f6f6&clientId=ub0c7b248-a611-4&from=paste&height=638&id=ub90d0c3e&originHeight=798&originWidth=1706&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=251862&status=done&style=none&taskId=u2d4d25b1-7027-437c-aafe-b5df1e37e57&title=&width=1364.8" alt="image.png"></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697443711444-131662e6-8679-4186-81d6-704ff0f51eb0.png#averageHue=%23f6f5f5&clientId=u6b1bb508-8493-4&from=paste&height=607&id=YodY8&originHeight=759&originWidth=1586&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=315620&status=done&style=none&taskId=uc461ed19-3335-4486-8589-13a86d5c098&title=&width=1268.8" alt="image.png"></p><ul><li>绿色数据只起到索引数据的作用 , 不存储数据</li><li>叶子节点串成链表 , 是数据存储部分.</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697443984864-4a477896-bd36-455e-a407-60c101a7f555.png#averageHue=%23dce7d6&clientId=u6b1bb508-8493-4&from=paste&height=339&id=ufbcb7e46&originHeight=424&originWidth=945&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=126447&status=done&style=none&taskId=u35e5ae07-56f3-4338-9f05-a190c9755f6&title=&width=756" alt="image.png"></li><li>与B-Tree区别 :  所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p> MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697444276488-09120785-2657-42a9-9925-53d0619f68dc.png#averageHue=%23f2ede8&clientId=u6b1bb508-8493-4&from=paste&height=416&id=uf5f45247&originHeight=520&originWidth=1539&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=294290&status=done&style=none&taskId=u70b1d1d8-f04c-4974-a9cb-6651592ba68&title=&width=1231.2" alt="image.png"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>通过hash算法, 将键值映射为新的值 &#x3D; &gt;映射到对应的槽位上&#x3D;&gt; 然后存储在Hash表中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697444572450-4aea757f-86e2-4c8d-b744-e862765069e8.png#averageHue=%23f5efe5&clientId=u6b1bb508-8493-4&from=paste&height=434&id=u666020a6&originHeight=542&originWidth=1534&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=302505&status=done&style=none&taskId=uc9ab2e99-548b-4af5-8445-3cfde6fc46a&title=&width=1227.2" alt="image.png"><br> 特点<br>A. Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）<br>B. 无法利用索引完成排序操作<br>C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引 </p><p>3). 存储引擎支持 在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。  </p><blockquote><p>为什么InnoDB选择B+Tree<br>A. 相对于二叉树，层级更少，搜索效率高；<br>B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；<br>C. 相对Hash索引，B+tree支持范围匹配及排序操作；  </p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697444999652-117b0c26-7038-4de0-a5e2-dfd093facf5d.png#averageHue=%23e7cfcc&clientId=u6b1bb508-8493-4&from=paste&height=446&id=u93f416de&originHeight=558&originWidth=1523&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=183134&status=done&style=none&taskId=ub6850173-1ad3-48a6-9ccc-de53b929adb&title=&width=1218.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697445141094-0a4c3eea-9f99-4b1c-ba8e-8a77fce822b1.png#averageHue=%23eddddb&clientId=u6b1bb508-8493-4&from=paste&height=553&id=u299359e6&originHeight=691&originWidth=1576&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=275391&status=done&style=none&taskId=u2b520549-168f-40a4-8949-7f94b9c0377&title=&width=1260.8" alt="image.png"></p><h3 id="聚集索引-只记录行数据"><a href="#聚集索引-只记录行数据" class="headerlink" title="聚集索引,  只记录行数据"></a>聚集索引,  只记录行数据<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697445628081-f59bedaf-446b-46dc-8af8-18daa0581c47.png#averageHue=%23f0eeee&clientId=u5e2abf71-e359-4&from=paste&height=618&id=ua1c3d749&originHeight=773&originWidth=1693&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=281978&status=done&style=none&taskId=ub8ca1228-49d6-48af-b5bd-6b3e5d18ec6&title=&width=1354.4" alt="image.png"></h3><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697445734692-3c072d16-a075-43e4-aeb4-fb5c5fb793bc.png#averageHue=%23e8dec1&clientId=u5e2abf71-e359-4&from=paste&height=338&id=ub114f59e&originHeight=423&originWidth=1555&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=238492&status=done&style=none&taskId=u9163f980-7b39-449b-9c9d-3c4cde08702&title=&width=1244" alt="image.png"><br>挂的是对应的ID<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697448926127-7b8a1baa-0c36-4505-a446-a1a2d4183fe5.png#averageHue=%23f4f2f0&clientId=ubdf98a65-1189-4&from=paste&height=672&id=ucfb9eb53&originHeight=840&originWidth=1715&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=352181&status=done&style=none&taskId=u7610ec8c-e0a3-4fd7-9c06-37dd88bd595&title=&width=1372" alt="image.png">二级索引先比较首字母字典序, 然后类似于二叉搜索树的方式, 找到Arm, 然后找到Arm对应的ID, 然后通过聚集索引 , 找到对应的行数据 </p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697449229318-a68abfbe-30c7-49d2-83ca-935eb47afa30.png#averageHue=%23fbf8eb&clientId=ubdf98a65-1189-4&from=paste&height=322&id=u50a3c153&originHeight=403&originWidth=985&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108846&status=done&style=none&taskId=ufd1af7a9-40ce-44b7-aa91-f4cdff3b9d7&title=&width=788" alt="image.png"><br>根据id查询效率高, 因为根据name查询还需要再回表查询一次<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697449696009-901f1fe7-ed3e-4f1e-84da-1395db31827b.png#averageHue=%23f8f5f3&clientId=u620327ff-a504-4&from=paste&height=686&id=u21c71159&originHeight=858&originWidth=1075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=332973&status=done&style=none&taskId=u47212048-dffd-4257-9714-bdc195dd13c&title=&width=860" alt="image.png"></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697513868605-78d440ee-778b-4e80-8107-59531f751bcf.png#averageHue=%23fcfbf4&clientId=uc6163d93-4653-4&from=paste&height=448&id=u63cf337a&originHeight=560&originWidth=1651&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=127224&status=done&style=none&taskId=ud8bcd8da-569d-49d4-9e87-9759427d1f7&title=&width=1320.8" alt="image.png"><br><code>table_name</code>索引关联的表名</p><h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="主要优化查询语句"><a href="#主要优化查询语句" class="headerlink" title="主要优化查询语句"></a>主要优化查询语句</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697514779029-a166174a-9d80-483d-bfbf-a14d53141ca0.png#averageHue=%23c8cec2&clientId=uc6163d93-4653-4&from=paste&height=618&id=u69ab3ef6&originHeight=773&originWidth=1623&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=410883&status=done&style=none&taskId=u3191e591-9069-4bdc-9bcf-584fdb9176c&title=&width=1298.4" alt="image.png"><br>根据具体情况来优化<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697514735225-5f6ba41b-d78c-48fe-8e63-3ac304599545.png#averageHue=%23f8f7ef&clientId=uc6163d93-4653-4&from=paste&height=546&id=u9edf7543&originHeight=683&originWidth=1560&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=268391&status=done&style=none&taskId=ubad0e591-fff0-4612-a033-1129260e42b&title=&width=1248" alt="image.png"></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志:"></a>慢查询日志:</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697514995074-cd4ae302-2472-445d-9768-317a0be604ba.png#averageHue=%23223c52&clientId=uc6163d93-4653-4&from=paste&height=162&id=uf6378d7f&originHeight=202&originWidth=832&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137570&status=done&style=none&taskId=ucfe5611c-a82b-4137-a319-3a8c5646f92&title=&width=665.6" alt="image.png"></p><ul><li>profile详情</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525427978-61a7ad86-a089-4cda-aa0a-ddba0fa3179b.png#averageHue=%23f8f7f4&clientId=uc6163d93-4653-4&from=paste&height=303&id=uf5129e08&originHeight=379&originWidth=1585&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=111939&status=done&style=none&taskId=u4650e16b-d288-4a96-9c2a-881950ca6b8&title=&width=1268" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525688275-e50b74c6-0b07-469f-9243-99c1338efc5c.png#averageHue=%2328465e&clientId=uc6163d93-4653-4&from=paste&height=465&id=ucba8e3c8&originHeight=581&originWidth=876&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=486349&status=done&style=none&taskId=uc8ef2d5d-f666-4158-adf5-df76f24b3a8&title=&width=700.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525715668-cf6877f2-72d2-450b-8d82-c4b3f72d3119.png#averageHue=%23fbfae9&clientId=uc6163d93-4653-4&from=paste&height=471&id=uc89509c3&originHeight=589&originWidth=1389&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=168075&status=done&style=none&taskId=uca4f44fe-f87a-44bd-8db3-45ce8673918&title=&width=1111.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525753543-26688226-f0bd-4746-956b-dba5f4baa23d.png#averageHue=%23254258&clientId=uc6163d93-4653-4&from=paste&height=544&id=u70540ae7&originHeight=680&originWidth=575&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=380080&status=done&style=none&taskId=uc0028d62-081a-4459-abe3-0356904aea6&title=&width=460" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525764568-3d3c8fb1-4737-4e6d-b42f-e8dee43c9455.png#averageHue=%2327455c&clientId=uc6163d93-4653-4&from=paste&height=557&id=u28a38675&originHeight=696&originWidth=876&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=666156&status=done&style=none&taskId=u8bf66c3c-c74b-4126-85f3-1c0284a425b&title=&width=700.8" alt="image.png"></p><h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p><code>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;</code><br>执行计划各字段的含义:<br><strong>id: 表示操作表的顺序, 如果id相同, 从上往下执行, 不同, 越大越先执行</strong><br>多对多, 需要一张关联表<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697853987915-09ad0eb6-7f58-4dde-bb64-e421ffb41f9a.png#averageHue=%23fbfbfa&clientId=u25ea9246-9b61-4&from=paste&height=552&id=ub81b8e17&originHeight=552&originWidth=1288&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148675&status=done&style=none&taskId=u94c689df-5d8f-4a8c-8c02-4ec4f165535&title=&width=1288" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697854069854-b84728f3-faa5-4367-b963-ad2c0b28c498.png#averageHue=%23254157&clientId=u25ea9246-9b61-4&from=paste&height=539&id=ude6c43a3&originHeight=539&originWidth=2547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=757435&status=done&style=none&taskId=u774ba924-6b8a-4ecd-8947-acca5dfeb66&title=&width=2547" alt="image.png"><br>执行顺序 - &gt; s &gt; sc &gt; c :  原因: s 和 c表直接没有关系, 是通过中间表来联系起来的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697854395110-40a3aa0d-6551-4798-bc3e-29fcef50a0ee.png#averageHue=%2329465d&clientId=u25ea9246-9b61-4&from=paste&height=1283&id=u682b7bf4&originHeight=1283&originWidth=2439&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1037047&status=done&style=none&taskId=u1c0f3f94-f5e3-4b4c-8869-453cbe771ba&title=&width=2439" alt="image.png"><br><strong>id值越大越先被执行</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697854530990-d90f1c28-8a03-48f5-b5c5-a722c6e5d64d.png#averageHue=%23243e54&clientId=u25ea9246-9b61-4&from=paste&height=445&id=u26b59710&originHeight=445&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=750365&status=done&style=none&taskId=u1b789646-7da8-4eba-a336-d2d837505b7&title=&width=2488" alt="image.png"><br>**type:  表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。  **<br>使用主键或者唯一索引,则为const  ,  非唯一性索引,ref<br>优化的时候尽量往前优化<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697855001399-cf48d894-c0b4-4c50-b888-c3d42cd25701.png#averageHue=%232d4d65&clientId=u25ea9246-9b61-4&from=paste&height=301&id=u590f66a9&originHeight=301&originWidth=1964&originalType=binary&ratio=1&rotation=0&showTitle=false&size=419333&status=done&style=none&taskId=u1e57cc80-5941-4b74-aaa4-1277eda09e0&title=&width=1964" alt="image.png"> possible_key 显示可能应用在这张表上的索引，一个或多个。<br> key 实际使用的索引，如果为NULL，则没有使用索引。<br> key_len 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。<br> filtered 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。  </p><h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="验证索引对查询效率提升"><a href="#验证索引对查询效率提升" class="headerlink" title="验证索引对查询效率提升"></a>验证索引对查询效率提升</h3><p>主键默认有主键索引,所以通过id查, 一般性能都很高<br>创建索引的过程会构建b+树的结构, 通过创建索引, 来提升其他字段的性能(提升的效率很大)<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697856551655-d3850b96-3080-46bc-87bb-0bef50105c55.png#averageHue=%232c4c63&clientId=ub7edcc15-1ad4-4&from=paste&height=175&id=u92a725f1&originHeight=175&originWidth=875&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118021&status=done&style=none&taskId=uf068183e-18bc-4194-8e35-760ce890edc&title=&width=875" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697856610898-70a3d29d-589f-4fcd-883f-5104aa4b9ff0.png#averageHue=%23faf9f4&clientId=ub7edcc15-1ad4-4&from=paste&height=946&id=u5849e0b6&originHeight=946&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=272654&status=done&style=none&taskId=u5c08f6f7-389a-475a-9c7a-7163defd7fb&title=&width=1188" alt="image.png"></p><h3 id="索引的使用规则"><a href="#索引的使用规则" class="headerlink" title="索引的使用规则"></a>索引的使用规则</h3><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul><li>最左前缀法则</li></ul><p>查询从索引的左列开始, 如果跳过了某一列, 索引将部分失效(后面的字段索引失效)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697879994898-42362556-c8bf-4c70-8ebb-570e6ad68a1c.png#averageHue=%2326435a&clientId=u685b6605-3101-4&from=paste&height=566&id=uc5265242&originHeight=566&originWidth=2250&originalType=binary&ratio=1&rotation=0&showTitle=false&size=574262&status=done&style=none&taskId=u942da6ce-8769-4699-83c1-a04e627aeb8&title=&width=2250" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880275790-bdbdef21-33bf-443e-9dd3-ba205d998ca8.png#averageHue=%2327445b&clientId=u685b6605-3101-4&from=paste&height=1110&id=u9d924d78&originHeight=1110&originWidth=2198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1381450&status=done&style=none&taskId=u7eb565c5-5364-4d7d-a0fa-4fbd11dd2c8&title=&width=2198" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880380063-e1ce9437-142c-4faf-85ce-257b6e94c995.png#averageHue=%2321384d&clientId=u685b6605-3101-4&from=paste&height=333&id=ueaee8639&originHeight=333&originWidth=2323&originalType=binary&ratio=1&rotation=0&showTitle=false&size=475688&status=done&style=none&taskId=u487a36a8-d919-4265-a713-db42f749e84&title=&width=2323" alt="image.png"></p><ul><li>范围查询</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880643880-701eae3c-50ac-4687-ac54-21c397f737a7.png#averageHue=%232b4b62&clientId=u685b6605-3101-4&from=paste&height=501&id=u2116031c&originHeight=501&originWidth=2330&originalType=binary&ratio=1&rotation=0&showTitle=false&size=580087&status=done&style=none&taskId=ufe65903b-5b4c-4b3d-80dd-34e07b5eb9d&title=&width=2330" alt="image.png"></p><ul><li>列运算</li></ul><p>在索引列上进行列运算失效<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880915008-cee11519-63c4-4ee8-8ec2-1dd34f2acca4.png#averageHue=%2327445b&clientId=u17655d80-6043-4&from=paste&height=1017&id=u05e57083&originHeight=1017&originWidth=2233&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1277150&status=done&style=none&taskId=uc7f1a9ff-2d92-4abf-a3f2-46153d73812&title=&width=2233" alt="image.png"></p><ul><li>字符串不加引号, 索引也将会失效</li><li>模糊查询失效</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697881172670-01c93ada-42b2-4f9a-87e3-e0cb25bcd2be.png#averageHue=%23faf9ec&clientId=u17655d80-6043-4&from=paste&height=477&id=u95498bd0&originHeight=477&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236774&status=done&style=none&taskId=ua7267f2c-b7d8-4764-9e0d-14496901b88&title=&width=1469" alt="image.png"></p><ul><li>or连接</li></ul><p>如果or连接一侧有索引 一侧 没有索引, 那么两个字段的索引将都会失效</p><ul><li>数据分布影响</li></ul><p>当需要查询的数据满足绝大部分, 就可能不走索引,直接全表扫描<br>如果很稀少, 夸张一点, 10086个人中查询一个人 ,  就需要用索引来提高查询效率</p><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697882026874-381e6707-8395-49f9-86ff-5a7040dea5d0.png#averageHue=%23fbfaf3&clientId=u17655d80-6043-4&from=paste&height=854&id=ud711b89c&originHeight=854&originWidth=2051&originalType=binary&ratio=1&rotation=0&showTitle=false&size=362308&status=done&style=none&taskId=uc455ca61-757f-4be1-8ced-fb754a98287&title=&width=2051" alt="image.png"><br>use index是一个建议, 建议数据库用哪个索引<br><code>force</code>是强制数据库用哪个索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697957985982-211eeb29-dfa6-49bb-9bbc-49427ea642dc.png#averageHue=%23f6eee8&clientId=uea2f1f1a-6e6d-4&from=paste&height=1109&id=u5149ec54&originHeight=1109&originWidth=2282&originalType=binary&ratio=1&rotation=0&showTitle=false&size=520759&status=done&style=none&taskId=ud658fdf5-5930-4cb5-92c1-bce81a44a5f&title=&width=2282" alt="image.png"><br><strong>思考:</strong><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697958171025-b1f59855-435b-403a-857b-6a913d30a3e0.png#averageHue=%23f8f8f6&clientId=uea2f1f1a-6e6d-4&from=paste&height=536&id=uacb71684&originHeight=536&originWidth=1372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175796&status=done&style=none&taskId=u60ee8599-b196-4987-9cf9-e2658d6b4a0&title=&width=1372" alt="image.png"><br>如果通过查找<code>username</code>, 但没有password字段, 需要进行回表查询效率降低, 效率提升的办法就是将<code>username</code>和 <code>password</code>建立一个联合索引.<br>注意最左匹配原则<br><a href="https://zhuanlan.zhihu.com/p/115778804">面试官:谈谈你对mysql联合索引的认识?</a></p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p><strong>为什么使用前缀索引?</strong><br>当字段过于庞大, 创建字段索引, 会出现浪费大量磁盘IO的情况<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697959021633-4d6e5da6-fe0c-431b-843c-e717f7caa976.png#averageHue=%232c4f67&clientId=uea2f1f1a-6e6d-4&from=paste&height=682&id=u36ba95e4&originHeight=682&originWidth=1633&originalType=binary&ratio=1&rotation=0&showTitle=false&size=518215&status=done&style=none&taskId=udd25767d-8cd7-4226-aa43-1decf1d5288&title=&width=1633" alt="image.png"><br><strong>解决</strong><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697959302180-b04133e2-091a-4aa0-b27d-fa93ba40c6e2.png#averageHue=%23f8f8f2&clientId=uea2f1f1a-6e6d-4&from=paste&height=918&id=u4788766e&originHeight=918&originWidth=2169&originalType=binary&ratio=1&rotation=0&showTitle=false&size=399957&status=done&style=none&taskId=u301a5bb3-7e6b-476b-9405-1d68d6bd9de&title=&width=2169" alt="image.png"><br><strong>前缀索引理解</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697959532132-45b9741c-0fb3-4a90-8c45-8ee0c58c7e22.png#averageHue=%23faf4f1&clientId=uea2f1f1a-6e6d-4&from=paste&height=1035&id=uf12f9ee0&originHeight=1035&originWidth=2147&originalType=binary&ratio=1&rotation=0&showTitle=false&size=666032&status=done&style=none&taskId=u4a6aedd1-3293-4108-92cc-b45bfdb7d62&title=&width=2147" alt="image.png"></p><h4 id="单列索引-联合索引"><a href="#单列索引-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p><strong>单列索引:</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961112156-fdba0645-2e31-4a81-8317-86ce6e883a4e.png#averageHue=%232c4f67&clientId=uea2f1f1a-6e6d-4&from=paste&height=361&id=u75b42efc&originHeight=361&originWidth=1467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246535&status=done&style=none&taskId=uab69ea71-c91c-4540-83b7-984dbff661f&title=&width=1467" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961275207-91793406-bb71-49c0-8458-34fcef0d64c9.png#averageHue=%23f7b2a8&clientId=uea2f1f1a-6e6d-4&from=paste&height=65&id=u3b7ac2ad&originHeight=65&originWidth=1504&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107495&status=done&style=none&taskId=uc7d01b3a-fd34-44ac-9882-a0fbcedb6f9&title=&width=1504" alt="image.png"><br><strong>联合索引</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961242787-5872fb46-3ff3-42f7-b383-6b295f095349.png#averageHue=%2327445b&clientId=uea2f1f1a-6e6d-4&from=paste&height=1103&id=uaac3630b&originHeight=1103&originWidth=2497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1615661&status=done&style=none&taskId=u593cca6d-2e38-4451-b521-0cd8ceb0427&title=&width=2497" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961369813-9cdad172-da8a-421b-8660-d3cea4f6cecd.png#averageHue=%23faf4ef&clientId=uea2f1f1a-6e6d-4&from=paste&height=869&id=u09631a09&originHeight=869&originWidth=2099&originalType=binary&ratio=1&rotation=0&showTitle=false&size=506370&status=done&style=none&taskId=u0f79300d-8f37-43c9-9f27-06c651a419c&title=&width=2099" alt="image.png"><br>对于phone和name的顺序也是要考虑的</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961597390-c4c56736-64c5-466f-94f4-8310b9c67a3a.png#averageHue=%23f7f6f6&clientId=uea2f1f1a-6e6d-4&from=paste&height=939&id=ub06dcec8&originHeight=939&originWidth=2138&originalType=binary&ratio=1&rotation=0&showTitle=false&size=505716&status=done&style=none&taskId=ub7440d06-ea8c-47ce-a420-3817cd3ca9b&title=&width=2138" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961756225-f626ce84-e6bf-4183-a086-9a996e2f61f8.png#averageHue=%23fcfbf1&clientId=uea2f1f1a-6e6d-4&from=paste&height=1058&id=uc47b7fe4&originHeight=1058&originWidth=1223&originalType=binary&ratio=1&rotation=0&showTitle=false&size=279613&status=done&style=none&taskId=u00913f09-d35d-4cb5-b541-e33bf5a853f&title=&width=1223" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://axdmdyj.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://axdmdyj.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="https://axdmdyj.github.io/posts/ae0f95e0.html"/>
    <id>https://axdmdyj.github.io/posts/ae0f95e0.html</id>
    <published>2023-10-14T17:09:13.000Z</published>
    <updated>2023-11-21T06:50:38.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E4%B8%80SpringMVC%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%93%E9%AA%8C">一、SpringMVC简介和体验</a><ul><li><a href="#11-%E4%BB%8B%E7%BB%8D">1.1 介绍</a></li><li><a href="#12-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8">1.2 主要作用</a></li><li><a href="#13-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3">1.3 核心组件和调用流程理解</a></li><li><a href="#14-%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C">1.4 快速体验</a></li></ul></li><li><a href="#%E4%BA%8CSpringMVC%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE">二、SpringMVC接收数据</a><ul><li><a href="#21-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE">2.1 访问路径设置</a></li><li><a href="#22-%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E9%87%8D%E7%82%B9">2.2 接收参数（重点）</a><ul><li><a href="#221-param-%E5%92%8C-json%E5%8F%82%E6%95%B0%E6%AF%94%E8%BE%83">2.2.1 param 和 json参数比较</a></li><li><a href="#222-param%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.2.2 param参数接收</a></li><li><a href="#223-%E8%B7%AF%E5%BE%84-%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.2.3 路径 参数接收</a></li><li><a href="#224-json%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.2.4 json参数接收</a></li></ul></li><li><a href="#23-%E6%8E%A5%E6%94%B6Cookie%E6%95%B0%E6%8D%AE">2.3 接收Cookie数据</a></li><li><a href="#24-%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%95%B0%E6%8D%AE">2.4 接收请求头数据</a></li><li><a href="#25-%E5%8E%9F%E7%94%9FApi%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">2.5 原生Api对象操作</a></li><li><a href="#26-%E5%85%B1%E4%BA%AB%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">2.6 共享域对象操作</a><ul><li><a href="#261-%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9B%9E%E9%A1%BE">2.6.1 属性（共享）域作用回顾</a></li><li><a href="#262-Request%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">2.6.2 Request级别属性（共享）域</a></li><li><a href="#263-Session%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">2.6.3 Session级别属性（共享）域</a></li><li><a href="#264-Application%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">2.6.4 Application级别属性（共享）域</a></li></ul></li></ul></li><li><a href="#%E4%B8%89SpringMVC%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE">三、SpringMVC响应数据</a><ul><li><a href="#31-handler%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">3.1 handler方法分析</a></li><li><a href="#32-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6">3.2 页面跳转控制</a><ul><li><a href="#321-%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9E%E6%A8%A1%E6%9D%BF%E8%A7%86%E5%9B%BE">3.2.1 快速返回模板视图</a></li><li><a href="#322-%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91">3.2.2 转发和重定向</a></li></ul></li><li><a href="#33-%E8%BF%94%E5%9B%9EJSON%E6%95%B0%E6%8D%AE%E9%87%8D%E7%82%B9">3.3 返回JSON数据（重点）</a><ul><li><a href="#331-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87">3.3.1 前置准备</a></li><li><a href="#332-ResponseBody">3.3.2 @ResponseBody</a></li><li><a href="#333-RestController">3.3.3 @RestController</a></li></ul></li><li><a href="#34-%E8%BF%94%E5%9B%9E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86">3.4 返回静态资源处理</a></li></ul></li><li><a href="#%E5%9B%9BRESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E6%88%98">四、RESTFul风格设计和实战</a><ul><li><a href="#41-RESTFul%E9%A3%8E%E6%A0%BC%E6%A6%82%E8%BF%B0">4.1 RESTFul风格概述</a><ul><li><a href="#411-RESTFul%E9%A3%8E%E6%A0%BC%E7%AE%80%E4%BB%8B">4.1.1 RESTFul风格简介</a></li><li><a href="#412-RESTFul%E9%A3%8E%E6%A0%BC%E7%89%B9%E7%82%B9">4.1.2 RESTFul风格特点</a></li><li><a href="#413-RESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">4.1.3 RESTFul风格设计规范</a></li><li><a href="#414-RESTFul%E9%A3%8E%E6%A0%BC%E5%A5%BD%E5%A4%84">4.1.4 RESTFul风格好处</a></li></ul></li><li><a href="#42-RESTFul%E9%A3%8E%E6%A0%BC%E5%AE%9E%E6%88%98">4.2 RESTFul风格实战</a><ul><li><a href="#421-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">4.2.1 需求分析</a></li><li><a href="#422-RESTFul%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1">4.2.2 RESTFul风格接口设计</a></li><li><a href="#423-%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">4.2.3 后台接口实现</a></li></ul></li></ul></li><li><a href="#%E4%BA%94SpringMVC%E5%85%B6%E4%BB%96%E6%89%A9%E5%B1%95">五、SpringMVC其他扩展</a><ul><li><a href="#51-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">5.1 全局异常处理机制</a><ul><li><a href="#511-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">5.1.1 异常处理两种方式</a></li><li><a href="#512-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">5.1.2 基于注解异常声明异常处理</a></li></ul></li><li><a href="#52-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8">5.2 拦截器使用</a><ul><li><a href="#521-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A6%82%E5%BF%B5">5.2.1 拦截器概念</a></li><li><a href="#522-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8">5.2.2 拦截器使用</a></li></ul></li><li><a href="#53-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">5.3 参数校验</a></li></ul></li><li><a href="#%E5%85%ADSpringMVC%E6%80%BB%E7%BB%93">六、SpringMVC总结</a></li></ul><h2 id="一、SpringMVC简介和体验"><a href="#一、SpringMVC简介和体验" class="headerlink" title="一、SpringMVC简介和体验"></a>一、SpringMVC简介和体验</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">https://docs.spring.io/spring-framework/reference/web/webmvc.html</a></p><p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ <code>spring-webmvc</code> ），但它通常被称为“Spring MVC”。</p><p>在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的<strong>首选方案</strong>。之所以能做到这一点，是因为SpringMVC具备如下显著优势：</p><ul><li><strong>Spring 家族原生产品</strong>，与IOC容器等基础设施无缝对接</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><p>原生Servlet API开发代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">                                                        <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于SpringMVC开发代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(&quot;userName&quot;)</span> String userName,Sting password)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">    <span class="comment">//调用业务即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-主要作用"><a href="#1-2-主要作用" class="headerlink" title="1.2 主要作用"></a>1.2 主要作用</h3><p><img src="/../../../ProTool/img/img1/202310150052058.png"></p><p>SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！</p><p>SpringMVC的作用主要覆盖的是表述层，例如：</p><ul><li>请求映射</li><li>数据输入</li><li>视图界面</li><li>请求分发</li><li>表单回显</li><li>会话控制</li><li>过滤拦截</li><li>异步交互</li><li>文件上传</li><li>文件下载</li><li>数据校验</li><li>类型转换</li><li>等等等</li></ul><p><strong>最终总结：</strong></p><ol><li>简化前端参数接收( 形参列表 )</li><li>简化后端数据响应(返回值)</li><li>以及其他……</li></ol><h3 id="1-3-核心组件和调用流程理解"><a href="#1-3-核心组件和调用流程理解" class="headerlink" title="1.3 核心组件和调用流程理解"></a>1.3 核心组件和调用流程理解</h3><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><strong>SpringMVC处理请求流程：</strong></p><p><img src="/../../../ProTool/img/img1/image_tmdw8dA_0q.png"></p><p><strong>SpringMVC涉及组件理解：</strong></p><ol><li>DispatcherServlet :  SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ]</li><li>HandlerMapping :  SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]</li><li>HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]</li><li>Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]</li><li>ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]</li></ol><h3 id="1-4-快速体验"><a href="#1-4-快速体验" class="headerlink" title="1.4 快速体验"></a>1.4 快速体验</h3><ol><li><p>体验场景需求</p><p><img src="/../../../ProTool/img/img1/image_JrHCHOxu_n.png"></p></li><li><p>配置分析</p><ol><li>DispatcherServlet，设置处理所有请求！</li><li>HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！</li><li>Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！</li></ol></li><li><p>准备项目</p><ol><li><p>创建项目</p><p>springmvc-base-quick</p><p>注意：需要转成maven&#x2F;web程序！！</p></li><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.api</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">servlet.api</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springioc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- web相关依赖  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用</span></span><br><span class="line"><span class="comment">         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’</span></span><br><span class="line"><span class="comment">         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的</span></span><br><span class="line"><span class="comment">         Servlet API，没有更新到 Jakarta EE 规范。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.api&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- springwebmvc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Controller声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler就是controller内部的具体方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestMapping</span>(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ResponseBody</span> 代表向浏览器直接返回数据!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/springmvc/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloController.hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello springmvc!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Spring MVC核心组件配置类</p><blockquote><p>声明springmvc涉及组件信息的配置类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>     </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerMapping <span class="title function_">handlerMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SpringMVC环境搭建</p><blockquote><p>对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> getServletMappings 返回的地址 设置DispatherServlet对应处理的地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定service / mapper层的配置类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定springmvc的配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置dispatcherServlet的处理路径!</span></span><br><span class="line"><span class="comment">   * 一般情况下为 / 代表处理所有请求!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动测试</p><p>注意： tomcat应该是10+版本！方可支持 Jakarta EE API!</p><p><img src="/../../../ProTool/img/img1/image_196iViHp_T.png"></p></li></ol><h2 id="二、SpringMVC接收数据"><a href="#二、SpringMVC接收数据" class="headerlink" title="二、SpringMVC接收数据"></a>二、SpringMVC接收数据</h2><h3 id="2-1-访问路径设置"><a href="#2-1-访问路径设置" class="headerlink" title="2.1 访问路径设置"></a>2.1 访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><ol><li><p><strong>精准路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>模糊路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/*  </span></span><br><span class="line"><span class="comment">     *    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *    /product/a/a 不可以</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/** </span></span><br><span class="line"><span class="comment">     *   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *   /product/a/a 也可以访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/product/*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductController.show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;product show!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单层匹配和多层匹配：</span><br><span class="line">  /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。</span><br><span class="line">  /**：可以匹配URL地址中的多层。</span><br><span class="line">其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次</span><br><span class="line">这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</span><br></pre></td></tr></table></figure></li><li><p><strong>类和方法级别区别</strong></p><p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p><ol><li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li><li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.标记到handler方法</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/logout&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.优化标记类+handler方法</span></span><br><span class="line"><span class="comment">//类上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//handler方法上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>附带请求方式限制</strong></p><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！</p><p>如果需要特定指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     * method = RequestMethod.POST 可以指定单个或者多个请求方式!</span></span><br><span class="line"><span class="comment">     * 注意:违背请求方式会出现405异常!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：违背请求方式，会出现405异常！！！</p></li><li><p><strong>进阶注解</strong></p><p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)</span></span><br><span class="line">||</span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/login&quot;)</span></span><br></pre></td></tr></table></figure><p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p></li><li><p><strong>常见配置问题</strong></p><p>出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。</p><blockquote><p>There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() <strong>mapped</strong>.</p></blockquote></li></ol><h3 id="2-2-接收参数（重点）"><a href="#2-2-接收参数（重点）" class="headerlink" title="2.2 接收参数（重点）"></a>2.2 接收参数（重点）</h3><h4 id="2-2-1-param-和-json参数比较"><a href="#2-2-1-param-和-json参数比较" class="headerlink" title="2.2.1 param 和 json参数比较"></a>2.2.1 param 和 json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li><p>参数编码： &#x20;</p><p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。</p></li><li><p>参数顺序： &#x20;</p><p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p></li><li><p>数据类型： &#x20;</p><p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p></li><li><p>嵌套性： &#x20;</p><p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p></li><li><p>可读性： &#x20;</p><p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p></li></ol><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><p><img src="/../../../ProTool/img/img1/202310150100732.png" alt="image-20231007134256617"></p><h4 id="2-2-2-param参数接收"><a href="#2-2-2-param参数接收" class="headerlink" title="2.2.2 param参数接收"></a>2.2.2 param参数接收</h4><ol><li><p><strong>直接接值</strong></p><p>客户端请求</p><p><img src="/../../../ProTool/img/img1/image_3SOeT8tvvW.png"></p><p><strong>handler接收参数</strong></p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">     *    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">     *          类型相同</span></span><br><span class="line"><span class="comment">     * 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@RequestParam注解</strong></p><p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p><code>@RequestParam</code>使用场景：</p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值<br>基本用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment"> *  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;stuAge&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p><p>如果没有没有设置非必须，也没有传递参数会出现：</p><p><img src="/../../../ProTool/img/img1/image_vIkYCRMSZL.png"></p><p>将参数设置非必须，并且设置默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>特殊场景接值</strong></p><ol><li><p>一名多值</p><p>多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line">    <span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体接收</p><p>Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例：</p><p>定义一个用于接收参数的实体类：</p><p>作用<br>    作用：将方法的返回值，以特定的格式写入到response的body区域，进而将数据返回给客户端。<br><br>    当方法上面没有写ResponseBody,底层会将方法的返回值封装为ModelAndView对象。<br><br>    如果返回值是字符串，那么直接将字符串写到客户端；如果是一个对象，会将对象转化为json串，然后写到客户端。</p><hr><p>版权声明：本文为CSDN博主「春风化作秋雨」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jiahao1186/article/details/91980316">https://blog.csdn.net/jiahao1186/article/details/91980316</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中，使用实体对象接收，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p><p>使用postman传递参数测试：</p><p><img src="/../../../ProTool/img/img1/image_5BkbhZjtyX.png"></p></li></ol></li></ol><h4 id="2-2-3-路径-参数接收"><a href="#2-2-3-路径-参数接收" class="headerlink" title="2.2.3 路径 参数接收"></a>2.2.3 路径 参数接收</h4><p><img src="/../../../ProTool/img/img1/image-20231013232602723.png" alt="image-20231013232602723"></p><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <strong><code>@PathVariable</code> 注解来处理路径传递参数。</strong></p><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment"> * 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment"> *              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-json参数接收"><a href="#2-2-4-json参数接收" class="headerlink" title="2.2.4 json参数接收"></a>2.2.4 json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p><ol><li><p>前端发送 JSON 数据的示例：（使用postman测试）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个用于接收 JSON 数据的 Java 类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String gender;</span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。</p><p><img src="/../../../ProTool/img/img1/image-20231013233612291.png" alt="image-20231013233612291"></p></li><li><p>完善配置</p><p>测试：</p><p><img src="/../../../ProTool/img/img1/image_-vKMBKKMSZ.png"></p><p>问题：</p><p>org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported]</p><p><img src="/../../../ProTool/img/img1/202310150101981.png"></p><p>原因：</p><ul><li>不支持json数据类型处理</li><li>没有json类型处理的工具（jackson）<br>解决：<br>springmvc handlerAdpater配置json转化器,配置类需要明确：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br></pre></td></tr></table></figure><p> }<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pom.xml 加入jackson依赖</span><br><span class="line">```xml</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.15.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p></li><li><p><strong>@EnableWebMvc注解说明</strong></p><p>@EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素！我们来解析<code>&lt;mvc:annotation-driven&gt;</code>对应的解析工作！</p><p>让我们来查看下<code>&lt;mvc:annotation-driven&gt;</code>具体的动作！</p><ul><li><p>先查看<code>&lt;mvc:annotation-driven&gt;</code>标签最终对应解析的Java类</p><p><img src="/../../../ProTool/img/img1/image_WJXPabVDSl.png"></p></li><li><p>查看解析类中具体的动作即可</p><p>打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler</p><p><img src="/../../../ProTool/img/img1/image_37KWhccu6c.png"></p><p>打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_MAPPING_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerMapping.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_ADAPTER_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> AnnotationDrivenBeanDefinitionParser.class.getClassLoader();</span><br><span class="line">    javaxValidationPresent = ClassUtils.isPresent(<span class="string">&quot;jakarta.validation.Validator&quot;</span>, classLoader);</span><br><span class="line">    romePresent = ClassUtils.isPresent(<span class="string">&quot;com.rometools.rome.feed.WireFeed&quot;</span>, classLoader);</span><br><span class="line">    jaxb2Present = ClassUtils.isPresent(<span class="string">&quot;jakarta.xml.bind.Binder&quot;</span>, classLoader);</span><br><span class="line">    jackson2Present = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>, classLoader) &amp;&amp;</span><br><span class="line">            ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.core.JsonGenerator&quot;</span>, classLoader);</span><br><span class="line">    jackson2XmlPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;</span>, classLoader);</span><br><span class="line">    jackson2SmilePresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;</span>, classLoader);</span><br><span class="line">    jackson2CborPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;</span>, classLoader);</span><br><span class="line">    gsonPresent = ClassUtils.isPresent(<span class="string">&quot;com.google.gson.Gson&quot;</span>, classLoader);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><pre><code> @Override @Nullable public BeanDefinition parse(Element element, ParserContext context) &#123;   //handlerMapping加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);   //添加jackson转化器   addRequestBodyAdvice(handlerAdapterDef);   addResponseBodyAdvice(handlerAdapterDef);   //handlerAdapter加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);   return null; &#125; //具体添加jackson转化对象方法 protected void addRequestBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;requestBodyAdvice&quot;,         new RootBeanDefinition(JsonViewRequestBodyAdvice.class));   &#125; &#125; protected void addResponseBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;responseBodyAdvice&quot;,         new RootBeanDefinition(JsonViewResponseBodyAdvice.class));   &#125; &#125;</code></pre>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.3 接收Cookie数据</span><br><span class="line"></span><br><span class="line">可以使用 `@CookieValue` 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</span><br><span class="line"></span><br><span class="line">考虑使用以下 cookie 的请求：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>下面的示例演示如何获取 cookie 值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-接收请求头数据"><a href="#2-4-接收请求头数据" class="headerlink" title="2.4 接收请求头数据"></a>2.4 接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-原生Api对象操作"><a href="#2-5-原生Api对象操作" class="headerlink" title="2.5 原生Api对象操作"></a>2.5 原生Api对象操作</h3><p><img src="/../../../ProTool/img/img1/image-20231014000823019.png" alt="image-20231014000823019"></p><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p><p>下表描述了支持的控制器方法参数</p><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment"> * 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">                  HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-共享域对象操作"><a href="#2-6-共享域对象操作" class="headerlink" title="2.6 共享域对象操作"></a>2.6 共享域对象操作</h3><h4 id="2-6-1-属性（共享）域作用回顾"><a href="#2-6-1-属性（共享）域作用回顾" class="headerlink" title="2.6.1 属性（共享）域作用回顾"></a>2.6.1 属性（共享）域作用回顾</h4><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><p><img src="/../../../ProTool/img/img1/img010_VQ5ta0PT96.png"></p><h4 id="2-6-2-Request级别属性（共享）域"><a href="#2-6-2-Request级别属性（共享）域" class="headerlink" title="2.6.2 Request级别属性（共享）域"></a>2.6.2 Request级别属性（共享）域</h4><ol><li><p>使用 Model 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Model model)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ModelMap 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        ModelMap modelMap)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Map 类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用原生 request 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">        HttpServletRequest request)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ModelAndView 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">// 2.存入模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-6-3-Session级别属性（共享）域"><a href="#2-6-3-Session级别属性（共享）域" class="headerlink" title="2.6.3 Session级别属性（共享）域"></a>2.6.3 Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-4-Application级别属性（共享）域"><a href="#2-6-4-Application级别属性（共享）域" class="headerlink" title="2.6.4 Application级别属性（共享）域"></a>2.6.4 Application级别属性（共享）域</h4><p>解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、SpringMVC响应数据"><a href="#三、SpringMVC响应数据" class="headerlink" title="三、SpringMVC响应数据"></a>三、SpringMVC响应数据</h2><h3 id="3-1-handler方法分析"><a href="#3-1-handler方法分析" class="headerlink" title="3.1 handler方法分析"></a>3.1 handler方法分析</h3><p>理解handler方法的作用和组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中注册,供DS查找!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment"> *       1.接收请求参数(param,json,pathVariable,共享域等) </span></span><br><span class="line"><span class="comment"> *       2.调用业务逻辑 </span></span><br><span class="line"><span class="comment"> *       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment"> *       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment"> *       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment"> *       3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">    调用业务方法</span><br><span class="line">    返回的结果 （页面跳转，返回数据（json））</span><br><span class="line">    <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 请求数据接收，我们都是通过handler的形参列表</p><p>&#x20;            前端数据响应，我们都是通过handler的return关键字快速处理！</p><p>&#x20;       springmvc简化了参数接收和响应！</p><h3 id="3-2-页面跳转控制"><a href="#3-2-页面跳转控制" class="headerlink" title="3.2 页面跳转控制"></a>3.2 页面跳转控制</h3><h4 id="3-2-1-快速返回模板视图"><a href="#3-2-1-快速返回模板视图" class="headerlink" title="3.2.1 快速返回模板视图"></a>3.2.1 快速返回模板视图</h4><ol><li><p>开发模式回顾</p><p>在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。</p><p><img src="/../../../ProTool/img/img1/202310150104483.png" alt="image-20231014082655185"></p><p><strong>前后端分离模式：[重点]</strong></p><p>指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格  式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。</p><p>混合开发模式：</p><p>指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。</p><p>对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！</p></li><li><p><strong>jsp技术了解</strong></p><p>JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。</p><p>JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。</p><p>JSP 的主要特点包括：</p><ol><li>简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。</li><li>高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。</li><li>多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。<br>总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。</li></ol></li><li><p>准备jsp页面和依赖</p><p>pom.xml依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp需要依赖! jstl--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsp页面创建</p><p>建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！</p><p>位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;</span><br><span class="line">        $&#123;msg&#125;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>快速响应模版页面</p><ol><li><p>配置jsp视图解析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handler返回视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  跳转到提交文件页面  /save/jump</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  如果要返回jsp页面!</span></span><br><span class="line"><span class="comment"> *     1.方法返回值改成字符串类型</span></span><br><span class="line"><span class="comment"> *     2.返回逻辑视图名即可    </span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;</span></span><br><span class="line"><span class="comment"> *            + 逻辑视图名 +</span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;jump&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jumpJsp</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;FileController.jumpJsp&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;request data!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="3-2-2-转发和重定向"><a href="#3-2-2-转发和重定向" class="headerlink" title="3.2.2 转发和重定向"></a>3.2.2 转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 转发到 /demo 路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h3 id="3-3-返回JSON数据（重点）"><a href="#3-3-返回JSON数据（重点）" class="headerlink" title="3.3 返回JSON数据（重点）"></a>3.3 返回JSON数据（重点）</h3><h4 id="3-3-1-前置准备"><a href="#3-3-1-前置准备" class="headerlink" title="3.3.1 前置准备"></a>3.3.1 前置准备</h4><p>导入jackson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加json数据转化器</p><p>@EnableWebMvc&#x20;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-ResponseBody"><a href="#3-3-2-ResponseBody" class="headerlink" title="3.3.2 @ResponseBody"></a>3.3.2 @ResponseBody</h4><ol><li><p>方法上使用@ResponseBody</p><p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p><img src="/../../../ProTool/img/img1/image-20231014084004267.png" alt="image-20231014084004267"></p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="/../../../ProTool/img/img1/image_GfNTc3Ei41.png"></p></li><li><p>类上使用@ResponseBody</p><p>如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//responseBody可以添加到类上,代表默认类中的所有方法都生效!</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-3-RestController"><a href="#3-3-3-RestController" class="headerlink" title="3.3.3 @RestController"></a>3.3.3 @RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。</p><p>RestController源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-返回静态资源处理"><a href="#3-4-返回静态资源处理" class="headerlink" title="3.4 返回静态资源处理"></a>3.4 返回静态资源处理</h3><ol><li><p><strong>静态资源概念</strong></p><p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括：</p><ul><li>纯HTML文件</li><li>图片</li><li>CSS文件</li><li>JavaScript文件</li><li>……</li></ul></li><li><p><strong>静态资源访问和问题解决</strong></p><ul><li><p>web应用加入静态资源</p><p><img src="/../../../ProTool/img/img1/image_4ZDfBKo7ze.png"></p></li><li><p>手动构建确保编译</p><p><img src="/../../../ProTool/img/img1/image_WNWOVOea6e.png"></p><p><img src="/../../../ProTool/img/img1/image_jkHB39M3Xa.png"></p><p><img src="/../../../ProTool/img/img1/image_iUBYDKRqy5.png"></p></li><li><p>访问静态资源</p><p><img src="/../../../ProTool/img/img1/image_k7bhHrwvx1.png"></p></li><li><p>问题分析</p><ul><li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li><li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul></li><li><p>问题解决</p><p>在 SpringMVC 配置配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试访问图片：</p><p><img src="/../../../ProTool/img/img1/image_mrBsYbjiMM.png"></p></li><li><p>新的问题：其他原本正常的handler请求访问不了了</p><p>handler无法访问</p><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="四、RESTFul风格设计和实战"><a href="#四、RESTFul风格设计和实战" class="headerlink" title="四、RESTFul风格设计和实战"></a>四、RESTFul风格设计和实战</h2><h3 id="4-1-RESTFul风格概述"><a href="#4-1-RESTFul风格概述" class="headerlink" title="4.1 RESTFul风格概述"></a>4.1 RESTFul风格概述</h3><h4 id="4-1-1-RESTFul风格简介"><a href="#4-1-1-RESTFul风格简介" class="headerlink" title="4.1.1 RESTFul风格简介"></a>4.1.1 RESTFul风格简介</h4><p><img src="/../../../ProTool/img/img1/image_wEi6we5MJQ.png"></p><p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。</p><p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。</p><p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p><p><img src="/../../../ProTool/img/img1/image_X8M-XfzI_A.png"></p><p>学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！</p><p><img src="/../../../ProTool/img/img1/202310141244518.png" alt="image-20231014124402358"></p><p><img src="/../../../ProTool/img/img1/202310150104795.png" alt="image-20231014124717765"></p><h4 id="4-1-2-RESTFul风格特点"><a href="#4-1-2-RESTFul风格特点" class="headerlink" title="4.1.2 RESTFul风格特点"></a>4.1.2 RESTFul风格特点</h4><ol><li>每一个URI代表1种资源（URI 是名词）；</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是XML或者<strong>JSON</strong>；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li><li><img src="/../../../ProTool/img/img1/202310150104952.png" alt="image-20231014125525831"></li></ol><h4 id="4-1-3-RESTFul风格设计规范"><a href="#4-1-3-RESTFul风格设计规范" class="headerlink" title="4.1.3 RESTFul风格设计规范"></a>4.1.3 <strong>RESTFul风格设计规范</strong></h4><ol><li><p><strong>HTTP协议请求方式要求</strong></p><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table></li><li><p><strong>URL路径风格要求</strong></p><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li></ol><ul><li><p>总结</p><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，<strong>改成名词</strong>，对应资源的唯一标识即可！</p></li></ul><h4 id="4-1-4-RESTFul风格好处"><a href="#4-1-4-RESTFul风格好处" class="headerlink" title="4.1.4 RESTFul风格好处"></a>4.1.4 RESTFul风格好处</h4><ol><li><p>含蓄，安全</p><p>使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。</p></li><li><p>风格统一</p><p>URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。</p></li><li><p>无状态</p><p>在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。</p></li><li><p>严谨，规范</p><p>严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。</p></li><li><p>简洁，优雅</p><p>过去做增删改查操作需要设计4个不同的URL，现在一个就够了。</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li><li><p>丰富的语义</p><p>通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。</p><blockquote><p><a href="http://localhost:8080/shop" title="http://localhost:8080/shop">http://localhost:8080/shop</a> <a href="http://localhost:8080/shop/product" title="http://localhost:8080/shop/product">http://localhost:8080/shop/product</a> <a href="http://localhost:8080/shop/product/cellPhone" title="http://localhost:8080/shop/product/cellPhone">http://localhost:8080/shop/product/cellPhone</a> <a href="http://localhost:8080/shop/product/cellPhone/iPhone" title="http://localhost:8080/shop/product/cellPhone/iPhone">http://localhost:8080/shop/product/cellPhone/iPhone</a></p></blockquote></li></ol><h3 id="4-2-RESTFul风格实战"><a href="#4-2-RESTFul风格实战" class="headerlink" title="4.2 RESTFul风格实战"></a>4.2 RESTFul风格实战</h3><h4 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1 需求分析"></a>4.2.1 需求分析</h4><ul><li>数据结构： User {id 唯一标识,name 用户名，age 用户年龄}</li><li>功能分析<ul><li>用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10）</li><li>保存用户功能</li><li>根据用户id查询用户详情功能</li><li>根据用户id更新用户数据功能</li><li>根据用户id删除用户数据功能</li><li>多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10）</li></ul></li></ul><h4 id="4-2-2-RESTFul风格接口设计"><a href="#4-2-2-RESTFul风格接口设计" class="headerlink" title="4.2.2 RESTFul风格接口设计"></a>4.2.2 RESTFul风格接口设计</h4><ol><li><p><strong>接口设计</strong></p><table><thead><tr><th>功能</th><th>接口和请求方式</th><th>请求参数</th><th>返回值</th></tr></thead><tbody><tr><td>分页查询</td><td>GET  &#x2F;user</td><td>page&#x3D;1&amp;size&#x3D;10</td><td>{ 响应数据 }</td></tr><tr><td>用户添加</td><td>POST &#x2F;user</td><td>{ user 数据 }</td><td>{响应数据}</td></tr><tr><td>用户详情</td><td>GET &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>用户更新</td><td>PUT &#x2F;user</td><td>{ user 更新数据}</td><td>{响应数据}</td></tr><tr><td>用户删除</td><td>DELETE &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>条件模糊</td><td>GET &#x2F;user&#x2F;search</td><td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td><td>{响应数据}</td></tr></tbody></table></li><li><p><strong>问题讨论</strong></p><p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p><p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p><p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p><ul><li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li><li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。<br>此外，还有一些通用的原则可以遵循：</li><li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li><li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li><li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li><li><img src="/../../../ProTool/img/img1/image-20231014130339783.png" alt="image-20231014130339783"></li></ul></li></ol><h4 id="4-2-3-后台接口实现"><a href="#4-2-3-后台接口实现" class="headerlink" title="4.2.3 后台接口实现"></a>4.2.3 后台接口实现</h4><p>准备用户实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>准备用户Controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 用户模块的控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户保存业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户保存业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户详情业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">detailUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户详情业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户更新业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户更新业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟条件分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;search&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;keyword&quot;,required= false)</span>String keyword)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size + <span class="string">&quot;, keyword = &quot;</span> + keyword);</span><br><span class="line">        System.out.println(<span class="string">&quot;条件分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、SpringMVC其他扩展"><a href="#五、SpringMVC其他扩展" class="headerlink" title="五、SpringMVC其他扩展"></a>五、SpringMVC其他扩展</h2><h3 id="5-1-全局异常处理机制"><a href="#5-1-全局异常处理机制" class="headerlink" title="5.1 全局异常处理机制"></a>5.1 全局异常处理机制</h3><h4 id="5-1-1-异常处理两种方式"><a href="#5-1-1-异常处理两种方式" class="headerlink" title="5.1.1 异常处理两种方式"></a>5.1.1 异常处理两种方式</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p><p>对于异常的处理，一般分为两种方式：</p><ul><li><strong>编程式异常处理</strong>：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 <strong>try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。</strong>在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li><strong>声明式异常处理：</strong>则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过<strong>配置等方式进行统一的管理和处理。</strong>在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p>站在宏观角度来看待声明式事务处理：</p><p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p><p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p><h4 id="5-1-2-基于注解异常声明异常处理"><a href="#5-1-2-基于注解异常声明异常处理" class="headerlink" title="5.1.2 基于注解异常声明异常处理"></a>5.1.2 基于注解异常声明异常处理</h4><ol><li><p>声明异常处理控制器类</p><p>异常处理控制类，统一定义异常处理handler方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.execptionhandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * description: 全局异常处理器,内部可以定义异常处理Handler!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明异常处理hander方法</p><p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理handler </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment"> * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment"> * 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment"> * 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment"> *       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件扫描控制器类配置</p><p>确保异常处理控制类被扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,</span></span><br><span class="line"><span class="meta">&quot;com.atguigu.exceptionhandler&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-拦截器使用"><a href="#5-2-拦截器使用" class="headerlink" title="5.2 拦截器使用"></a>5.2 拦截器使用</h3><h4 id="5-2-1-拦截器概念"><a href="#5-2-1-拦截器概念" class="headerlink" title="5.2.1 拦截器概念"></a>5.2.1 拦截器概念</h4><p>拦截器和过滤器解决问题</p><ul><li><p>生活中</p><p>为了提高乘车效率，在乘客进入站台前统一检票</p><p><img src="/../../../ProTool/img/img1/img008_uQA2iP6_5n.png"></p></li><li><p>程序中</p><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p><p><img src="/../../../ProTool/img/img1/img009_aXz6GsRSMQ.png"></p></li></ul><p><img src="/../../../ProTool/img/img1/202310150105383.png" alt="image-20231014141252652"></p><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li>相似点<ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li>不同点<ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul></li></ul><p>选择：</p><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。</p><p><img src="/../../../ProTool/img/img1/image_7rIm3LKXgr.png"></p><h4 id="5-2-2-拦截器使用"><a href="#5-2-2-拦截器使用" class="headerlink" title="5.2.2 拦截器使用"></a>5.2.2 拦截器使用</h4><ol><li><p>创建拦截器类</p></li><li><p><img src="/../../../ProTool/img/img1/image-20231014141727677.png" alt="image-20231014141727677"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if( ! preHandler())&#123;return;&#125;</span></span><br><span class="line">    <span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 返回true：放行</span></span><br><span class="line">        <span class="comment">// 返回false：不放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器方法拦截位置：</p><p><img src="/../../../ProTool/img/img1/image_FwhiGWjP_t.png"></p></li><li><p>修改配置类添加拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line">        <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 配置详解</span><br><span class="line"></span><br><span class="line">   1. 默认拦截全部</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      @Override</span><br><span class="line">      public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">          //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br><span class="line">          registry.addInterceptor(new Process01Interceptor());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><ol start="2"><li><p>精准配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>排除配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排除匹配,排除应该在匹配的范围内排除</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>())</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>多个拦截器执行顺序</p><ol><li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li><li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li><li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。<img src="/../../../ProTool/img/img1/202310150105406.png" alt="image-20231014143224525"></li></ol></li></ol><h3 id="5-3-参数校验"><a href="#5-3-参数校验" class="headerlink" title="5.3 参数校验"></a>5.3 参数校验</h3><blockquote><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p><p><img src="/../../../ProTool/img/img1/image-20231014143507329.png" alt="image-20231014143507329"></p></blockquote><ol><li><p><strong>校验概述</strong></p><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr><tr><td>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</td><td></td></tr><tr><td>注解</td><td>规则</td></tr><tr><td>————————————————————————————————————————————————————————————————————————————————————————————————————————————————-</td><td>——————–</td></tr><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr><tr><td>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</td><td></td></tr><tr><td>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</td><td></td></tr></tbody></table></li><li><p><strong>操作演示</strong></p><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>应用校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line">    <span class="meta">@Min(10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line">    <span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//email 邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>handler标记和绑定错误收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">                       BindingResult result)</span>&#123;</span><br><span class="line">       <span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试效果</p><p><img src="/../../../ProTool/img/img1/image_BKORDdDEb9.png"></p></li></ul></li><li><p><strong>易混总结</strong></p><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ol><li><p>@NotNull  (包装类型不为null)</p><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p></li><li><p>@NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p></li><li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。<br>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p></li></ol></li></ol><h2 id="六、SpringMVC总结"><a href="#六、SpringMVC总结" class="headerlink" title="六、SpringMVC总结"></a>六、SpringMVC总结</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>springmvc框架</td><td>主要作用、核心组件、调用流程</td></tr><tr><td>简化参数接收</td><td>路径设计、参数接收、请求头接收、cookie接收</td></tr><tr><td>简化数据响应</td><td>模板页面、转发和重定向、JSON数据、静态资源</td></tr><tr><td>restful风格设计</td><td>主要作用、具体规范、请求方式和请求参数选择</td></tr><tr><td>功能扩展</td><td>全局异常处理、拦截器、参数校验注解</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringMVC&quot;&gt;&lt;a href=&quot;#SpringMVC&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC&quot;&gt;&lt;/a&gt;SpringMVC&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="后端" scheme="https://axdmdyj.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="SpringMVC" scheme="https://axdmdyj.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="https://axdmdyj.github.io/posts/d044eab7.html"/>
    <id>https://axdmdyj.github.io/posts/d044eab7.html</id>
    <published>2023-10-14T15:13:01.000Z</published>
    <updated>2023-11-21T06:54:08.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p><img src="/../../../ProTool/img/img1/202310142311876-16972964465172.png" alt="image-20231014231100506"></p><h2 id="1-类型推断"><a href="#1-类型推断" class="headerlink" title="1.类型推断"></a>1.类型推断</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line">str = <span class="number">10</span>  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h2 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span>    <span class="comment">//预定义一个类型</span></span><br><span class="line">str = <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3-类型断言"><a href="#3-类型断言" class="headerlink" title="3.类型断言"></a>3.类型断言</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> result = numArr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>) <span class="keyword">as</span> <span class="built_in">number</span> <span class="comment">// as number断言一定有大于2的数</span></span><br><span class="line">result*<span class="number">5</span>  <span class="comment">// 如果不断言, 这行会报错,因为可能ressult是undefined</span></span><br></pre></td></tr></table></figure><h2 id="4-基础类型和联合类型"><a href="#4-基础类型和联合类型" class="headerlink" title="4.基础类型和联合类型"></a>4.基础类型和联合类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础类型, 当我们分配这些类型以后, 就不能进行其他类型的设置了</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>: <span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>: <span class="built_in">number</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 以下两种不常用</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nu</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">un</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//联合类型,可以是一种类型也可以是另一种类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v4</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="literal">null</span>  <span class="comment">// null可以赋值给任意类型(前提不开启严格配置项)</span></span><br><span class="line"><span class="comment">// 具体值的限制, 只能分配其中之一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v5</span>: <span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span> =<span class="number">5</span><span class="comment">//报错   =2正确</span></span><br></pre></td></tr></table></figure><h2 id="5-数组-元组-枚举"><a href="#5-数组-元组-枚举" class="headerlink" title="5.数组,元组,枚举"></a>5.数组,元组,枚举</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="comment">//[1,2,3,&#x27;a&#x27;]报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];<span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;1]报错</span></span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">t1</span>: [<span class="built_in">number</span>,<span class="built_in">string</span>,<span class="built_in">number</span>] = [<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>] <span class="comment">//定义一个元组</span></span><br><span class="line"><span class="comment">// t1[0] = &#x27;a&#x27; 报错</span></span><br><span class="line">并不一定要三个值, 可选</span><br><span class="line"><span class="keyword">let</span> <span class="attr">t1</span>: [<span class="built_in">number</span>,<span class="built_in">string</span>,<span class="built_in">number</span>?] = [<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>] <span class="comment">//2去掉也不报错,但&#x27;a&#x27;去掉报错</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span>&#123;</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">    C</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两种访问方式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyEnum</span>.<span class="property">A</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyEnum</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="Void类型"><a href="#Void类型" class="headerlink" title="Void类型"></a>Void类型</h3><p>只能被赋值为<code>undefined</code></p><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyFn</span> (<span class="attr">a</span>:<span class="built_in">number</span>, <span class="attr">b</span>:<span class="built_in">string</span>)   <span class="comment">//参数接收</span></span><br><span class="line">: <span class="built_in">number</span>&#123; <span class="comment">//设置返回值类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFn</span> (<span class="attr">a</span>:<span class="built_in">number</span>, b?:<span class="built_in">string</span>, c?:<span class="built_in">boolean</span>, ...<span class="attr">rest</span>:<span class="built_in">number</span>[])   <span class="comment">//b可选, 建议必选的放左侧, 可选的放右侧</span></span><br><span class="line">: <span class="built_in">number</span>&#123; <span class="comment">//设置返回值类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="title class_">MyFn</span>(<span class="number">20</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="literal">true</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义自己创建类型的一个约束方式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Obj</span>=&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">10</span>  <span class="comment">//避免一些错误, 比如写成ago = 10就会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>:<span class="title class_">Obj</span>=&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">10</span>  <span class="comment">//避免一些错误, 比如写成ago = 10就会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-类型别名"><a href="#8-类型别名" class="headerlink" title="8.类型别名"></a>8.类型别名</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyUserName</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">MyUserName</span> = <span class="string">&#x27;a&#x27;</span>  <span class="comment">// = 1也可以</span></span><br></pre></td></tr></table></figure><h2 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9.泛型"></a>9.泛型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFn</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>):<span class="built_in">number</span>[]&#123;</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改成通用的函数</span></span><br><span class="line"><span class="keyword">function</span> myFn&lt;T&gt;(<span class="attr">a</span>:T,<span class="attr">b</span>:T):T[]&#123;</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myfN&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//(1,&#x27;a&#x27;)报错</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../ProTool/img/img1/2</summary>
      
    
    
    
    <category term="前端" scheme="https://axdmdyj.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://axdmdyj.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–10-10-day35</title>
    <link href="https://axdmdyj.github.io/posts/9b8ac020.html"/>
    <id>https://axdmdyj.github.io/posts/9b8ac020.html</id>
    <published>2023-10-09T16:49:59.000Z</published>
    <updated>2023-11-12T08:53:08.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>只有一只股票！</li><li>当前只有买股票或者卖股票的操作</li></ul><p>想获得利润至少要两天为一个交易单元。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>分解本题</p><p>假如第 0 天买入，第 3 天卖出，那么利润为：<code>prices[3] - prices[0]。</code></p><p>相当于<code>(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</code></p><p><strong>此时将利润分解为每天为单位的维度 , 而不是从连续几天考虑</strong></p><p>prices每天的利润序列 <code>(prices[i] - prices[i - 1]).....(prices[1] - prices[0])</code></p><p><strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>只收集正利润 就是贪心所贪的地方</p><p>&#x3D;&#x3D;局部最优&#x3D;&#x3D; 收集每天的正利润, 全局最优: 求得最大利润</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            res += Math.max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>跳几步无所谓, 关键在于可跳的覆盖范围</p><p>&#x3D;&gt; <strong>问题转化为: 跳跃覆盖的范围能不能到达终点</strong></p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++)&#123;</span><br><span class="line">            cover = Math.max(i + nums[i] , cover);</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>i &lt;= cover</code> 在覆盖范围内移动, 超出覆盖范围没有意义</p><h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p><strong>局部最优</strong>：当前可移动距离尽可能多走，如果还没到终点，步数再加一。</p><p><strong>整体最优：</strong>一步尽可能多走，从而达到最少步数。</p><p><strong>从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！</strong></p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>;    <span class="comment">// 当前覆盖最远距离下标</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;            <span class="comment">// 记录走的最大步数</span></span><br><span class="line">        <span class="type">int</span> nextDistance = <span class="number">0</span>;   <span class="comment">// 下一步覆盖最远距离下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            nextDistance = max(nums[i] + i, nextDistance);  <span class="comment">// 更新下一步覆盖最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;                         <span class="comment">// 遇到当前覆盖最远距离下标</span></span><br><span class="line">                ans++;                                  <span class="comment">// 需要走下一步</span></span><br><span class="line">                curDistance = nextDistance;             <span class="comment">// 更新当前覆盖最远距离下标（相当于加油了）</span></span><br><span class="line">                <span class="keyword">if</span> (nextDistance &gt;= nums.size() - <span class="number">1</span>) <span class="keyword">break</span>;  <span class="comment">// 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机-II&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/best-time-to</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="回溯算法" scheme="https://axdmdyj.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–10-07-day32</title>
    <link href="https://axdmdyj.github.io/posts/ce36b93.html"/>
    <id>https://axdmdyj.github.io/posts/ce36b93.html</id>
    <published>2023-10-07T12:46:42.000Z</published>
    <updated>2023-11-12T08:53:08.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯算法总结"><a href="#回溯算法总结" class="headerlink" title="回溯算法总结"></a>回溯算法总结</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。</p><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>题目链接: <a href="https://leetcode.cn/problems/combinations/description/">https://leetcode.cn/problems/combinations/description/</a></p><p>通过列举10086层<code>for循环的例子, 进而得出为什么要用回溯法</code></p><p>搜索的过程：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>，这个理念贯穿整个回溯法系列</p><p>可以通过思考在哪一步不需要继续往下遍历了. 然后进行剪枝优化</p><p><strong>剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了</strong>。</p><p><strong>在for循环上做剪枝操作是回溯法剪枝的常见套路！</strong></p><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>题目链接: <a href="https://leetcode.cn/problems/combination-sum-iii/description/">https://leetcode.cn/problems/combination-sum-iii/description/</a></p><p>整体思路还是一样的，本题的剪枝会好想一些，即：<strong>已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉</strong></p><p>所以剪枝的代码可以在for循环加上 <code>i &lt;= 9 - (k - path.size()) + 1</code> 的限制！</p><h2 id="组数总和"><a href="#组数总和" class="headerlink" title="组数总和(||)"></a>组数总和(||)</h2><p>需要使用startIndex的情况</p><ul><li>如果是一个集合来求组合的话，就需要startIndex</li><li>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</li></ul><p><strong>只是说求组合的情况，如果是排列问题，又是另一套分析的套路</strong>。</p><h2 id="组合-三"><a href="#组合-三" class="headerlink" title="组合(三)"></a>组合(三)</h2><p>集合元素会有重复，但要求解集不能包含重复的组合。</p><p>两个维度，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。</p><p><strong>在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</strong></p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><h2 id="多个集合求组合"><a href="#多个集合求组合" class="headerlink" title="多个集合求组合"></a>多个集合求组合</h2><p>开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。</p><p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！ (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>都是是求同一个集合中的组合！</strong></p><h2 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h2><ul><li>切割问题其实类似组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p><strong>用求解组合问题的思路来解决 切割问题本题就成功一大半了</strong>，接下来就可以对着模板照葫芦画瓢。</p><p><strong>但后序如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p><p><strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1</strong>。</p><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p><strong>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果</strong>。</p><p><strong>本题其实可以不需要加终止条件</strong>，因为startIndex &gt;&#x3D; nums.size()，本层for循环本来也结束了，本来我们就要遍历整棵树。</p><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p><strong>使用set针对同一父节点本层去重，但子集问题一定要排序，</strong></p><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><p>排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。</p><p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。</p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯算法总结&quot;&gt;&lt;a href=&quot;#回溯算法总结&quot; class=&quot;headerlink&quot; title=&quot;回溯算法总结&quot;&gt;&lt;/a&gt;回溯算法总结&lt;/h1&gt;&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理论基础&quot; class=&quot;headerlink&quot; title=&quot;理</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="回溯算法" scheme="https://axdmdyj.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–10-04-day25</title>
    <link href="https://axdmdyj.github.io/posts/ba74d5ec.html"/>
    <id>https://axdmdyj.github.io/posts/ba74d5ec.html</id>
    <published>2023-10-04T13:06:10.000Z</published>
    <updated>2023-11-12T08:53:08.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p> 第一眼做这个以为跟前面的都一样,无脑三部曲.但后来才发现题给的解释说,集合中的数可以使用多次. 傻眼了. 那怎么去考虑终止条件呢. 还有如何去深度搜索和宽度搜索呢?</p></blockquote><p>​注意叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递<strong>归没有层数的限制，只要选取的元素总和超过target，就返回！</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>二维数组result存放结果集，数组path存放符合条件的结果。</p><p>参数: </p><p>集合</p><p><code>candiates</code> 题目给的数组</p><p><code>target</code> 目标和</p><p><code>sum</code> 总和</p><p><code>startIndex</code> </p><blockquote><p><strong>startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？</strong></p><p>如果是一个集合来求组合的话，就需要startInde</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</p></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ector&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>根据题目, 终止条件只有两种: sum大于target和sum等于target。</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">    result.push_back(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p>单层for循环依然是从startIndex开始，搜索candidates集合。</p><p>如何重复选取?</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">    sum += candidates[i];</span><br><span class="line">    path.push_back(candidates[i]);</span><br><span class="line">    backtracking(candidates, target, sum, i); <span class="comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">    sum -= candidates[i];   <span class="comment">// 回溯</span></span><br><span class="line">    path.pop_back();        <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不用i+1了，表示可以重复读取当前的数</strong></p><p>相当于下一层递归循环 ,  i 还是从这一层的startIndex开始, 这样就实现可重复读取啦</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> startIndex, <span class="type">int</span> target, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每层遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;  candidates.size(); i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            backtracking(candidates, i, target, sum);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">         backtracking(candidates, <span class="number">0</span>, target, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line"></span><br><span class="line">            backtracking(candidates, target, i, sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p><p>可以在for循环判断的终止条件中增加限制: </p><blockquote><p>如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了</p><p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p></blockquote><p>所以单层<code>for</code> 搜索可以改为 sum+&#x3D; candidates原本是在for循环里面 .在这里判断, 就会少走下面的递归函数, 完成剪枝的目的</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++)</span><br></pre></td></tr></table></figure><h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>跟上一题不同的是, 本题candidates 中的每个数字在每个组合中只能使用一次。</p><p>本题数组candidates的元素<strong>是有重复</strong>的，而<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和 (opens new window)</a>是无重复元素的数组candidates</p><p><strong>所谓去重，其实就是使用过的元素不能重复选取</strong></p><p>组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>回溯三部曲</strong></p><ul><li>递归函数参数</li></ul><p>加一个<code>used[]</code> 数组, 用来记录同一树枝上的元素是否使用过</p><p>用来记录同一数层上的元素是否使用过</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放组合集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;           <span class="comment">// 符合条件的组合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;&amp; used)</span> &#123;</span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>跟上一题一样的</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; target) &#123; <span class="comment">// 这个条件其实可以省略</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">    result.push_back(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单层搜索逻辑</li></ul><p><strong>这里与上一题最大的区别就是去重啦</strong>,<strong>一定一定!!要在开始先排序</strong></p><p>难点在于如何判断同一树层上的元素是否使用过</p><p>用<code>used</code> 数组, 0 代表没用过, 1 代表已经用过</p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><p>为什么 used[i - 1] &#x3D;&#x3D; false 就是同一树层呢?</p><p>因为同一树层，used[i - 1] &#x3D;&#x3D; false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">    <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += candidates[i];</span><br><span class="line">    path.push_back(candidates[i]);</span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    backtracking(candidates, target, sum, i + <span class="number">1</span>, used); <span class="comment">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">    used[i] = <span class="literal">false</span>;</span><br><span class="line">    sum -= candidates[i];</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum, <span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 单层遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length ; i++)&#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line"></span><br><span class="line">            backtracking(candidates, target, i+<span class="number">1</span>, sum, used);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">        <span class="comment">// 加标志数组，用来辅助判断同层节点是否已经遍历</span></span><br><span class="line">        Arrays.fill(used, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 为了将重复的数字都放到一起，所以先进行排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法小补充"><a href="#语法小补充" class="headerlink" title="语法小补充"></a>语法小补充</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在java中,可以这么实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(used, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>两个关键问题:</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p><strong>切割问题类似于组合问题</strong></p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。</li></ul><p>递归纵向逐个切割, </p><p>for循环横向遍历切割</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><strong>回溯三部曲</strong></p><ul><li>递归函数参数</li></ul><p>path存放切割后的回文子串</p><p>二维数组res存放结果集</p><p>startIndex , 这里就一个集合,所以也要使用</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path; <span class="comment">// 放已经回文的子串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span> <span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; s, <span class="type">int</span> startIndex)</span> &#123;</span><br></pre></td></tr></table></figure><ul><li>递归函数终止条件</li></ul><p>这个startIndex就可以看做是一个切割线</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单层搜索逻辑</li></ul><p><strong>主要是在递归循环中如何取子串</strong></p><p><code>startIndex =&gt; i</code> 就是子串</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPalindrome(s, startIndex, i)) &#123; <span class="comment">// 是回文子串</span></span><br><span class="line">        <span class="comment">// 获取[startIndex,i]在s中的子串</span></span><br><span class="line">        <span class="built_in">string</span> str = s.substr(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">        path.push_back(str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 如果不是则直接跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(s, i + <span class="number">1</span>); <span class="comment">// 寻找i+1为起始位置的子串</span></span><br><span class="line">    path.pop_back();        <span class="comment">// 回溯过程，弹出本次已经添加的子串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为不能切割在同一处, 遍历到下一层的时候, i+1</p></blockquote><ul><li>判断回文字符串</li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path; <span class="comment">// 放已经回文的子串</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span> <span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; s, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.size()) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, startIndex, i)) &#123;   <span class="comment">// 是回文子串</span></span><br><span class="line">                <span class="comment">// 获取[startIndex,i]在s中的子串</span></span><br><span class="line">                <span class="built_in">string</span> str = s.substr(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">                path.push_back(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 不是回文，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>); <span class="comment">// 寻找i+1为起始位置的子串</span></span><br><span class="line">            path.pop_back(); <span class="comment">// 回溯过程，弹出本次已经添加的子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39. 组合总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;39. 组合总和</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="回溯算法" scheme="https://axdmdyj.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–10-03-day24</title>
    <link href="https://axdmdyj.github.io/posts/8d4dbf4.html"/>
    <id>https://axdmdyj.github.io/posts/8d4dbf4.html</id>
    <published>2023-10-03T11:39:51.000Z</published>
    <updated>2023-11-12T08:53:08.572Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题相当于是在</p><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a>多了一个判断找出的集合之和等于n的判断</p><p>因为数只能取从1 ~ 9</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>回溯三部曲</p><ul><li>第一曲:确定递归函数参数</li></ul><p>依然定义path 和 result为全局变量</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>targetSum（int）目标和，也就是题目中的n。</li><li>k（int）就是题目中要求k个数的集合。</li><li>sum（int）为已经收集的元素的总和，也就是path里元素的总和。</li><li>startIndex（int）为下一层for循环搜索的起始位置。</li></ul></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure><p>补充一下: 回溯算法递归的参数很难一次确定,需要用到什么参数,填什么参数</p><ul><li>第二曲:确定终止条件</li></ul><p>跟组合一样,遍历到第k层其实就已经将树的深度遍历完了</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == targetSum) result.push_back(path);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三曲: 单层搜索</li></ul><p>每一层都是遍历的数都是上一层的数<code>-1</code>,因为集合中不能出现重复的数</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    path.push_back(i);</span><br><span class="line">    backtracking(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">    sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">    path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考这段代码的时候,暂时不要去考虑backtracking里面的过程,直接到<code>sum  -= i</code>和<code>pop.pop_back</code>,然后进行下一层for循环,这两个相当于是清理战场了,然后换一个<code>i</code>再打一遍</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum) &#123;</span><br><span class="line">                res.push_back(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//单层搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> ; i++)&#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backtracking(targetSum,k,sum,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>如果已经选的元素 已经大于<code>targetSum</code>了,那么也没有必要继续往下遍历了</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝操作</span></span><br><span class="line"><span class="keyword">if</span>(sum) &gt; targetSum&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终代码</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; targetSum) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum) &#123;</span><br><span class="line">                res.push_back(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//单层搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> ; i++)&#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backtracking(targetSum,k,sum,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>本题一眼看可以暴力,因为如果<code>digit = 2</code>, 那么两层for魂环酒后了. 但如果<code>digit=10086</code> 层呢,for循环是并不可能的. 这是和<a href="https://leetcode.cn/problems/combinations/">77. 组合</a>在刚开始分析时一样的问题</p><p>理解本题后，要解决如下三个问题：</p><ul><li>数字和字母如何映射</li><li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来</li><li>输入1 * #按键等等异常情况</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="数字和字母如何映射"></a>数字和字母如何映射</h3><p>可以用<code>map</code>, 或者定义一个二维数组,</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="built_in">string</span> letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回溯法来解决n个for循环的问题"><a href="#回溯法来解决n个for循环的问题" class="headerlink" title="回溯法来解决n个for循环的问题"></a>回溯法来解决n个for循环的问题</h3><p>依然是: 深度就是字母集合的长度</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>第一曲: 确定回溯函数参数</li></ul><p>这个在实际做题中不可能一下子想出来,用到什么写什么</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;<span class="comment">//字符串数组result保存起来</span></span><br><span class="line"><span class="built_in">string</span> s;<span class="comment">//收集叶子节点的结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; digits, <span class="type">int</span> index)</span><span class="comment">//记录遍历第几个数字</span></span><br></pre></td></tr></table></figure><p>const string&amp; digit相当于取了一个别名,引用digit但不改变其字符串内容</p><ul><li>确定终止条件</li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(intdex == digits.size())&#123;<span class="comment">//遍历到树底了</span></span><br><span class="line">    result.push_back(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定单层遍历逻辑</li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line"><span class="built_in">string</span> letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.size(); i++) &#123;</span><br><span class="line">    s.push_back(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">    backtracking(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">    s.pop_back();                       <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的for循环并不是从startIndex开始遍历的</strong> <strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合</strong>，<strong>而<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>都是求同一个集合中的组合！</strong></p><p>注意：输入1 * #按键等等异常情况</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="built_in">string</span> letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; digits, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.size())&#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">string</span> letters = letterMap[digit];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.size(); i++)&#123;</span><br><span class="line">            s.push_back(letters[i]);</span><br><span class="line">            backtracking(digits, index + <span class="number">1</span>);</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        backtracking(digits,<span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;216-组合总和-III&quot;&gt;&lt;a href=&quot;#216-组合总和-III&quot; class=&quot;headerlink&quot; title=&quot;216. 组合总和 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problem</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="回溯算法" scheme="https://axdmdyj.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–10-02-day23</title>
    <link href="https://axdmdyj.github.io/posts/30c745e3.html"/>
    <id>https://axdmdyj.github.io/posts/30c745e3.html</id>
    <published>2023-10-02T08:27:10.000Z</published>
    <updated>2023-11-12T08:53:08.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果 <code>k = 2</code></p><p>就直接可以用两层for循环可以解决</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果 <code> k = 10086呢</code> 不可能去用10086层for循环</p><p>这时候可以考虑取用回溯算法来解决暴力都解决不了的问题</p><p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p><blockquote><p>此时,在 <code>n = 100 , k = 50的时候</code> 就是递归50层</p></blockquote><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong></p><p>对于一个集合,相当于是递归树的宽度,而k相当于是递归的深度</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归的返回值以及参数</li></ul><p>先定义两个全局变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br></pre></td></tr></table></figure><ul><li>回溯函数的三个参数</li></ul><p>n, 集合大小.   k 组合集合的大小(树的深度)</p><p><strong>startIndex</strong> 记录下一层递归从哪开始,避免重复</p><p>比如1,2,3,4下一层就要从2开始</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span><br></pre></td></tr></table></figure><ul><li>回溯终止条件</li></ul><p>path数组的大小等于k时,找到了一个子集大小为k的组合,在path存的就是根节点到叶子结点的路径</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">    result.push_back(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单层搜索的过程</li></ul><p>for循环, &#x3D;&gt;  横向遍历集合</p><p>递归 &#x3D;&gt; 纵向遍历</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">    path.push_back(i); <span class="comment">// 处理节点</span></span><br><span class="line">    backtracking(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">    path.pop_back(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯模版"><a href="#回溯模版" class="headerlink" title="回溯模版"></a>回溯模版</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= n; i++)&#123;</span><br><span class="line">            path.push_back(i); <span class="comment">// 处理结点</span></span><br><span class="line">            backtracking(n , k , i+<span class="number">1</span>); <span class="comment">//递归,不能使用++i改变原来的值</span></span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k , <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n ; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n, k , i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">            backtracking(n , k , <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h1><p>回溯法虽然是暴力搜索,但有时候也是可以剪枝优化的</p><p>在遍历中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当n &#x3D; 9, k &#x3D; 9, 那么 起始从2开始到9也不到9个数,</p><p>这个地方就可以剪枝了</p><ul><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ul><p>举一个<code>n = 9</code>  <code>k  - 4</code> 就知道上面三步操作是为什么了</p><p>for循环优化后</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) <span class="comment">// i为本次搜索的起始位置</span></span><br></pre></td></tr></table></figure><h1 id="Code-剪枝优化"><a href="#Code-剪枝优化" class="headerlink" title="Code(剪枝优化)"></a>Code(剪枝优化)</h1><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 优化的地方</span></span><br><span class="line">            path.push_back(i); <span class="comment">// 处理节点</span></span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.pop_back(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;77-组合&quot;&gt;&lt;a href=&quot;#77-组合&quot; class=&quot;headerlink&quot; title=&quot;77. 组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/combinations/&quot;&gt;77. 组合&lt;/a&gt;&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="回溯算法" scheme="https://axdmdyj.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–9-21-day16</title>
    <link href="https://axdmdyj.github.io/posts/8d213e83.html"/>
    <id>https://axdmdyj.github.io/posts/8d213e83.html</id>
    <published>2023-09-24T10:41:31.000Z</published>
    <updated>2023-11-12T08:53:08.575Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求最大深度, 首先可以想到,前序遍历和后序遍历</p><p>对于求深度,和求高度.都可以用后序遍历,因为一个二叉树的最大深度和最大的高度是相等的</p><p>那么如何求最大深度呢?</p><p>可以使用递归,即递归的求左右两节点的长度, 并将左右两节点的长度取最大值.</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241939134.png" alt="image-20230924185157004"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getdepth</span><span class="params">(TreeNode* node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = getdepth(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightdepth = getdepth(node-&gt;right);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + max(leftdepth,rightdepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getdepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getdepth</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftdepth</span> <span class="operator">=</span> getdepth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightdepth</span> <span class="operator">=</span> getdepth(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(leftdepth,rightdepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getdepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一眼看其实和求<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>类似,但还是有很多细节的区别的</p><p>因为当在根结点有空的子节点的时候就会出现错误</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241856074.png" alt="image-20230924185607931"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode* node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = getDepth(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = getDepth(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span> &amp;&amp;node-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + min(leftDepth,rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span> + Math.min(leftDepth,rightDepth);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>比较容易想到的就是后序遍历,做法跟前两道是一样的.</p><p>但因为是一个完全二叉树,根据完全二叉树的性质,我们又可以采用另一种方法</p><p>:<img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241941772.png" alt="image-20230924194150634"></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> getCount(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> getCount(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">countNodes</span> <span class="operator">=</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getCount(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用完全二叉树性质"><a href="#利用完全二叉树性质" class="headerlink" title="利用完全二叉树性质"></a>利用完全二叉树性质</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;104-二叉树的最大深度&quot;&gt;&lt;a href=&quot;#104-二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;104. 二叉树的最大深度&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problem</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="二叉树" scheme="https://axdmdyj.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–9-19-day14</title>
    <link href="https://axdmdyj.github.io/posts/de4f162b.html"/>
    <id>https://axdmdyj.github.io/posts/de4f162b.html</id>
    <published>2023-09-19T15:49:28.000Z</published>
    <updated>2023-11-12T08:53:08.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二叉树理论基础"><a href="#1-二叉树理论基础" class="headerlink" title="1. 二叉树理论基础"></a>1. 二叉树理论基础</h1><h2 id="1-1-二叉树的种类"><a href="#1-1-二叉树的种类" class="headerlink" title="1.1 二叉树的种类"></a>1.1 二叉树的种类</h2><ul><li>满二叉树: 每一个节点的子节点都为0或2</li><li>完全二叉树: 除了最底层的结点,其他结点每层节点数都达到最大值</li><li>二叉搜索树:所有左结点的值都小于根结点</li><li>平衡二叉树: 左右两个子树高度最大值不能超过1</li></ul><h2 id="1-2-二叉树存储方式"><a href="#1-2-二叉树存储方式" class="headerlink" title="1.2 二叉树存储方式"></a>1.2 二叉树存储方式</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储的元素在内存中是连续分布的，通常用数组来存储。如果父节点的数组下标是 root，那么它的左孩子就是 root * 2 + 1，右孩子就是 root * 2 + 2。</p><h3 id="1-3-二叉树的遍历方式"><a href="#1-3-二叉树的遍历方式" class="headerlink" title="1.3 二叉树的遍历方式"></a>1.3 二叉树的遍历方式</h3><ul><li><p>深度优先遍历 </p></li><li><blockquote><p>前序遍历,中序遍历, 后序遍历</p></blockquote></li><li><p>广度优先遍历</p></li><li><blockquote><p>层序遍历</p></blockquote></li></ul><h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Struct twoTreeNode&#123;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">twoTreeNode *left;</span><br><span class="line">twoTreeNode *right;</span><br><span class="line">twoTreeNode(<span class="type">int</span> x): val(x),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-二叉树理论基础&quot;&gt;&lt;a href=&quot;#1-二叉树理论基础&quot; class=&quot;headerlink&quot; title=&quot;1. 二叉树理论基础&quot;&gt;&lt;/a&gt;1. 二叉树理论基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-二叉树的种类&quot;&gt;&lt;a href=&quot;#1-1-二叉树的种类&quot; c</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="二叉树" scheme="https://axdmdyj.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–9-18-day13</title>
    <link href="https://axdmdyj.github.io/posts/e65c883c.html"/>
    <id>https://axdmdyj.github.io/posts/e65c883c.html</id>
    <published>2023-09-17T17:03:45.000Z</published>
    <updated>2023-11-12T08:53:08.573Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为要求滑动窗口中的最大值,</p><p>所以比较容易实现的便是,自己定义一个结构,能够让队列头始终是滑动窗口中最大的:</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309190106567.png" alt="image-20230919010607211"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309190106585.png" alt="image-20230919010613196"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQue</span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; value == deque.peek())&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty()  &amp;&amp; val &gt; deque.getLast())&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> deque.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k  + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 存放结果元素的数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">MyQue</span> <span class="variable">myque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[num++] = myque.peek();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++)&#123;</span><br><span class="line">        myque.poll(nums[i-k]);</span><br><span class="line"></span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">        res[num++] = myque.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++:</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQue</span>&#123;</span></span><br><span class="line">    Deque&lt;Integer&gt; <span class="built_in">deque</span> = new LinkedList&lt;&gt;();</span><br><span class="line">    <span class="type">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">deque</span>.isEmpty() &amp;&amp; value == <span class="built_in">deque</span>.peek())&#123;</span><br><span class="line">            <span class="built_in">deque</span>.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">deque</span>.isEmpty()  &amp;&amp; val &gt; <span class="built_in">deque</span>.getLast())&#123;</span><br><span class="line">                <span class="built_in">deque</span>.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">deque</span>.add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deque</span>.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = nums.length - k  + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 存放结果元素的数组</span></span><br><span class="line">    <span class="type">int</span>[] res = new <span class="type">int</span>[len];</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MyQue myque = new MyQue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[num++] = myque.peek();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">        myque.poll(nums[i-k]);</span><br><span class="line"></span><br><span class="line">        myque.add(nums[i]);</span><br><span class="line">        res[num++] = myque.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;239-滑动窗口最大值&quot;&gt;&lt;a href=&quot;#239-滑动窗口最大值&quot; class=&quot;headerlink&quot; title=&quot;239. 滑动窗口最大值&quot;&gt;&lt;/a&gt;&lt;a h</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="栈和队列" scheme="https://axdmdyj.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和Session区别</title>
    <link href="https://axdmdyj.github.io/posts/6bead416.html"/>
    <id>https://axdmdyj.github.io/posts/6bead416.html</id>
    <published>2023-09-16T16:13:08.000Z</published>
    <updated>2023-11-12T08:53:08.559Z</updated>
    
    <content type="html"><![CDATA[<p>Cookie和Session都用于管理用户的状态和身份，但它们在存储位置、数据容量、安全性和传输方式等方面存在一些关键区别，下面通过具体示例来说明这些区别：</p><ol><li><p>存储位置：</p><ul><li><strong>Cookie</strong>：Cookie数据存储在用户的浏览器中。这意味着服务器可以将一些信息存储在用户的计算机上，以便在后续请求中使用。</li><li><strong>Session</strong>：Session数据存储在服务器上，不会在用户浏览器中留下痕迹。</li></ul></li><li><p>数据容量：</p><ul><li><strong>Cookie</strong>：Cookie的存储容量通常较小，一般限制在几KB。这适用于存储少量的文本数据，如用户首选项或购物车中的几个商品。</li><li><strong>Session</strong>：Session的存储容量通常较大，不受明确定义的限制，因为它们可以利用服务器的资源，用于存储更多的数据，如用户登录状态、购物车内容等。</li></ul></li><li><p>安全性：</p><ul><li><strong>Cookie</strong>：由于Cookie存储在用户浏览器中，它们容易受到安全威胁。例如，Cookie可以被用户查看和修改，从而可能引发安全漏洞。</li><li><strong>Session</strong>：Session数据存储在服务器上，不容易被用户直接访问或篡改，因此相对更安全。</li></ul></li><li><p>传输方式：</p><ul><li><strong>Cookie</strong>：每次用户向服务器发送HTTP请求时，浏览器会自动将相关的Cookie信息附加到请求头中，以便服务器可以提取这些信息。</li><li><strong>Session</strong>：通常，Session ID会存储在Cookie中或者通过URL参数传递给服务器。服务器使用Session ID来查找并还原用户的会话数据。</li></ul></li></ol><p>示例：<br>假设有一个在线购物网站，用户在登录后可以将商品添加到购物车。以下是Cookie和Session在这个场景中的应用：</p><ul><li><p><strong>Cookie的应用</strong>：当用户登录后，服务器可以创建一个包含用户ID和购物车内容的Cookie，并在用户的浏览器中存储。每次用户浏览不同商品或查看购物车时，浏览器都会自动将Cookie信息发送到服务器，服务器通过Cookie中的用户ID来识别用户，并获取购物车内容。然而，由于Cookie易于修改，用户可能尝试篡改购物车中的商品数量。</p></li><li><p><strong>Session的应用</strong>：当用户登录后，服务器创建一个与该用户相关联的Session，其中包含用户ID和购物车内容等信息。Session数据存储在服务器上，而不会发送到用户浏览器中。每次用户进行操作时，服务器使用Session ID（通常存储在Cookie中）来查找并还原用户的购物车内容，而用户无法直接修改Session数据，因为它们位于服务器上，更加安全。</p></li></ul><p>综上所述，Cookie和Session在不同情况下用于管理用户状态和身份，具有各自的优势和限制，开发人员应根据应用程序的需求和安全性考虑选择合适的机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Cookie和Session都用于管理用户的状态和身份，但它们在存储位置、数据容量、安全性和传输方式等方面存在一些关键区别，下面通过具体示例来说明这些区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;存储位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cookie&lt;/strong&gt;</summary>
      
    
    
    
    <category term="每日八股" scheme="https://axdmdyj.github.io/categories/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="八股" scheme="https://axdmdyj.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法60天训练–9-15-day10</title>
    <link href="https://axdmdyj.github.io/posts/1e82b846.html"/>
    <id>https://axdmdyj.github.io/posts/1e82b846.html</id>
    <published>2023-09-15T10:20:28.000Z</published>
    <updated>2024-01-05T10:34:59.302Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先应该先明确队列是先进先出,</p><p>而栈是先进后出,而如果想用栈实现队列,就可以尝试用两个栈</p><p>进栈和出栈</p><ul><li>进栈模拟入队列</li><li>出栈模拟先出队列</li></ul><p>画图如下</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309171830073.png" alt="image-20230917183021976"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stIn;</span><br><span class="line">Stack&lt;Integer&gt; stOut;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      stIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">stIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span>(stOut.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stIn.isEmpty())&#123;</span><br><span class="line">        stOut.push(stIn.pop());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="built_in">this</span>.pop();</span><br><span class="line">stOut.push(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stOut.isEmpty()&amp;&amp;stIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line"></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">stIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(stOut.empty())&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stIn.empty())&#123;</span><br><span class="line">        stOut.push(stIn.top());</span><br><span class="line">        stIn.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> result = stOut.top();</span><br><span class="line">stOut.pop();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> res = this-&gt;pop();</span><br><span class="line">stOut.push(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stIn.empty()&amp;&amp;stOut.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度: push和empty为O(1), pop和peek为O(n)</p><p>空间复杂度: O(n)</p><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>队列是先进先出原则,</p><p>而栈是先进后出原则</p><p>因此,可以使用两个队列来实现栈</p><p><strong>可以使用一个队列来实现栈</strong></p><p>满足先进后出的方法就是; 入队列之后,就将这个数放到队首</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309171847163.png" alt="image-20230917184757095"></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">que.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> size = que.size();</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">while</span>(size--)&#123;</span><br><span class="line">    que.push(que.front());</span><br><span class="line">    que.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> que.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> que.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            que.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="keyword">return</span> que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que.poll();</span><br><span class="line">        que.add(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rePosition</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">        size--; <span class="comment">// 不包括刚刚添加的数</span></span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que.add(que.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: pop为O(n)，其他为O(1)</li><li>空间复杂度: O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;232-用栈实现队列&quot;&gt;&lt;a href=&quot;#232-用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;232. 用栈实现队列</summary>
      
    
    
    
    <category term="算法60天打卡" scheme="https://axdmdyj.github.io/categories/%E7%AE%97%E6%B3%9560%E5%A4%A9%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="栈和队列" scheme="https://axdmdyj.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
